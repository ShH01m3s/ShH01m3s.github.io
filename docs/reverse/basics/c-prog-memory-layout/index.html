<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Proccess Memory Layout - Analyst</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://bakerst221b.com/favicon.png">
  <link href="/css/style-classic.css"></link>
  
  
  <link rel="stylesheet" href="/css/style.min.564b5f4faf3af87992cb8ab298314448914c22dbdb3f2f9c584546b21b8d407c.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home ğŸ¡">
      <a href="/">
        <span>Home ğŸ¡</span>
      </a>
    </li>
    
    <li class="menu-item-blog âœï¸">
      <a href="/docs/blog">
        <span>Blog âœï¸</span>
      </a>
    </li>
    
    <li class="menu-item-dfir ğŸ”">
      <a href="/docs/dfir">
        <span>DFIR ğŸ”</span>
      </a>
    </li>
    
    <li class="menu-item-crypto ğŸ—ï¸">
      <a href="/docs/cryptography">
        <span>Crypto ğŸ—ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-reverse ğŸ”§">
      <a href="/docs/reverse">
        <span>Reverse ğŸ”§</span>
      </a>
    </li>
    
    <li class="menu-item-toolkit ğŸ§°">
      <a href="/docs/toolkit">
        <span>Toolkit ğŸ§°</span>
      </a>
    </li>
    
    <li class="menu-item-threat hunting ğŸª¤">
      <a href="/docs/thunting">
        <span>Threat Hunting ğŸª¤</span>
      </a>
    </li>
    
    <li class="menu-item-about me ğŸ§ğŸ½â€â™€ï¸">
      <a href="/docs/about">
        <span>About me ğŸ§ğŸ½â€â™€ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-tech reference ğŸ“š">
      <a href="/docs/reference">
        <span>Tech Reference ğŸ“š</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo.png" /></a>
    </div>
    <div class="logo-mobile">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo-mobile.svg" /></a>
    </div>
    

    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home ğŸ¡">
      <a href="/">
        <span>Home ğŸ¡</span>
      </a>
    </li>
    
    <li class="menu-item-blog âœï¸">
      <a href="/docs/blog">
        <span>Blog âœï¸</span>
      </a>
    </li>
    
    <li class="menu-item-dfir ğŸ”">
      <a href="/docs/dfir">
        <span>DFIR ğŸ”</span>
      </a>
    </li>
    
    <li class="menu-item-crypto ğŸ—ï¸">
      <a href="/docs/cryptography">
        <span>Crypto ğŸ—ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-reverse ğŸ”§">
      <a href="/docs/reverse">
        <span>Reverse ğŸ”§</span>
      </a>
    </li>
    
    <li class="menu-item-toolkit ğŸ§°">
      <a href="/docs/toolkit">
        <span>Toolkit ğŸ§°</span>
      </a>
    </li>
    
    <li class="menu-item-threat hunting ğŸª¤">
      <a href="/docs/thunting">
        <span>Threat Hunting ğŸª¤</span>
      </a>
    </li>
    
    <li class="menu-item-about me ğŸ§ğŸ½â€â™€ï¸">
      <a href="/docs/about">
        <span>About me ğŸ§ğŸ½â€â™€ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-tech reference ğŸ“š">
      <a href="/docs/reference">
        <span>Tech Reference ğŸ“š</span>
      </a>
    </li>
    
  </ul>
</div>
    
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
    
    <div style="margin-left: 20pt;">
      <a href="/index.xml" type="application/rss+xml">
        <img src="/images/rss.png" alt="RSS Feed">
      </a>
    </div>
    
    <style>
      a[href="/index.xml"] {
        display: inline-block;
        vertical-align: middle;
        margin-right: 10px;
      }
    
      a[href="/index.xml"] img {
        height: 30px;
      }
    </style>
    
  </div>
</div>


    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <p>
   <a href="/docs/reverse/basics/"> ğŸ‘ˆğŸ¼ Back to </br> ğŸ“š Basics </a>
  </p>
  <aside>
   <nav id="TableOfContents">
  <ul>
    <li><a href="#intro">Intro</a></li>
    <li><a href="#picture">Picture</a></li>
    <li><a href="#metaphor-and-analogy">Metaphor and Analogy</a></li>
    <li><a href="#memory-segmentation">Memory Segmentation</a>
      <ul>
        <li><a href="#cmd-args-and-env-vars">Cmd args and env vars</a></li>
        <li><a href="#stack">Stack</a></li>
        <li><a href="#heap">Heap</a></li>
        <li><a href="#bss">.BSS</a></li>
        <li><a href="#data">.Data</a></li>
        <li><a href="#text">.Text</a></li>
      </ul>
    </li>
    <li><a href="#summary">Summary</a></li>
  </ul>
</nav>
 </aside>
</div>



          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">Proccess Memory Layout</h1>
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    <div class="meta">
      
      
      <div class="article-category">
          
            
            
            
            
            
              <i class="fab fa-linux"></i>&nbsp;<i class="fab fa-apple"></i>&nbsp;<i class="fab fa-windows"></i>&nbsp;<i class="fas fa-mobile"></i>
            
            
          
          
      </div> <br />
      

      
      

      
      <div class="article-tag">
          <i class="fas fa-tag"></i>
          
          
          <a class="tag-link" href="/tags/reverse" rel="tag">reverse</a>
          
      </div> 
      
    </div>
    
    <b>Created:</b> 27.09.2020
    <br />

    

  </header>


  <div class="content" itemprop="articleBody">
    <h2 id="intro">Intro</h2>
<p>At the very beginning of my career I found it hard to grasp the notion of memory layout and stack. Even when I read about it several times, it didn&rsquo;t feel solid. That&rsquo;s why I drew drew and drew. Because my mind prefers pictures, analogies, metaphors and examples! So, I&rsquo;ve made that. May be someone finds it useful.</p>
<h2 id="picture">Picture</h2>
<p><img src="images/memoryLayoutC.png" alt="memoryLayoutC"></p>
<h2 id="metaphor-and-analogy">Metaphor and Analogy</h2>
<p>I was thinking about a good metaphor, but that was the extent of my imagination&hellip; Let&rsquo;s say some weirdo (let&rsquo;s call him Gargaralian) is piling up all the boring books he has ğŸ“š under the table because the appartment is too small and the luxury of having a bookcase is not an option available for him. Besides, the table is a little loose, so that pile of books could be like the fifth leg. Something like that:</p>
<p><img src="images/books_under_table.jpg" alt="books_under_table"></p>
<p><img src="images/books_under_table_2.png" alt="books_under_table_2"></p>
<p>He is piling them up to reach the table top. He has limited space from the floor to the table top, around <code>4294967295</code> of hydroget atoms (he&rsquo;s a weirdo, thus he counts table heights in atoms of hydrogen ğŸ¤“ ). For normal people, it&rsquo;s about 43 centimetres (around 17 inches). With each book ğŸ“˜ the distance to the table top is decreased â¬‡ï¸ . So, when he puts the first book, the distance becomes smaller - 39 cm. I think, you get the main idea. The same is with memory for each program: each one of them is given a limited space and it should decide wisely how to use it. Some programs might fail that task and have an overflow (when there are more books than the table height lets us pile), some underflow (when there are on the contrary not enough books and the table gets loose), but that&rsquo;s whole another story.</p>
<p>We will go from the top to the bottom, from the highest address (<code>0xffffffff</code>) to the lowest (<code>0x00000000</code>). As an example, I&rsquo;ll use <code>ping</code> program. So, we have 6 books&hellip;</p>
<h2 id="memory-segmentation">Memory Segmentation</h2>
<h3 id="cmd-args-and-env-vars">Cmd args and env vars</h3>
<p>This is our first ğŸ“˜, right on the floor. We are executing a program with some command line argument which now has the highest address in memory (around <code>0xffffffff</code>):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ping ya.ru
</span></span></code></pre></div><p>This goes on the very bottom of the pile. There is pretty much of space left!</p>
<h3 id="stack">Stack</h3>
<p>Grows towards lower memory addresses.</p>
<table>
<thead>
<tr>
<th>buffer[]</th>
</tr>
</thead>
<tbody>
<tr>
<td>flag (canary?)</td>
</tr>
<tr>
<td>SFP (EBP value of the caller)</td>
</tr>
<tr>
<td>ret</td>
</tr>
<tr>
<td>arg1</td>
</tr>
<tr>
<td>arg2</td>
</tr>
<tr>
<td>arg3</td>
</tr>
<tr>
<td>arg4</td>
</tr>
</tbody>
</table>
<p>To see the stack frame in <code>gdb</code> - <code>x/16xw $esp</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">stack_var</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">function</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">stack_var</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Both <code>main</code> and <code>function</code> have a <code>stack_var</code>. They are not the same. They only share the name, but in fact these only exist while the function&rsquo;s context exists. These are local variables.</p>
<p>Say, our custom ping program has a function <code>dns_request</code>. Let&rsquo;s have a closer look:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">int</span> <span class="n">dns_request</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">//make request
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">dns_request</span><span class="p">(</span><span class="s">&#34;ya.ru&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">function</span> <span class="kt">bool</span> <span class="n">dns_request</span> <span class="p">(</span><span class="kt">char</span> <span class="n">domain_name</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="kt">bool</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="k">struct</span> <span class="n">dns_request</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">     <span class="n">dns_request</span><span class="p">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="p">...</span>
</span></span><span class="line"><span class="cl">     <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">somefunc</span><span class="p">(</span><span class="n">dns_request</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">     <span class="p">...</span> 
</span></span><span class="line"><span class="cl">     <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>There is an interesting article <a href="https://opensource.com/article/19/5/how-write-good-c-main-function#:~:text=The%20main()%20function%20has,(negative%20one)%20on%20failure.&amp;text=The%20argument%20vector%2C%20argv%2C%20is,line%20that%20invoked%20your%20program.">about</a> primary function.</p>
</blockquote>
<p>What goes right on the stack? In general, everything that dies after function&rsquo;s finished executing and before it returns. Specifically (from the snippet above):</p>
<ol>
<li>function arguments (<code>char domain_name[]</code>)</li>
<li>Local variables (<code>bool result</code>, <code>int i</code>)</li>
</ol>
<p>Depending on archetecture and calling conventions, the code may differ a little, but I would like to show a snippet of C and the corresponding assembly below:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">function</span> <span class="kt">void</span> <span class="nf">_func1</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//assembly equivalent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//push 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//push 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//call _func2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_func2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">function</span> <span class="kt">int</span> <span class="nf">_func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//function prologue (behind the curtain --&gt; no equivalent in C)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//push ebp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//mov ebp, esp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="cl">  <span class="c1">//mov eax, [ebp + 8]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//mov edx, [ebp + 12]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//add eax, edx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">arg1</span> <span class="o">+</span> <span class="n">arg2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">//pop ebp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//ret
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>What goes on the stack (in assembly)? Everything that was <code>push</code>ed (<code>_func1</code>: <code>3</code> and <code>2</code>; <code>_func2</code>: <code>ebp</code>). So, in assembly, it&rsquo;s obvious what goes on the stack.</p>
<p><a href="http://eleceng.dit.ie/frank/IntroToC/Memory.html">Here</a> is an interesting article about the different layers of memory of a C-program. The author, among other things, states that we cannot use local variables to return values because the stack is freed after program execution. But the thing (is far as I know) is that the return values are put into the eax register before returning, so they are not technically on the stack any more. Of course, if you use not the value from the returned function but an address of the local variable (which would be utterly weird), then yes, there is no guarantee it wasn&rsquo;t overwritten.</p>
<p>What I&rsquo;d also like to mention in the context of stack is that even though they say it&rsquo;s freed, it&rsquo;s not actually released per se. There is an esp register, which is very interesting.</p>
<p>Is underflow specific to stack?</p>
<h3 id="heap">Heap</h3>
<p>Stack vs Heap <a href="https://gribblelab.org/CBootCamp/7_Memory_Stack_vs_Heap.html">article</a>.</p>
<p>Doesn&rsquo;t have a fixed size. The growth of the heap moves downward toward higher memory addresses. So, heap grows toward stack and stack - toward heap. One day when they meet (if they meet), you&rsquo;ll deal with stack or heap overflow.</p>
<p>Variable need to be allocated first with a <code>malloc()</code> function. Pointers are usually used to reference heap variables.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">heap_var</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>If it can&rsquo;t allocate memory, it will return a <code>NULL</code> pointer (<code>0x0</code>). There once was a vulnerability in BootROM on iOS devices regarding this (Alloc8 exploit).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp"># Good code
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">pointer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// handle error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// pointer is valid, continue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp"># Bad code in alloc8 vulnerable BootROM
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">pointer</span> <span class="o">==</span> <span class="mh">0x8</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// handle error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// pointer is valid, continue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>For some reason, the return value was compared to <code>0x8</code>, not <code>NULL</code> or even <code>0x0</code>. Typo?</p>
<p>After the memory is no longer needed, you must call <code>free()</code> on this memory location. However, it will still be reused once the new malloc is called, even after freeing the memory space. It depends on the system, how the allocation functions are implemented, and the block size to allocate.</p>
<h3 id="bss">.BSS</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">global_var</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">int</span> <span class="n">uninit_var</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// some code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>This memory segment holds <strong>uninitialised</strong> global and static variables. Have a fixed size. Writable.</p>
<h3 id="data">.Data</h3>
<p>You can read about static variables, functions, classes and class members here.</p>
<p>This memory segment holds initialised global and static variables. Have a fixed size. Writable.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">global_var</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">int</span> <span class="n">uninit_var</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// some code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="text">.Text</h3>
<p>It contains the actual code of the program. It&rsquo;s usually (and better be) read-only to prevent changes to the code. Also, different instances of the same process can share this memory portion.</p>
<h2 id="summary">Summary</h2>
<p>Consider the following code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span> <span class="err">ğŸšœ</span> <span class="n">plough</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="cp"># Plough the soil to plant the seed
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span> <span class="err">ğŸŒ±</span> <span class="n">seed</span><span class="p">(</span><span class="kt">int</span> <span class="n">seed</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="cp"># Plant the seed
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="n">plough</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span> <span class="err">ğŸ¥€</span> <span class="n">grow_rose</span><span class="p">(</span><span class="kt">int</span> <span class="n">seed</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="cp"># grow and get a rose
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">grow_rose</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span></code></pre></div><p>To grow a rose ğŸ¥€, one must first plant and nurture a seedling ğŸŒ±. But before planting the seed, one must first plough ğŸšœ the soil. So, here are the steps: ğŸ¥€ <code>get_rose</code> &lt;- ğŸŒ± <code>seed</code> &lt;- ğŸšœ <code>plough</code>.</p>
<p>In other words:</p>
<ul>
<li><input disabled="" type="checkbox"> ğŸšœ <code>plough</code></li>
<li><input disabled="" type="checkbox"> ğŸŒ± <code>seed</code></li>
<li><input disabled="" type="checkbox"> ğŸ¥€ <code>grow_rose</code></li>
</ul>
<p>But what does it look like on the stack? Depending on the system, the stack grows up (towards the highest address) or down (towards the lowest address). Let&rsquo;s assume we are dealing with a system where stack grows down. There are three important registers that hold the value that&rsquo;s different for each function: <code>ESP</code> pointing to the top of the stack (aka stack pointer), <code>EBP</code> pointing to the start of a frame of a function (aka base pointer) and <code>EIP</code> pointing to the code currently being executed (aka function pointer).</p>
<p>Each function&rsquo;s belongings on the stack are called a stack frame. Each function gets one. I don&rsquo;t know about you, but I&rsquo;ve watched my fair share of detective movies and series, and when they show someone getting arrested, they come to jail, register and leave all their belongings. They get them back when they are released. You might relate this to a stack: <em>please save this and that until I return</em>.</p>
<p>The <code>EBP</code> value is needed in order to &ldquo;delete&rdquo; the bunch of stuff stored on the stack for this particular function. They are not actually deleted, they will eventually get overwritten, but since <code>EBP</code> is no logner pointing there, and <code>ESP</code> is restored to the value of the EBP, <code>they</code> are not available for the code.</p>
<p>Here is a little picture of a stack, that shows how <code>EBP</code> can be moved up and down. Here is how the stack is built:</p>
<p><img src="images/growing-stack.png" alt="img"></p>
<p>On the other hand, <code>ESP</code> is moving up and down WITHIN the given frame, with each addition or removal from the stack. <code>EBP</code> stays the same WITHIN the frame and changes only when the frame is changed. Since all local variables are added at the beginning of the function in assembly (regardless of where those were added in the source code), and CPU knows the number of those local variables, it can use EBP as a base and calcilate the address of each variable by adding multiples of 32-bits (8 bytes) to the EBP. It&rsquo;s pretty much the same thing as with relative virtual addresses and image base described <a href="https://bakerst221b.com/docs/reverse/basics/memory-addressing/">here</a>.</p>
<p>Below is a picture of one frame to visualise the difference between <code>EBP</code> and <code>ESP</code>:</p>
<p><img src="images/esp-ebp.png" alt="img"></p>
<p>In the pictures above, fingers pointing to the right ğŸ‘‰ğŸ¾ are <code>EBP</code> pointers, palm-front â˜ğŸ¾ is <code>ESP</code> and ğŸ‘ˆğŸ¾ is a saved <code>EIP</code> (return address). Each function has a finger of different colour, making tracking the changes in the pictures easier. The ğŸ¥€ <code>grow_rose</code>&rsquo;s base pointer is of the darker colour ğŸ‘‰ğŸ¾, and its <code>EIP</code> (function pointer) is of the same colour but pointing to the left ğŸ‘ˆğŸ¾. The ğŸŒ±<code>seed</code> function&rsquo;s <code>EBP</code> ğŸ‘‰ and EIP ğŸ‘ˆ are yellow. And last but not least, the ğŸšœ <code>plough</code> function&rsquo;s <code>EBP</code> ğŸ‘‰ğŸ¼ and <code>EIP</code> ğŸ‘ˆğŸ¼ are both beige.</p>
<p>Now, when the ğŸšœ <code>plough</code> function returns, the CPU retrieves the ğŸŒ±<code>seed</code> function&rsquo;s <code>EBP</code> ğŸ‘‰ from the ğŸšœ <code>plough</code> function&rsquo;s stack frame so that now <code>EBP</code> points to the base of this stack frame, which is now ğŸŒ±<code>seed</code> function&rsquo;s frame. It also returns the <code>EIP</code> value from the stack, knowing which line of code to execute next.</p>
<p><img src="images/removing-from-stack.png" alt="img"></p>
<blockquote>
<p>Just in case you are wondering, return values is stored in the <code>EAX</code> register, not on the stack.</p>
</blockquote>
<p>Something similar happens to the <code>EIP</code> register.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span> <span class="err">ğŸšœ</span> <span class="n">plough</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="err">ğŸ‘‰ğŸ¼</span> <span class="err">#</span> <span class="n">Plough</span> <span class="n">the</span> <span class="n">soil</span> <span class="n">to</span> <span class="n">plant</span> <span class="n">the</span> <span class="n">seed</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span> <span class="err">ğŸŒ±</span> <span class="n">seed</span><span class="p">(</span><span class="kt">int</span> <span class="n">seed</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="cp"># Plant the seed
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="err">ğŸ‘‰</span> <span class="n">plough</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">func</span> <span class="err">ğŸ¥€</span> <span class="n">grow_rose</span><span class="p">(</span><span class="kt">int</span> <span class="n">seed</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="cp"># grow and get a rose
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="err">ğŸ‘‰ğŸ¾</span> <span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">grow_rose</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span></code></pre></div><p>When the callee function returns, thanks to the saved <code>EIP</code> value on the stack, the CPU knows where to resume the code. Think of the <code>EBP</code> as a bookmark for stack and <code>EIP</code> - as a bookmark for code.</p>
<p>When a function is called, it prepares a nest ğŸªº for itself, a cosy one (like a pregnant woman during the nesting period). It&rsquo;s called a <strong>function prologue</strong>. After all the fun is over, the function &ldquo;cleans the mess&rdquo;, which we call the <strong>function epilogue</strong>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">push ebp &lt;- function prologue for the main function
</span></span><span class="line"><span class="cl">mov ebp,esp
</span></span><span class="line"><span class="cl">sub esp,0x8
</span></span><span class="line"><span class="cl">and esp, 0xfffffff0
</span></span><span class="line"><span class="cl">mov eax,0x0
</span></span><span class="line"><span class="cl">sub esp,eax
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">push 20
</span></span><span class="line"><span class="cl">push 10
</span></span><span class="line"><span class="cl">call Addme
</span></span><span class="line"><span class="cl">	...
</span></span><span class="line"><span class="cl">	push ebp # &lt;- function prologue for the AddMe function
</span></span><span class="line"><span class="cl">	mov ebp,esp
</span></span><span class="line"><span class="cl">	sub esp,4
</span></span><span class="line"><span class="cl">	...
</span></span><span class="line"><span class="cl">	mov esp,ebp # &lt;- function epilogue for the AddMe function, stack is cleaned, i.e. stackpointer is moved up 
</span></span><span class="line"><span class="cl">	pop ebp # EBP restored
</span></span><span class="line"><span class="cl">	ret # EIP restored
</span></span></code></pre></div><p>A little note before we part, I remember being very confused about what were the following lines:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">sub esp,0x8
</span></span><span class="line"><span class="cl">and esp, 0xfffffff0
</span></span></code></pre></div><p>Let&rsquo;s start with the first line, <code>sub esp,0x8</code>. Remember that the stack is growing towards the LOWEST address? So, the <code>ESP</code> pointer gets smaller each time the stack grows. When we ADD something to the stack, we need to SUBTRACT from the stack pointer. When we want to DELETE something, we ADD. A little confusing, I know. Remember, though, on some systems stack grows downwards!</p>
<p>If you see the source code for the assembly above, or if you prefer the hardcore way, you may notice that there are two local variables, integers <code>20</code> and <code>10</code>. Integers on a 32-bit system are 4 bytes in size. So, two integers is 8 bytes. By substracting 8 from the ESP we are moving the stack pointer down towards the lowest address and thus preparing the nestğŸªº for the two local variables.</p>
<p>The second line, <code>and esp, 0xfffffff0</code> is for the alignment purposes as all addresses need to be aligned to 16-byte (in case of 32-bit systems at least) for some operations. The <code>0xfffffff0</code> mask used with AND operand clears the last bytes of the ESP. Here is what this mask looks like in binary:</p>
<p><img src="images/and-mask.png" alt="img"></p>
<p>As you can see, the last 4 bits are equal to <code>0</code>. When <code>1</code> is <code>AND</code>ed with <code>0</code>, you get <code>0</code>. When something get&rsquo;s <code>AND</code>ed with <code>1</code>, it remains as it was. So, for the first 28 bits all <code>1</code>s will remain <code>1</code>s and all <code>0</code>s will remain <code>0</code>s. For the last 4 bits, regardless of the original value, all the 4 bits will be set to <code>0</code>. Pretty much as if we were multiplying by <code>1</code> or <code>0</code>, same effect here.</p>
<p>The following line <code>mov eax,0x0</code>, I assume, is for making sure that the <code>EAX</code> register is cleaned before used (it&rsquo;s always used for the return value on Windows and some other systems). However, I don&rsquo;t yet understand what that&rsquo;s for: <code>sub esp,eax</code>.</p>

  </div>
</article>
</div>
</div>

        </div>
      </div>
    </div>
    
  </div>

  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            <li class="zerostatic"><a href="https://www.zerostatic.io">www.zerostatic.io</a></li>
            </ul>
        </div>
      </div>
    </div>
  </div>
</div>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.302a6fc365d5139fb98cf60bdb8f715d96257ea189161d36c190ccfa8182e569.js"></script>
  

  
  
  
    
  


</body>

</html>
