<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Meltdown &amp; Spectre - Analyst</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://bakerst221b.com/favicon.png">
  <link href="/css/style-classic.css"></link>
  
  
  <link rel="stylesheet" href="/css/style.min.564b5f4faf3af87992cb8ab298314448914c22dbdb3f2f9c584546b21b8d407c.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home 🏡">
      <a href="/">
        <span>Home 🏡</span>
      </a>
    </li>
    
    <li class="menu-item-blog ✍️">
      <a href="/docs/blog">
        <span>Blog ✍️</span>
      </a>
    </li>
    
    <li class="menu-item-dfir 🔍">
      <a href="/docs/dfir">
        <span>DFIR 🔍</span>
      </a>
    </li>
    
    <li class="menu-item-crypto 🗝️">
      <a href="/docs/cryptography">
        <span>Crypto 🗝️</span>
      </a>
    </li>
    
    <li class="menu-item-reverse 🔧">
      <a href="/docs/reverse">
        <span>Reverse 🔧</span>
      </a>
    </li>
    
    <li class="menu-item-toolkit 🧰">
      <a href="/docs/toolkit">
        <span>Toolkit 🧰</span>
      </a>
    </li>
    
    <li class="menu-item-threat hunting 🪤">
      <a href="/docs/thunting">
        <span>Threat Hunting 🪤</span>
      </a>
    </li>
    
    <li class="menu-item-about me 🧝🏽‍♀️">
      <a href="/docs/about">
        <span>About me 🧝🏽‍♀️</span>
      </a>
    </li>
    
    <li class="menu-item-tech reference 📚">
      <a href="/docs/reference">
        <span>Tech Reference 📚</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo.png" /></a>
    </div>
    <div class="logo-mobile">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo-mobile.svg" /></a>
    </div>
    

    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home 🏡">
      <a href="/">
        <span>Home 🏡</span>
      </a>
    </li>
    
    <li class="menu-item-blog ✍️">
      <a href="/docs/blog">
        <span>Blog ✍️</span>
      </a>
    </li>
    
    <li class="menu-item-dfir 🔍">
      <a href="/docs/dfir">
        <span>DFIR 🔍</span>
      </a>
    </li>
    
    <li class="menu-item-crypto 🗝️">
      <a href="/docs/cryptography">
        <span>Crypto 🗝️</span>
      </a>
    </li>
    
    <li class="menu-item-reverse 🔧">
      <a href="/docs/reverse">
        <span>Reverse 🔧</span>
      </a>
    </li>
    
    <li class="menu-item-toolkit 🧰">
      <a href="/docs/toolkit">
        <span>Toolkit 🧰</span>
      </a>
    </li>
    
    <li class="menu-item-threat hunting 🪤">
      <a href="/docs/thunting">
        <span>Threat Hunting 🪤</span>
      </a>
    </li>
    
    <li class="menu-item-about me 🧝🏽‍♀️">
      <a href="/docs/about">
        <span>About me 🧝🏽‍♀️</span>
      </a>
    </li>
    
    <li class="menu-item-tech reference 📚">
      <a href="/docs/reference">
        <span>Tech Reference 📚</span>
      </a>
    </li>
    
  </ul>
</div>
    
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
    
    <div style="margin-left: 20pt;">
      <a href="/index.xml" type="application/rss+xml">
        <img src="/images/rss.png" alt="RSS Feed">
      </a>
    </div>
    
    <style>
      a[href="/index.xml"] {
        display: inline-block;
        vertical-align: middle;
        margin-right: 10px;
      }
    
      a[href="/index.xml"] img {
        height: 30px;
      }
    </style>
    
  </div>
</div>


    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <p>
   <a href="/docs/reverse/exploits/"> 👈🏼 Back to </br> ⚙️ Exploits </a>
  </p>
  <aside>
   <nav id="TableOfContents">
  <ul>
    <li><a href="#speculative-execution">Speculative Execution</a>
      <ul>
        <li><a href="#diving-deeper">Diving Deeper</a></li>
      </ul>
    </li>
    <li><a href="#meltdown">Meltdown</a></li>
    <li><a href="#spectre">Spectre</a></li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
 </aside>
</div>



          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">Meltdown &amp; Spectre</h1>
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    <div class="meta">
      
      

      
      

      
    </div>
    
    <b>Created:</b> 28.07.2022
    <br />

    

  </header>


  <div class="content" itemprop="articleBody">
    <p><em>Several years ago, the internet was flooded with news about two famous vulnerabilities: Meltdown and Spectre. It took me some time to understand how both of them work, but here are the results of my attempt. To understand the mechanics of these two vulnerabilities, one needs to understand the basics that I&rsquo;ve tried to explain in the article <a href="https://bakerst221b.com/docs/reverse/basics/cpu">here</a>.</em></p>
<h2 id="speculative-execution">Speculative Execution</h2>
<p>The core problen with these two fellas, is the speculative (ahead and out of order) execution.</p>
<p>Imagine a couple: a man 🕺🏼 and a woman 💃🏻. The woman has a little problem with alcohol 🍷 . So, they have come up with a solution not to let her go down the mine but also not to make her life too boring as well. She can have a fair share of her favourite wine only if they are having a steak 🥩 for dinner. Neat 🙂 Now, they have run out of meat and the husband 🕺🏼 went to the shop. The woman 💃🏻 doesn&rsquo;t know if he buys a steak or not, but just to safe the time for opening the wine and letting it decante for a while, she opens the bottle anyway hoping he will not return empy-handed. If her husband succeeds with the quest of the steak-hunt, she can safely drink the wine and enjoy the evening. Otherwise, she will get rid of the wine 🍷 . I know, what a waste!</p>
<p>This is a rough idea of speculative execution.</p>
<p>Consider the following code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="err">🪰</span> <span class="o">&lt;</span> <span class="err">🐘</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="err">🕺🏼</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>If 🐘&rsquo;s size is not in the cache and needs to be calculated, the CPU speculates that the condition is met and executed the body of the <code>if</code> statement. The moment we know the 🐘&rsquo;s size, and if it&rsquo;s smaller the the 🪰, the result of the operation withing the body of the <code>if</code> statement is discarded.</p>
<p>But 💃🏻 didn&rsquo;t drink the wine since there was no steak, no hard done, right? Well, one could smell the wine 🍷 when coming to the kitchen, and deducing that she was going to have a steak 🥩. This is a very rough analogy for a side-channel attack. You can&rsquo;t see the wine, but the smell of the steak can give you a hint.</p>
<p>Now, let&rsquo;s take another analogy that&rsquo;s closer aligned with the code below. Let&rsquo;s say, that we have safe deposit boxes in a private vault. This vault is protected by guards, systems, alarms etc. A 👱🏻‍♀️ woman called Janice is the only person who has access to the keys. She keeps them all in her drawer, but those that were used recently, she keeps on the table. It&rsquo;s a usual thing for her to be required to open the same deposit box shortly after it was open: people ofter forget stuff. People come, provide their identifications and if all is alright, she opens the box for them. Most of the time, people coming in do have access to the vault, and thus usually pass the check. So, while the security guard checks the person for guns and drugs and checks their identification cards 🪪, Janice finds the key that&rsquo;s needed and goes to safe deposit box. She opens it. If the person doesn&rsquo;t pass the check for some reason, he is not let in. Janice closes the box and returns back to her desk. The person coming can see if Janice is at her desk and how quickly she stands up with a key to the box. So, he can deduce wether she&rsquo;s using the key from the table or from the drawer based on how quickly she finds it. So, imagine a thief needs to know if some known businessmen owning a safe deposit box has accessed it recently. By impersonating this businessmen and observing how quickly Janice finds the key, he can know if the businessman in question has recently opened his vault.</p>
<h3 id="diving-deeper">Diving Deeper</h3>
<p>Now, let&rsquo;s see what the actual technicalities are.</p>
<p>There are 256 possible values for a byte: from <code>0x00</code> to <code>0xFF</code> (or from <code>0</code> to <code>255</code> in decimal, or <code>0000 0000</code> to <code>1111 1111</code> in binary).</p>
<p>We create an array with all the <code>255</code> possible values for 1 byte. In the picture below, the numbers in squares represent indices of the arrays <code>kernel</code> and <code>probe_array</code>. Numbers and emojis above - actual data in the array. <code>probe_array</code> contains no data or garbage - we don&rsquo;t really care about it. We only care about its indices. However, for the <code>kernel</code> array we do care about the actual values.</p>
<p><img src="images/spec-exec-1.png" alt="img"></p>
<p>Then, we try accessing data in the <code>probe_array</code> at the index that&rsquo;s equal to the data retrieved from the kernel memory (which can only be a value from <code>0</code> to <code>255</code>). We don&rsquo;t see which value that is, but the CPU knows the value at <code>kernel[0]</code> which is <code>3</code>🍓 and uses it to get the value at <code>probe_array[🍓]</code>. It also saves the address of <code>probe_array[3🍓]</code> to its cache for quicker retrieval the next time it&rsquo;s needed.</p>
<p><img src="images/spec-exec-2.png" alt="img"></p>
<p>However, our process doesn&rsquo;t have access to this area of memory, so, the CPU discards the result. But! It doesn&rsquo;t clear the cache, so that <code>probe_array[3🍓]</code> is still there.</p>
<p><img src="images/spec-exec-3.png" alt="img"></p>
<p>While the <code>probe_array[3🍓]</code> is still in the cache, we will try accessing each of the 256 items in the <code>probe_array</code> to see which value is retrieved quicker than others.</p>
<p><img src="images/spec-exec-4.png" alt="img"></p>
<p>We start at <code>probe_array[0]</code>. Say, it takes CPU 10 seconds 🕙 to get back to us (yeah, our CPU is super slow, just for the simplicity’s sake). We repeat this step for <code>probe_array[1]</code> and <code>probe_array[2]</code>. We get the result in 10 seconds 🕙 again.</p>
<p><img src="images/spec-exec-5.png" alt="img">
Once we get to <code>probe_array[3🍓]</code> we get the result in 2 seconds 🕑 as opposed to 10 seconds 🕙. So, we can assume that this value was in the cache, thus, the byte at <code>kernel[0]</code> equals to <code>3🍓</code>.</p>
<blockquote>
<p>❗️One thing the attacker needs to make sure of, is the the cache is cleared after each probe of the kernel byte (at step 1 in the pictures).</p>
</blockquote>
<p>Let&rsquo;s now see the code. I have marked some places with the same emojis as in the pictures above.</p>
<blockquote>
<p>❗️Multiplication by <code>4096</code> is needed because memory is allocated in pages that are of <code>4096</code> bytes in size. We can ignore it in the illustration for simplicity&rsquo;s sake.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">kernel_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">kernel_address</span><span class="p">;</span>  <span class="c1">// Kernel address to read from, aka, our kernel array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">probe_array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="mi">256</span><span class="o">*</span><span class="mi">4096</span><span class="p">];</span>  <span class="c1">// The probe array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Out-of-order execution and caching
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">uint8_t</span> <span class="err">🍓</span> <span class="o">=</span> <span class="n">kernel_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// the value at index 0 is 3🍓. We fetch byte from kernel memory, triggers exception but gets speculatively executed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">uint8_t</span> <span class="n">dummy</span> <span class="o">=</span> <span class="n">probe_array</span><span class="p">[</span><span class="err">🍓</span><span class="o">*</span><span class="mi">4096</span><span class="p">];</span>  <span class="c1">// Access the corresponding index in the probe array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Measure access times for each index in the probe array, the fastest one reveals the secret byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">measure_access_time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">probe_array</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4096</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// When we reach probe_array[🍓], we get our guy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="meltdown">Meltdown</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"></code></pre></div><h2 id="spectre">Spectre</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Spectre pseudocode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">probe_array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="mi">256</span><span class="o">*</span><span class="mi">4096</span><span class="p">];</span>  <span class="c1">// Probe array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">uint8_t</span> <span class="n">array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>  <span class="c1">// Some array in our program
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">array_bound</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>  <span class="c1">// Pointer to just past the end of the array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">300</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Train the CPU branch predictor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_mm_clflush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array_bound</span><span class="p">);</span>  <span class="c1">// Flush array_bound from cache
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">volatile</span> <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">z</span><span class="o">++</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// Delay (optional)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">%</span> <span class="mi">6</span><span class="p">)</span> <span class="o">?</span> <span class="nl">array</span> <span class="p">:</span> <span class="n">kernel_address</span><span class="p">;</span>  <span class="c1">// Triggers branch misprediction after sufficient training
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">array_bound</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">uint8_t</span> <span class="n">value</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// Speculatively fetch byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">uint8_t</span> <span class="n">dummy</span> <span class="o">=</span> <span class="n">probe_array</span><span class="p">[</span><span class="n">value</span><span class="o">*</span><span class="mi">4096</span><span class="p">];</span>  <span class="c1">// Speculatively access probe array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Measure access times for each index in the probe array, the fastest one reveals the secret byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">measure_access_time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">probe_array</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4096</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// &#39;i&#39; is potentially the value from kernel memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="references">References</h2>
<details>
    <summary>Expand&hellip;</summary>
    <p><a href="https://bakerst221b.com/docs/reverse/basics/memory-addressing/">This</a>, <a href="https://bakerst221b.com/docs/reverse/basics/c-prog-memory-layout/">this</a> and <a href="https://bakerst221b.com/docs/reverse/basics/tlb">this</a> article can help gain some initial understanding of memory addressing and layout.</p>
<p><a href="https://github.com/IAIK/meltdown">https://github.com/IAIK/meltdown</a>
<a href="https://hackernoon.com/a-simplified-explanation-of-the-meltdown-cpu-vulnerability-ad316cd0f0de">https://hackernoon.com/a-simplified-explanation-of-the-meltdown-cpu-vulnerability-ad316cd0f0de</a></p>
<p><a href="https://seedsecuritylabs.org/Labs_16.04/PDF/Meltdown_Attack.pdf">https://seedsecuritylabs.org/Labs_16.04/PDF/Meltdown_Attack.pdf</a></p>
<p><a href="https://seedsecuritylabs.org/Labs_16.04/PDF/Spectre_Attack.pdf">https://seedsecuritylabs.org/Labs_16.04/PDF/Spectre_Attack.pdf</a></p>

</details>
  </div>
</article>
</div>
</div>

        </div>
      </div>
    </div>
    
  </div>

  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            <li class="zerostatic"><a href="https://www.zerostatic.io">www.zerostatic.io</a></li>
            </ul>
        </div>
      </div>
    </div>
  </div>
</div>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.302a6fc365d5139fb98cf60bdb8f715d96257ea189161d36c190ccfa8182e569.js"></script>
  

  
  
  
    
  


</body>

</html>
