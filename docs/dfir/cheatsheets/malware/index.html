<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤔 How Do I Spot Malware? - Analyst</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://bakerst221b.com/favicon.png">
  <link href="/css/style-classic.css"></link>
  
  
  <link rel="stylesheet" href="/css/style.min.564b5f4faf3af87992cb8ab298314448914c22dbdb3f2f9c584546b21b8d407c.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home 🏡">
      <a href="/">
        <span>Home 🏡</span>
      </a>
    </li>
    
    <li class="menu-item-blog ✍️">
      <a href="/docs/blog">
        <span>Blog ✍️</span>
      </a>
    </li>
    
    <li class="menu-item-dfir 🔍">
      <a href="/docs/dfir">
        <span>DFIR 🔍</span>
      </a>
    </li>
    
    <li class="menu-item-crypto 🗝️">
      <a href="/docs/cryptography">
        <span>Crypto 🗝️</span>
      </a>
    </li>
    
    <li class="menu-item-toolkit 🧰">
      <a href="/docs/toolkit">
        <span>Toolkit 🧰</span>
      </a>
    </li>
    
    <li class="menu-item-about me 🧝🏽‍♀️">
      <a href="/docs/about">
        <span>About me 🧝🏽‍♀️</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo.png" /></a>
    </div>
    <div class="logo-mobile">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo-mobile.svg" /></a>
    </div>
    

    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home 🏡">
      <a href="/">
        <span>Home 🏡</span>
      </a>
    </li>
    
    <li class="menu-item-blog ✍️">
      <a href="/docs/blog">
        <span>Blog ✍️</span>
      </a>
    </li>
    
    <li class="menu-item-dfir 🔍">
      <a href="/docs/dfir">
        <span>DFIR 🔍</span>
      </a>
    </li>
    
    <li class="menu-item-crypto 🗝️">
      <a href="/docs/cryptography">
        <span>Crypto 🗝️</span>
      </a>
    </li>
    
    <li class="menu-item-toolkit 🧰">
      <a href="/docs/toolkit">
        <span>Toolkit 🧰</span>
      </a>
    </li>
    
    <li class="menu-item-about me 🧝🏽‍♀️">
      <a href="/docs/about">
        <span>About me 🧝🏽‍♀️</span>
      </a>
    </li>
    
  </ul>
</div>
    
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
    
    <div style="margin-left: 20pt;">
      <a href="/index.xml" type="application/rss+xml">
        <img src="/images/rss.png" alt="RSS Feed">
      </a>
    </div>
    
    <style>
      a[href="/index.xml"] {
        display: inline-block;
        vertical-align: middle;
        margin-right: 10px;
      }
    
      a[href="/index.xml"] img {
        height: 30px;
      }
    </style>
    
  </div>
</div>


    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <p>
   <a href="/docs/dfir/cheatsheets/"> 👈🏼 Back to </br> Artefacts CheatSheet </a>
  </p>
  <aside>
   <nav id="TableOfContents">
  <ul>
    <li><a href="#windows">Windows</a>
      <ul>
        <li><a href="#-ram">💭 RAM</a></li>
        <li><a href="#parents-and-children">Parents and Children</a></li>
        <li><a href="#wincore-vs-non-core">WinCore vs Non-Core</a></li>
        <li><a href="#singletons">Singletons</a></li>
        <li><a href="#boot-times">Boot Times</a></li>
        <li><a href="#deviations">Deviations</a></li>
        <li><a href="#processes">Processes</a>
          <ul>
            <li><a href="#command-line">Command line</a></li>
            <li><a href="#files">Files</a></li>
            <li><a href="#shimcache">Shimcache</a></li>
            <li><a href="#dlls">DLLs</a></li>
            <li><a href="#handles">Handles</a></li>
            <li><a href="#drivers">Drivers</a></li>
            <li><a href="#permissions">Permissions</a></li>
            <li><a href="#network">Network</a></li>
            <li><a href="#injections">Injections</a></li>
            <li><a href="#hooks">Hooks</a></li>
            <li><a href="#dkom">DKOM</a></li>
          </ul>
        </li>
        <li><a href="#common-malware">Common Malware</a>
          <ul>
            <li><a href="#cobalt-strike">Cobalt Strike</a></li>
          </ul>
        </li>
        <li><a href="#iocs">IOCs</a></li>
      </ul>
    </li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
 </aside>
</div>



          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">🤔 How Do I Spot Malware?</h1>
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    <div class="meta">
      
      

      
      

      
    </div>
    
    <b>Created:</b> 27.06.2023
    <br />

    

  </header>


  <div class="content" itemprop="articleBody">
    <p><em>The number or applications installed or present on a device can sometimes be frightening. Not all of them are installed with the user&rsquo;s consent. Some of them might be malicious. How does one spot these little pesky rodents?</em></p>
<p>System faults, errors and crashes can be spotted via System (errors, warnings and critical) and application events.</p>
<h2 id="windows">Windows</h2>
<p>🪵 <strong>Event logs</strong>: ⚙️ System, 📱Application</p>
<table>
<thead>
<tr>
<th>🏺 Artefact</th>
<th>📝 Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>🪵 Event logs</td>
<td>⚙️ errors, warning and critical<!-- raw HTML omitted -->📱1000 (error), 1001 (WER), 1002 (hanging)</td>
</tr>
<tr>
<td>📑 WER</td>
<td>📂 <code>C:\Microsoft\Windows\WER</code> 🛠️ <code>NinjaCopy</code> can collect that.</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="-ram">💭 RAM</h3>
<p>The best place to find malware is in RAM. At some point, it needs to run. Either get the RAM copy or some alternative like a <code>hiberfil.sys</code>. There are several techniques to use to identify malware in the RAM image: signature-based search (like with most AV), contradictions (something is not right there), heuristic/behavioural (the system or a process is behaving weirdly and unexpectedly).</p>
<p>Deviations = investigative leads. <strong>Core Processes</strong> - essential for Win, run on any Win system under examination.</p>
<p><img src="images/standart-proc-win.png" alt="standart-proc-win"></p>
<h3 id="parents-and-children">Parents and Children</h3>
<ul>
<li>check names</li>
<li>parent (for example, <code>svchost.exe</code> is started by <code>services.exe</code>)</li>
<li>expected path</li>
<li>Singleton?</li>
<li>Account (local system, mane, users)</li>
<li>start time (boot time, later)</li>
<li>Security identifier (SID)</li>
</ul>
<p><code>svchost.exe</code> - the most abused process. Check for the above deviations in the result.</p>
<p>One thing to do is compare the output from both <code>psllist</code> and <code>psscan</code> plugins to see if any rootkits are hiding. <code>pslist</code> relies on the doubly-linked <code>EPROCESS</code> list where each node represents a process&rsquo;s meta and points to the next <code>EPROCESS</code>. The problem is that with the DKOM technique (Direct Kernel Object Manipulation), an attacker can unlink the rogue process from the <code>EPROCESS</code> list, thus hiding it from the OS eye.</p>
<p>Here is what the <code>EPROCESS</code> list looks like (roughly):</p>
<p><img src="images/dkom.png" alt="img">
And here is what happens when the process is unlinked:</p>
<p><img src="images/no-dkom.png" alt="img"></p>
<p>As you can see, now the 🌴 process is &ldquo;invisible&rdquo; to the operating system. <code>pstree</code> plugin also relies on the same data structure, so, the only difference is in the presentation: you see a tree (child-parent relationships) instead of a list which is helpful too. <code>psscan</code>, on the other hand, doesn&rsquo;t rely on the <code>EPROCESS</code> list; it scans the whole image for these <code>EPROCESS</code> objects (their signatures), whether they are linked to each other or not, and thus identifies the rogue processes. It can also identify terminated processes (and marks them as such).</p>
<blockquote>
<p>❗️One very important thing to note is that <code>pslist</code> shows the virtual address of the <code>EPROCESS</code> structure (when it was in memory), whereas the <code>psscan</code> shows the physical offset (from the raw image start). 32-bit virtual address consists of the following parts: <code>10b</code> for page index, <code>10b</code> for page table index, <code>12b</code> for byte index. Additionally, <code>pslist</code> shows 🐾 number of threads, 🐾 number of handles, while <code>psscan</code> additionally notes 🐾 page directory base offset (PDB) and 🐾 exit time. <code>pstree</code> has the same info but in a different representation.</p>
</blockquote>
<p>Both plugins also show the following data:</p>
<p>🐾 Process name
🐾 PID
🐾 PPID (parent PID)
🐾 Start time</p>
<blockquote>
<p>🛠 <code>EchoTrail</code> is an excellent online tool for insights into the Windows core processes (expected boot time, children and parents etc).</p>
</blockquote>
<p>You can use the 🛠 <code>pstree</code> plugin to create a diagram in <code>.dot</code> format, which can later be used to create a png</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">📘 vol.py -f imagename --profile prof pstree --output<span class="o">=</span>dot --output-file<span class="o">=</span>pstree.dot
</span></span><span class="line"><span class="cl">📘 dot -Tpng pstree.dot -o pstree.png
</span></span></code></pre></div><p>Check <strong>parent</strong> processes of core processes:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">📘 grep -E -i <span class="s2">&#34;(system|wininit|lsass|lsm|services|sms|taskhost|winlogon|iexplore|explorer|svchost|csrss)&#34;</span> pslist.txt &gt; pslist-all-core.txt
</span></span><span class="line"><span class="cl">📘 grep -E -i <span class="s2">&#34;(system|wininit|lsass|lsm|services|sms|taskhost|winlogon|iexplore|explorer|svchost|csrss)&#34;</span> psscan.txt &gt; psscan-all-core.txt
</span></span></code></pre></div><p>We have the result of <code>pslist</code>:</p>
<p><img src="images/pslist-results.png" alt="pslist-results"></p>
<p>We have several suspicious processes here: <code>scvhost.exe</code> (misspelled <code>svchost.exe</code>), some <code>xminer.exe</code> and a process with an intriguing name <code>3.exe</code>. But these are the processes that we could have seen, should we use a Task Manager on a live system. What about terminated or unlinked processes?</p>
<p>To answer that we run <code>psscan</code>:</p>
<p><img src="images/psscan-results.png" alt="psscan-results"></p>
<p>We saw the same <code>3.exe</code> in the list. But also we see <code>q.exe</code> which was run for about a minute and during that time another processes was spawned - <code>xmcminer.exe</code>. <code>q.exe</code> was terminated that&rsquo;s why we don&rsquo;t see it in <code>pslist</code> results. But <code>xmcminer.exe</code> was not terminated but we still don&rsquo;t see it in <code>pslist</code>. That means that the process was unlinked from a doubly-linked list of processes in memory (aka hidden).</p>
<p>Take unique process names, sort and count:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">📘 cut -d <span class="s2">&#34; &#34;</span> -f <span class="m">2</span> <span class="s1">&#39;psscan.txt&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> sort &gt; <span class="s1">&#39;psscan_proc_sorted.txt&#39;</span>
</span></span></code></pre></div><p>Also, think about what the attackers are likely to run. Some remote tools, for example? Like, WMI or PowerShell. When PowerShell remoting is used, <code>wsmprovhost.exe</code> process is running in RAM on the target (when <code>ComputreName</code> option is specified). Or if it&rsquo;s an IIS server, there will be a <code>w3wp.exe</code> running in RAM. If the attacker manages to run a web shell, this process will spawn the tools that this web shell invokes, like <code>net.exe</code> or <code>sc.exe</code>.</p>
<p>🤨 If the user launches PowerShell, its parent will be <code>explorer.exe</code>. If admin - <code>svchost.exe</code>. PowerShell as a parent of cmd.exe is not necessarily suspicious but could be. 🤨  <code>wmiprvse.exe</code> is the one running WMI. If you see <code>wmiprvse.exe</code> spawns cmd.exe which does something with the registry or service could be something worth looking into.
🤨 Such processes like <code>mshta</code>, <code>word</code> or <code>excel</code> running PowerShell is also not a good thing.
🤨 <code>ActiveScriptEventConsumer</code> WMI spawns a rare process - <code>scrcons.exe</code>.</p>
<h3 id="wincore-vs-non-core">WinCore vs Non-Core</h3>
<p>Check <strong>names</strong> of non-win processes:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">📘 grep -E -i -v <span class="s2">&#34;(system|wininit|lsass|lsm|services|sms|taskhost|winlogon|iexplore|explorer|svchost|csrss)&#34;</span>  pslist.txt &gt; pslist-all-non-wincore.txt
</span></span><span class="line"><span class="cl">📘 grep -E -i -v <span class="s2">&#34;(system|wininit|lsass|lsm|services|sms|taskhost|winlogon|iexplore|explorer|svchost|csrss)&#34;</span>  psscan.txt &gt; psscan-all-non-wincore.txt
</span></span></code></pre></div><h3 id="singletons">Singletons</h3>
<p>Check known <strong>singletons</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">📘 grep -E -i <span class="s2">&#34;(system|wininit|lsass|services|lsm)&#34;</span> pslist.txt &gt; pslist-all-singletons.txt
</span></span><span class="line"><span class="cl">📘 grep -E -i <span class="s2">&#34;(system|wininit|lsass|services|lsm)&#34;</span> psscan.txt &gt; psscan-all-singletons.txt
</span></span></code></pre></div><p><img src="images/pslist-singletons.png" alt="pslist-singletons"></p>
<p>In the example above there are two <code>lsass.exe</code> processes which is nonsense. Obviously, some investigative lead.</p>
<h3 id="boot-times">Boot Times</h3>
<p>Check <strong>boot times</strong>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">📘 grep -E -i &#34;(system|wininit|lsass|services|sms|lsm|csrss)&#34; pslist.txt &gt; pslist-all-boot.txt
</span></span><span class="line"><span class="cl">📘 grep -E -i &#34;(system|wininit|lsass|services|sms|lsm|csrss)&#34; psscan.txt &gt; psscan-all-boot.txt
</span></span></code></pre></div><p><code>System</code> is a pivot point. Other processes that should start at boot, should have roughly the same starting date and time. <code>pslist</code> is pulling the information of a doubly-linked list (like a Task Manager). <code>psscan</code> - unallocated space (processes terminated or unlinked from this double-linked list).</p>
<p>Also, get all processes that did not start at boot time:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">📘 grep -E -i -v 2019-01-20 <span class="s1">&#39;pslist.txt&#39;</span> &gt; pslist_not_boottime.txt
</span></span><span class="line"><span class="cl">📘 grep -E -i -v 2019-01-20 <span class="s1">&#39;psscan.txt&#39;</span> &gt; psscan_not_boottime.txt
</span></span></code></pre></div><h3 id="deviations">Deviations</h3>
<p>Another helpful plugin to use would be the <code>malfind</code>, which tries to identify rogue processes looking for specific attack patterns automatically. And one of the most useful (at least, in my humble opinion) is the <code>processbl</code> which stands for process baseline and means you can compare the processes and DLLs in your image with some baseline image.</p>
<p>The baseline plugin has three parts: <code>processbl</code>, <code>drivebl</code> and <code>servicebl</code>.</p>
<p>⚙️ <code>processbl</code> compares processes and their loaded DLLs (relies on the same structure as <code>pslist</code>)
⚙️ drivebl compares the drivers
⚙️ servicebl compares the services</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">📘 vol.py -f imagefile --profile<span class="o">=</span>prof -B ./baseline.img processbl -U <span class="m">2</span> &gt; error.log <span class="c1">#  -U - shows what&#39;s different and -K - what&#39;s not</span>
</span></span></code></pre></div><p>Since this plugin does NOT compare the executable paths, only the names, it&rsquo;s a good practice to use both <code>-U</code> and <code>-K</code> switches to see what&rsquo;s really out of place.</p>
<h3 id="processes">Processes</h3>
<p>Processes consist of the following elements that reside in RAM:</p>
<p>🏺 dlls and command line information 🛠️ <code>dlllist</code> 🛠️ <code>dlldump</code> 🛠️ <code>ldrmodules</code>
🏺 handles (files, directories, registry keys, mutants, semaphores, events such as threat notifications) 🛠️ <code>handles</code> 🛠️ <code>mutantscan</code> (gives more information than handles).
🏺 threads
🏺 memory sections 🛠️ <code>getsids</code>
🏺 sockets (ports and connections)
🏺 command line arguments and output</p>
<blockquote>
<p>❗️<code>EPROCESS</code> structure only allows 16 bytes for the name. So, to see the full path and name see <code>PEB</code>.</p>
</blockquote>
<p>You can dump the whole memory with 🛠️ <code>memdump</code> or just a specific process with 🛠️ <code>procdump</code>. 🛠️ <code>vaddump</code> can also be of help (a separate file for each section).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="err">📘</span> <span class="n">vol</span><span class="p">.</span><span class="n">py</span> <span class="o">-f</span> <span class="n">image</span> <span class="n">memdump</span> <span class="n">-p</span> <span class="n">PID</span> <span class="p">-</span><span class="n">-dump-dir</span><span class="p">=./</span><span class="n">some</span><span class="p">/</span>
</span></span><span class="line"><span class="cl"><span class="err">📘</span> <span class="n">strings</span> <span class="n">-a</span> <span class="n">-t</span> <span class="n">d</span> <span class="n">-e</span> <span class="n">l</span> <span class="n">file</span> <span class="p">&gt;&gt;</span> <span class="n">strings</span><span class="p">.</span><span class="n">txt</span> <span class="c"># bstrings.exe</span>
</span></span><span class="line"><span class="cl"><span class="err">📘</span> <span class="nb">sort </span><span class="n">strings</span><span class="p">.</span><span class="n">txt</span> <span class="p">&gt;</span> <span class="n">sorted_str</span><span class="p">.</span><span class="n">txt</span>
</span></span><span class="line"><span class="cl"><span class="err">📘</span> <span class="n">grep</span> 
</span></span></code></pre></div><h4 id="command-line">Command line</h4>
<p>🛠️ <code>consoles</code> (prints commands and outputs, looking for <code>CONSOLE_INFORMATION</code>) and 🛠️ <code>cmdscan</code> (information from the command history buffer).</p>
<p>On WinXP <code>csrss.exe</code> and Win7+ - <code>conhost.exe</code> is responsible for command line history, which is stored in their memory, searching the VAD for <code>DOSKEY</code> structure (🛠️ <code>cmdscan</code>). By default, cmd.exe only keeps 50 entries in the buffer.</p>
<p>🛠️ <code>cmdscan</code> has the following list of data:</p>
<p>🐾 command process containing the cmd history
🐾 PID
🐾 Command History (its offset)
🐾 Application
🐾 Flags
🐾 First command (location)
🐾 CommandCountMax (size of the buffer)
🐾 LastAdded (entry last added to buffer)
🐾 LastDisplayed
🐾 Process Handle (the app handle number)
🐾 Command list</p>
<p>🛠️ <code>consoles</code></p>
<p>🐾 Console process containing CONSOLE_INFORMATION structure
🐾 PID
🐾 Console (offset in process memory)
🐾  Offset where the console was found
🐾 CommandHistorySize (default number of commands kept in the buffer)
🐾 HistoryBufferCount
🐾 HistoryBufferMax
🐾 OriginalTitle (first title of console window)
🐾 Title (current title)
🐾 AttachedProcess (process name, PID and handle ID running within this process)
🐾 Command list
🐾 Screen (coordinates of console window)
🐾 Dump (console screen output)</p>
<h4 id="files">Files</h4>
<p>🛠️ <code>filescan</code> helps to identify files, 🛠️ <code>handles</code> with <code>-t</code> set to <code>File</code> can also be used. Then, 🛠️ <code>dumpfiles</code> can be used to get those files for further analysis. Scans for <code>File_Objects</code> from memory. It&rsquo;s recommended to narrow down the output with <code>-Q</code> (offset) or <code>-r</code> (regex). Each <code>File_Objects</code> contains three <code>Section_Object_Pointers</code>: <code>ImageSectonObject</code> (memory-mapped binaries), <code>DataSectonObject</code> (memory-mapped files), and <code>SharedCachedMap</code> (parts cached by Windows Cache manager).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="err">📘</span> <span class="n">vol</span><span class="p">.</span><span class="n">py</span> <span class="o">-f</span> <span class="n">image</span> <span class="n">dumpfiles</span> <span class="n">-n</span> <span class="n">-i</span> <span class="n">-r</span> <span class="p">\\.</span><span class="n">exe</span> <span class="p">-</span><span class="n">-dump-dir</span><span class="p">=./</span><span class="n">path</span><span class="p">/</span> <span class="c"># use the original name when printing the output, -i - ignore case, -r - regex </span>
</span></span></code></pre></div><blockquote>
<p>❗️The 🛠️ <code>dumpfiles</code> plugin will only look for <code>FILE_OBJECTS</code> within the VAD<code> </code>tree or in process handles. So it will not recover maliciously manipulated files. Also, special files like <code>$MFT</code> or <code>$LogFile</code> are not in VAD. Use 🛠️ <code>filescan</code> to find interesting things and then 🛠️ <code>dumpfiles</code> to dump them.</p>
</blockquote>
<h4 id="shimcache">Shimcache</h4>
<p>🛠️ <code>shimcachemem</code>. 🏺 <code>Shimcache</code> updates are not writing updates to disk until the system is shut down or rebooted. So, some saucy stuff can be there.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="err">📘</span> <span class="n">vol</span><span class="p">.</span><span class="n">py</span> <span class="o">-f</span> <span class="n">image</span> <span class="p">-</span><span class="n">-output</span><span class="p">=</span><span class="n">csv</span> <span class="p">-</span><span class="n">-output</span><span class="o">-file</span><span class="p">=</span><span class="n">name</span> <span class="n">-P</span> <span class="c"># -P print the VA and PA offsets.</span>
</span></span></code></pre></div><h4 id="dlls">DLLs</h4>
<p>🛠️  <code>dlllist</code> relies heavily on PEB and shows the following data:</p>
<p>🐾 Base offset (used to dump the DLL with 🛠️  <code>dlldump</code> later)
🐾 DLL size
🐾 Load count (statically or dynamically loaded)
🐾 Load time (you can spot if the DLL was loaded after runtime giving out possible injection)
🐾 DLL file path (useful to spot deviations)
🐾 Command line</p>
<blockquote>
<p>❗️There can be lots of DLLs loaded into the processes, better run with the <code>-p</code> switch.</p>
</blockquote>
<p>Use 🛠️ <code>dlldump</code> to dump the DLL of interest. If no parameters are provided, it will dump EVERYTHING. But if you want to narrow down the analysis, use both <code>-p PID</code> and <code>-b baseoffset</code>. You can also use<code> -r regex</code> to find the DLL by name. The base offset can be provided by the 🛠️ <code>dlllist</code>.</p>
<h4 id="handles">Handles</h4>
<p>There are many handles, and it would be nearly impossible to analyse them ALL in time. To ease up your investigation, keep in mind that there are several types of handles that can be passed to the <code>handles</code> volatility plugin as a <code>-t</code> switch value:</p>
<p>🫳🏼 process
🫳🏼 file
🫳🏼 thread
🫳🏼 event
🫳🏼 key
🫳🏼 port
🫳🏼 wmiguid
🫳🏼 timer
🫳🏼 iocompletion
🫳🏼 windowstation
🫳🏼 directory
🫳🏼 token
🫳🏼 semaphore
🫳🏼 mutant</p>
<p><code>filescan</code> (scan for <code>FILE_OBJECTS</code>) and <code>mutantscan</code> (scan for <code>_KMUTANT</code>) plugins can scan the entire image for different handle types, which is useful when finding unallocated data.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">📘 vol.py -f image --profile<span class="o">=</span>prof -t File
</span></span></code></pre></div><h4 id="drivers">Drivers</h4>
<p>🛠️ <code>modules</code>, 🛠️ <code>modscan</code> and 🛠️ <code>driverbl</code> give us a list (hopefully) of suspicious drivers. To get its base offset, use 🛠️ <code>modscan</code> or 🛠️ <code>modules</code>. Once we have the base offset of the nefarious driver, use 🛠️ <code>moddump</code> to retrieve it for further inspection.</p>
<p>🐾 driver name
🐾 base offset
🐾 output filename</p>
<blockquote>
<p>❗️ The offset provided by the 🛠️ <code>ssdt</code> plugin is the function offset, not that of the driver!</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="err">📘</span> <span class="n">vol</span><span class="p">.</span><span class="n">py</span> <span class="o">-f</span> <span class="n">image</span> <span class="n">ssdt</span> <span class="p">|</span> <span class="n">egrep</span> <span class="n">-v</span> <span class="p">`(</span><span class="n">ntoskrnl</span><span class="p">|</span><span class="n">win32k</span><span class="p">)`</span>
</span></span><span class="line"><span class="cl"><span class="err">📘</span> <span class="n">vol</span><span class="p">.</span><span class="n">py</span> <span class="o">-f</span> <span class="n">image</span> <span class="n">modules</span> <span class="p">|</span> <span class="n">grep</span> <span class="n">something</span>
</span></span><span class="line"><span class="cl"><span class="err">📘</span> <span class="n">vol</span><span class="p">.</span><span class="n">py</span> <span class="o">-f</span> <span class="n">image</span> <span class="n">moddump</span> <span class="n">-b</span> <span class="n">offset</span> <span class="p">-</span><span class="n">-dump-dir</span><span class="p">=./</span><span class="n">filename</span>
</span></span></code></pre></div><h4 id="permissions">Permissions</h4>
<p>Permissions on Windows are specified with the tokens and SIDs. 🛠️ <code>getsid</code> volatility plugin can display the security identifiers for the given process.</p>
<h4 id="network">Network</h4>
<p>There are three main data to look out for when analysing network artefacts:</p>
<p>🏺 ports. Look out for non-browser processes listening on <code>443</code>, <code>80</code>, <code>8080</code> or browsers listening on anything other than that. RDP (<code>3389</code>) is something to look closer at if this type of connection is uncommon for this machine. PowerShell remoting - <code>5985</code>.
🏺 connections. Check the IP for nefariousness. DNS requests to unusual domains or TXT records. Workstation-to-workstation connections are not usually common and often show lateral movement. RDP to the local host is especially suspicious (VPN?).<br>
🏺 processes (those responsible for that network connection)</p>
<blockquote>
<p>❗️ Network sockets have creation times, and terminated processes can be recovered.</p>
</blockquote>
<p>Volatility plugins follow the single-linked list (for older machines): 🛠️ <code>connections</code> (active, open), 🛠️ <code>sockets</code> (active). Volatility plugins scan the image for known structures (for older machines): 🛠️ <code>connscan</code>, 🛠️ <code>sockscan</code> (<code>_ADDRESS_OBJECT</code>).</p>
<p>🛠️ <code>netscan</code> combines the functionality of the above plugins and can be used against Vista+. Shows the following data:</p>
<p>🐾 memory offset
🐾 protocol
🐾 local IP
🐾 state (for TCP)
🐾 PID
🐾 process owner name
🐾 creation time</p>
<h4 id="injections">Injections</h4>
<p>Most information is taken from <a href="!%5Bulr-4%5D(images/ulr-4.png)">here</a>, but more visualisation is added. The screenshots from IDA Pro are also copied from that blog post. I will start with a brief overview of the volatility plugins used to analyse injection, and you can see the list below for more detailed analysis instructions. For more, see the <code>Attacks DB -&gt; Binary -&gt; Injections article</code>.</p>
<p>🛠️ <code>Get-InjectedThread</code> to do live analysis for injections and 🛠️ <code>hollows_hunter</code> to spot more advanced techniques, also live.</p>
<ol>
<li><strong>Classic</strong>. A malicious DLL&rsquo;s <strong>path</strong> is copied in the memory space of a legitimate running process to be loaded in runtime.</li>
<li><strong>PE injection</strong>. A malicious <strong>DLL</strong> itself is copied into the memory space of a legitimate running process.</li>
<li><strong>Process Hollowing</strong>. An already loaded good process is fully overwritten with something that could be better. Imagine that the legit code was scooped out.</li>
<li><strong>SIR</strong> (<strong>S</strong>uspend, <strong>I</strong>nject, <strong>R</strong>esume). EIP register&rsquo;s value of a running thread is substituted. This is the chain of function calls needed for this attack.</li>
<li><strong>Hook</strong>. Uses <code>SetWindowsHookEx()</code> API function.</li>
<li><strong>Registry poisoning</strong>. Using the registry to inject. These are the keys that can be used for injection.
<ol>
<li>Upon <code>User32.dll</code> load <code>mal.dll</code> will be loaded (whenever <code>CreateProcess()</code>, <code>CreateProcessAsUser()</code>, <code>CreateProcessWithLogonW()</code>, <code>CreateProcessWithTokenW()</code>, <code>WinExec()</code> are called, <code>mal.dll</code> will be called):
<ol>
<li>🔑 <code>HKLM/Software/Microsoft/WindowsNT/CurrentVersion/Windows/Appinit_Dlls</code></li>
<li>🔑 <code>HKLM/Software/Wow6432Node/Microsoft/WindowsNT/CurrentVersion/Windows/Appinit_Dlls</code></li>
<li>🔑 <code>HKLM/System/CurrentControlSet/Control/Session Manager/AppCertDlls</code></li>
</ol>
</li>
<li>IFEO - usually used to attach a debugger. The value of the  <code>Debugger Value</code> is changed.
<ol>
<li>🔑 <code>HKLM/Software/Wow6432Node/Microsoft/WindowsNT/CurrentVersion/image file execution options</code></li>
</ol>
</li>
<li>❗️ <code>mal.dll</code> needs to be present on disk.</li>
<li>❗️ There are &ldquo;smithereens&rdquo; left in the registry that can be a good lead in an investigation.</li>
</ol>
</li>
<li><strong>APC</strong>.</li>
<li><strong>EWMI</strong> with <code>SetWindowLong()</code></li>
<li><strong>SHIMS</strong>. My favourite and the most useful for malware: <code>DisableNX</code>, <code>DisableSEH</code>, <code>InjectDLL</code>.</li>
<li><strong>Userland rootkit</strong>. Rootkits are usually associated with the kernel space. However, there are also userland rootkits out there. There are two main techniques known: IAT and inline. When the IAT hooking technique is used, malware changes the import address table. This way, when a good application calls some function from this tampered DLL, the replaced function is executed instead. With inline hooking, the malware modifies the function&rsquo;s body itself.</li>
<li><strong>Reflective</strong>. This means not using LoadLibrary or Windows Loader to load the code. This allows the malware to avoid being tracked by the system. The code can be injected directly from memory. The only legit way to load code is from disk and only sections with code are supposed to be marked as <code>Page_Execute_ReadWrite</code>. So, the memory analysis process to identify this is as follows:
<ol>
<li>Walk through the VAD and inspect each section.</li>
<li>Detect unusual permissions like <code>Page_Execute_ReadWrite</code>, and if it is mapped to disk.</li>
</ol>
</li>
</ol>
<p>🛠️ <code>ldrmodule</code>. Detects unlinked and unmapped processes. It checks and follows these three doubly-linked lists in the PEB and the VAD, then scans the image for the structures, comparing the results from VAD and PEB. Such plugins as <code>dlllist</code> will show only what&rsquo;s not unlinked, and <code>ldrmodule</code> will highlight deviations.</p>
<p>🐾 PID
🐾 p_name
🐾 base offset (location in the image)
🐾 PEB <code>InLoadOrderModule</code> list (<code>InLoad</code>) - doubly-linked list
🐾 PEB <code>InInitializationOrderModule</code> list (<code>InInit</code>) - doubly-linked list
🐾 PEB <code>InMemoryOrderModule</code> list (<code>InMem</code>) - doubly-linked list
🐾 VAD Tree <code>MappedPath</code> ❗️In case you don&rsquo;t see anything here, the program was not loaded from the disk, which is almost always suspicious even if all the three PEB lists show <code>True</code> for this process.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="err">📘</span> <span class="n">vol</span><span class="p">.</span><span class="n">py</span> <span class="o">-f</span> <span class="n">image</span> <span class="n">ldrmodules</span> <span class="n">-p</span> <span class="n">PID</span>
</span></span></code></pre></div><p>Classic and PE injection techniques use <code>CreateRemoteThread</code>, and classic uses <code>LoadLibraryA</code> WinAPI call. Since WinAPI was used, it will look very similar to a legit process. The best bet would be to check the <code>MappedPath</code> column for unusual locations.</p>
<blockquote>
<p>❗️<code>dlllist</code> will also show this info since the malware is not hiding itself with this technique, just injecting.</p>
</blockquote>
<blockquote>
<p>🔎 If <code>MappedPath</code> is empty and all three PEB lists are empty, the file was not loaded from the disk, which is an excellent indication of injection.
🔎 When <code>MappedPath</code> is empty for the memory section that is supposed to belong to the executable itself - process hollowing.</p>
</blockquote>
<blockquote>
<p>🔎 Using this module, ✍️ You can grep for <code>False</code> to narrow the search.
🔎 False positives: unloaded DLLs not yet removed from memory until <code>FreeLibrary</code> is called; strange extensions like <code>.fon</code>, <code>.mui</code> etc. will not be present in the PEB lists but in the VAD. Since they are all PE files, they will appear suspicious when they are not; PEB is only about <code>exe</code> and <code>dll</code>.</p>
</blockquote>
<p>Three PEB doubly-linked lists are useful for detecting injections. &ldquo;Good&rdquo; programs will be present in all three, showing <code>True</code> in the corresponding columns in the output. Some legit programs (a limited number) will be absent from some lists. Also, process executables will always be missing from the <code>InInit</code> list. Sometimes unloaded DLLs that weren&rsquo;t yet removed from the process memory might also be showing there.</p>
<p>🛠️ <code>malfind</code>. Find hidden and injected code and dumps interesting parts of memory. It can help identify more advanced injection techniques like reflective injection.</p>
<p>🐾 p_name
🐾 PID
🐾 Starting offset
🐾 Ending offset
🐾 Tag (type of memory section)
🐾 Hits (from YARA)
🐾 Protect (memory permissions)</p>
<p>It also dumps some starting portions of the memory section (64 bytes) so the analyst can easily spot the MZ header or the shellcode. Sometimes, the malware gets very clever, padding the section with something malicious with <code>ADD [EAX], AL</code> that looks like garbage for the analyst, or overwrites the MZ header, clears the entire MZ header or jumps to the code placed later. The best approach here is to dump this section and review it fully.</p>
<p>🛠️ <code>hollowfind</code>. Identifies main hollowing techniques. Compares PEB with VAD, looks for unusual section permissions (similar to <code>malfind</code>).</p>
<p>🛠️ <code>threadmap</code>. Analyse threads and find process hollowing countermeasures. Each threat is mapped to its corresponding VAD entry; the plugin test this entry and the code contained to identify anomalies. Harder to hide and manipulate, there always needs to be a threat pointing to the injected code.</p>
<h4 id="hooks">Hooks</h4>
<h5 id="ssdt">SSDT</h5>
<p>The system Service Descriptor Table hooks the system calls. This technique involves patching one or more pointers that point to the lookup table for system functions. Legit calls are always either to <code>ntoskrnl.exe</code> or <code>win32k.sys</code>.</p>
<p>🛠️ <code>ssdt</code>. It helps identify SSDT hooking by looking for references other than <code>ntoskrnl.exe</code> or <code>win32k.sys</code>. In order to remove legit hooks, use the following grep:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="err">📘</span> <span class="n">ssdt_output</span> <span class="p">|</span> <span class="n">egrep</span> <span class="n">-v</span> <span class="p">`(</span><span class="n">ntoskrnl</span><span class="p">\.</span><span class="n">exe</span> <span class="p">|</span> <span class="n">win32k</span><span class="p">\.</span><span class="n">sys</span><span class="p">)`</span>
</span></span></code></pre></div><p>On Vista+ this technique is harder to pull off since the Kernel Patch Protection (PatchGuard) will crash the processes attempting to do this (unless there is a vulnerability).</p>
<p>🐾 Tables entry
🐾 function offset
🐾 function
🐾 function owner</p>
<p>Note the hooked functions, as they can give a clue to the malware&rsquo;s function.</p>
<p>🛠️ <code>ssdt_ex</code> can be used to identify and dump SSDT entries.</p>
<h5 id="idt">IDT</h5>
<p><strong>IDT</strong> (Interrupt Descriptor Table). Not very common in modern systems. 🛠️ <code>idt</code>. Helps identify IDT technique.</p>
<h5 id="iat">IAT</h5>
<p><strong>IAT</strong> (Import Address Table) and Inline API. User-mode DLL function hooking can be spotted with 🛠️ <code>volatility</code> <code>apihooks</code> plugin. As the output can be overwhelming, use <code>-Q</code> to only scan critical processes or/and <code>-R</code> to skip kernel mode checks.</p>
<blockquote>
<p>✍️ False positives to eliminate:<code> setupapi.dll</code>, <code>mswsock.dll</code>, <code>sfc_os.dll</code>, <code>adsldpc.dll</code>, <code>advapi32.dll</code>, <code>secur32.dll</code>, <code>ws2_32.dll</code>, <code>iphlpapi.dll</code>, <code>ntdll.dll</code>, <code>kernel32.dll</code>, <code>user32.dll</code>, <code>gdi32.dll</code>.</p>
</blockquote>
<p><code>Unknown</code> in the <code>Hooking module</code> shows that it is jumping into a memory section that&rsquo;s not mapped to disk.</p>
<h5 id="irp">IRP</h5>
<p><strong>IRP</strong> (I/O Request Packets) for driver hooking, low-level stuff. 🛠️ <code>driverirp</code>. It helps in identifying the <strong>IRP</strong> technique.</p>
<p>Use 🛠️ <code>psxview</code> plugin for the cross-view analysis. Eliminate false positives by using <code>-R</code> (known good). It includes the data from the following plugins: <code>pslist</code>, <code>psscan</code>, <code>pspcid</code> (keeps track of processes and PIDs), <code>thrdproc</code> (reviews all threads in memory and collects processes using thread parent id), <code>csrss</code> (<code>csrss.exe</code> keeps a handle to each process started <strong>after</strong> it), <code>session</code> (process for each logon session), <code>deskthrd</code> (identify processes via threads attached to each Windows desktop).</p>
<blockquote>
<p>✍️ If you see <code>False</code> in all the columns except for 🛠️ <code>psscan</code> -&gt; the process was terminated.</p>
</blockquote>
<p>🛠️ <code>modscan</code> (scanning the memory image) and 🛠️ <code>modules</code> (uses the list). This plugin looks for loaded kernel modules and drivers. Run both to see the difference, then you might use 🛠️ <code>devicetree</code> to see the same info better visualised. Also, use the plugins for hooking identifications and then, you can either use a baseline image with 🛠️ <code>driverbl</code> plugin or dump the memory area with the 🛠️ <code>moddump</code>.</p>
<h4 id="dkom">DKOM</h4>
<p>Direct Kernel Object Manipulation. Unlinks the process from the <code>EPROCESS</code> doubly-linked list. Process unlinked in this way won&rsquo;t be visible to <code>pslist</code> plugin or <code>tasklist.exe</code>.</p>
<h3 id="common-malware">Common Malware</h3>
<h4 id="cobalt-strike">Cobalt Strike</h4>
<p>CS usually spawns a child process for each activity to make itself more persistent. These are called sacrificial processes. A good approach would be to look for exited child processes under <code>PowerShell</code> or <code>WmiPrvSE</code>.</p>
<h3 id="iocs">IOCs</h3>
<p>🛠️ <code>openioc_scan</code>, 🛠️ <code>yarascan</code> (vol plugin) and 🛠️ <code>page_brute.py</code>.</p>
<h2 id="references">References</h2>
<details>
    <summary>Expand&hellip;</summary>
    Something here
</details>
  </div>
</article>
</div>
</div>

        </div>
      </div>
    </div>
    
  </div>

  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            <li class="zerostatic"><a href="https://www.zerostatic.io">www.zerostatic.io</a></li>
            </ul>
        </div>
      </div>
    </div>
  </div>
</div>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.302a6fc365d5139fb98cf60bdb8f715d96257ea189161d36c190ccfa8182e569.js"></script>
  

  
  
  
    
  


</body>

</html>
