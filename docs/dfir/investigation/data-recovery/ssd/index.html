<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flash Memory Overview - Analyst</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://bakerst221b.com/favicon.png">
  <link href="/css/style-classic.css"></link>
  
  
  <link rel="stylesheet" href="/css/style.min.564b5f4faf3af87992cb8ab298314448914c22dbdb3f2f9c584546b21b8d407c.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home 🏡">
      <a href="/">
        <span>Home 🏡</span>
      </a>
    </li>
    
    <li class="menu-item-blog ✍️">
      <a href="/docs/blog">
        <span>Blog ✍️</span>
      </a>
    </li>
    
    <li class="menu-item-dfir 🔍">
      <a href="/docs/dfir">
        <span>DFIR 🔍</span>
      </a>
    </li>
    
    <li class="menu-item-crypto 🗝️">
      <a href="/docs/cryptography">
        <span>Crypto 🗝️</span>
      </a>
    </li>
    
    <li class="menu-item-reverse 🔧">
      <a href="/docs/reverse">
        <span>Reverse 🔧</span>
      </a>
    </li>
    
    <li class="menu-item-toolkit 🧰">
      <a href="/docs/toolkit">
        <span>Toolkit 🧰</span>
      </a>
    </li>
    
    <li class="menu-item-threat hunting 🪤">
      <a href="/docs/thunting">
        <span>Threat Hunting 🪤</span>
      </a>
    </li>
    
    <li class="menu-item-about me 🧝🏽‍♀️">
      <a href="/docs/about">
        <span>About me 🧝🏽‍♀️</span>
      </a>
    </li>
    
    <li class="menu-item-tech reference 📚">
      <a href="/docs/reference">
        <span>Tech Reference 📚</span>
      </a>
    </li>
    
    <li class="menu-item-notes 📝">
      <a href="/docs/notes">
        <span>Notes 📝</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo.png" /></a>
    </div>
    <div class="logo-mobile">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo-mobile.svg" /></a>
    </div>
    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home 🏡">
      <a href="/">
        <span>Home 🏡</span>
      </a>
    </li>
    
    <li class="menu-item-blog ✍️">
      <a href="/docs/blog">
        <span>Blog ✍️</span>
      </a>
    </li>
    
    <li class="menu-item-dfir 🔍">
      <a href="/docs/dfir">
        <span>DFIR 🔍</span>
      </a>
    </li>
    
    <li class="menu-item-crypto 🗝️">
      <a href="/docs/cryptography">
        <span>Crypto 🗝️</span>
      </a>
    </li>
    
    <li class="menu-item-reverse 🔧">
      <a href="/docs/reverse">
        <span>Reverse 🔧</span>
      </a>
    </li>
    
    <li class="menu-item-toolkit 🧰">
      <a href="/docs/toolkit">
        <span>Toolkit 🧰</span>
      </a>
    </li>
    
    <li class="menu-item-threat hunting 🪤">
      <a href="/docs/thunting">
        <span>Threat Hunting 🪤</span>
      </a>
    </li>
    
    <li class="menu-item-about me 🧝🏽‍♀️">
      <a href="/docs/about">
        <span>About me 🧝🏽‍♀️</span>
      </a>
    </li>
    
    <li class="menu-item-tech reference 📚">
      <a href="/docs/reference">
        <span>Tech Reference 📚</span>
      </a>
    </li>
    
    <li class="menu-item-notes 📝">
      <a href="/docs/notes">
        <span>Notes 📝</span>
      </a>
    </li>
    
  </ul>
</div>
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
  </div>
</div>


    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <p>
   <a href="/docs/dfir/investigation/data-recovery/"> 👈🏼 Back to </br> 🩻 Data Recovery </a>
  </p>
  <aside>
   <nav id="TableOfContents">
  <ul>
    <li><a href="#raw-nand-vs-emmc">Raw NAND vs eMMC</a></li>
    <li><a href="#structure">Structure</a>
      <ul>
        <li><a href="#page">Page</a></li>
        <li><a href="#block">Block</a></li>
        <li><a href="#plane">Plane</a></li>
        <li><a href="#lun">LUN</a></li>
      </ul>
    </li>
    <li><a href="#main-characteristics">Main Characteristics</a>
      <ul>
        <li><a href="#wear-leveling">Wear Leveling</a></li>
        <li><a href="#trim">Trim</a></li>
        <li><a href="#garbage-collection">Garbage Collection</a></li>
      </ul>
    </li>
    <li><a href="#chip-off">Chip-off</a>
      <ul>
        <li><a href="#data-recovery">Data Recovery</a></li>
        <li><a href="#imaging-process">Imaging Process</a></li>
        <li><a href="#reconstruction-steps">Reconstruction steps</a></li>
      </ul>
    </li>
    <li><a href="#cmd42-lock">CMD42 Lock</a></li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
 </aside>
</div>



          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">Flash Memory Overview</h1>
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    <div class="meta">
      
      
      <div class="article-category">
          
            
            
            
            
            
              <i class="fab fa-linux"></i>&nbsp;<i class="fab fa-apple"></i>&nbsp;<i class="fab fa-windows"></i>&nbsp;<i class="fas fa-mobile"></i>
            
            
          
          
      </div> <br />
      

      
      

      
    </div>
  </header>


  <div class="content" itemprop="articleBody">
    <p><em>In this article I&rsquo;m going to give a general overview of how SSD works and how it&rsquo;s different from an HDD.</em></p>
<p>SSDs consist of NAND memory chips, a power terminal and a data terminal. Due to its nature, data cannot be overwritten, therefore, it needs to be white clean first.</p>
<blockquote>
<p>🔎 Does it mean that there is no data in the unallocated or slack space?</p>
</blockquote>
<p>Data is written in pages and deleted in blocks (multiple pages).</p>
<h2 id="raw-nand-vs-emmc">Raw NAND vs eMMC</h2>
<p>eMMC = controller + NAND. Raw NAND chips use NAND protocol. We need some device to emulate the controller in order to retreive the data from the NAND chip. Controller has a buffer, which stores some amount of pages. Reads/writes pages to NAND or erases blocks from NAND.</p>
<p><img src="images/nand-raw.png" alt="nand-raw"></p>
<p>With eMMC you are forced to work through the built in controller, using eMMC protocol. However, under the hood the NAND inside still uses NAND protocol to talk to the controller. These chips are popular for many devices (except for Apple ones). QNX environment - real-time operating system.</p>
<p><img src="images/emmc.png" alt="emmc"></p>
<p><img src="images/xry-emmc.png" alt="xry-emmc"></p>
<p>What are these gold pads? They are techno pads used by the manufacturer to do testing, debugging. Is this a way to talk to this chip directly? The lock sits in the controller chip.</p>
<p><img src="images/techno-pads.png" alt="techno-pads"></p>
<h2 id="structure">Structure</h2>
<p>There lots of flavours of flash chips but as far as I understand they are primarily of the same structure [<a href="https://www.youtube.com/watch?v=GMQF9P_oGi0">1</a>].</p>
<h3 id="page">Page</h3>
<p>The smallest read 👀 and write ✍️ unit is a <strong>page</strong> 📄. Each page consists of <code>DATA</code>, <code>SA</code> and <code>ECC</code> sections.  Service Area consists of the Header, LBN and data. A page can get up to 4096 bytes in size (0.5-16Kb) + 224 bytes (spare area, used to mark bad blocks and to hold the ECC data [<a href="https://developer.ridgerun.com/wiki/index.php/Introduction_to_Nand_Memories">3</a>]). There are three different ways to arrange data on a page i.e. page layout (see the picture below [<a href="https://www.youtube.com/watch?v=GMQF9P_oGi0">1</a>]):</p>
<ul>
<li>all data then all spare area.</li>
<li>chunks of data and spare area where spare area might have varying size.</li>
<li>chunks of data and spare area where spare area has a fixed size.</li>
</ul>
<p><img src="images/page-structure.png" alt="t"></p>
<p><strong>Data area</strong> 🗄️ is of constant size within one page and can be 512, 1024 or 2048 bytes.</p>
<p><strong>Spare area</strong> 🤪. Depending on the page layout (shown above), it can have the following structure:</p>
<ul>
<li>header (1 byte) + 1 byte of free space + LBN (logical block number, 2 bytes) + 2 bytes of free space + ECC (10 bytes).</li>
<li>the larger areas have LBN + 2bytes + ECC, the smaller ones - 2 bytes + ECC.</li>
<li>chunks between data areas (122 bytes in size in the picture above) are ECC. At the end of a page there are 122bytes for ECC again + 1 byte of free space + header (1 byte) + 2 bytes of free space + LBN (logical block number, 2 bytes) + 42 bytes of free space.</li>
</ul>
<p><strong>ECC</strong> (error correction code 🤔).</p>
<h3 id="block">Block</h3>
<p>128 pages make up a <strong>block</strong> 🧱.  Now, a block is the smallest erase eraser ✏️ unit. Its size can vary between 128Kb and 4Mb, depending on the page size I guess. There are two types of blocks. <strong>Physical blocks</strong> contain user data, system data, firmware, cache, obsolete user data. <strong>Logical blocks</strong> only contain actual user data. After we&rsquo;ve acquired the physical dump, we need to perform certain operations with it to get the user data. The process is called <strong>block management</strong>. Physical blocks contain user data, system data, firmware, cache, obsolete user data. Logical block only contain actual user data.</p>
<h3 id="plane">Plane</h3>
<p>Physically adjacent blocks (1024 of them, to be precise) form a <strong>plane</strong> ✈️. Following the calculation it can get as big as 4320Mb.</p>
<h3 id="lun">LUN</h3>
<p><strong>Logical unit (LUN)</strong> 📁 is comprised of two planes ✈️✈️ and therefore is up to 4320Mb in size (at the moment of the writing and to my knowledge at least).</p>
<p><img src="images/lnu.png" alt="lnu"></p>
<h2 id="main-characteristics">Main Characteristics</h2>
<h3 id="wear-leveling">Wear Leveling</h3>
<p>The data is spread evenly accross  the chips. That gives birth to certain problems like the one described on Magnet Summit 2021 (see <a href="/docs/dfir/antiforensics/cmd42-lock">here</a>). This is needed because each chip has a finite amount of writes to it.</p>
<h3 id="trim">Trim</h3>
<p>SSD&rsquo;s controller identifies areas of the chips no longer in use and wipes them.</p>
<h3 id="garbage-collection">Garbage Collection</h3>
<p>Re-organizes the data and then wipes the chips. So, the hash of the drive is going to be different from time to time. Write blocker is of no use here, since these changes are happening internally.</p>
<h2 id="chip-off">Chip-off</h2>
<h3 id="data-recovery">Data Recovery</h3>
<p>Even though deleted data on a flash chip is known to be unrecoverable, it&rsquo;s not completely true. Data is usually deleted in blocks (several pages, up to 4Mb). So, before the garbage collector and trim operation perform their duty, the data is still there. But, if you are imaging the flash chip via its controller, these areas won&rsquo;t be returned since the controller already knows them to be discarded. However, if connecting directly to the NAND chip (which is loads harder), these areas that were not cleaned by the garbage collector but already unallocated, will be images as well. However this process is time consuming and sophisticated, so it surely depends on the case whether it&rsquo;s worth doing so.</p>
<p>But the data is written to NAND randomly, so, in order to reconstruct the data we need to do some sort of emulation. But we don&rsquo;t have such a tool. Using this Visual NAND reconstructor we can reconstruct the controller manually. Sometimes data is writen sequencially, so, 8Kb-4Mb (page or block) can be recovered easier: SMS, chats, GPS data, emails, contacts, logs, text data, thumbnails, pictures, zip, audio, video (from the most to the least recoverable).</p>
<h3 id="imaging-process">Imaging Process</h3>
<p>To acquire a physical image of a NAND chip in case no encryption is in place, you need to perform the following operations:</p>
<ul>
<li>Open up the device and get to the chip itself.</li>
<li>Unsoldering the chip from the board.</li>
<li>Cleaning the chip.</li>
<li>Connecting the chip to the NAND reader. If not reader available, use techno pads and connect to the breakput board, then, using Visual NAND reconstructor (ruSolut) - read the chip.</li>
<li>Acquire the image using some forensic tool like FTK or Magnet or etc.</li>
</ul>
<h3 id="reconstruction-steps">Reconstruction steps</h3>
<ul>
<li><input disabled="" type="checkbox"> Get the physical image (☝️)</li>
<li><input disabled="" type="checkbox"> Determine the page layout. When you load this image into a Visual NAND reconstructor, you&rsquo;ll get a bitmap representation of the data from the NAND chip. In order to read the contents you&rsquo;ll have to determine the page layout. An example of before and after [<a href="https://www.youtube.com/watch?v=GMQF9P_oGi0">1</a>]:</li>
</ul>
<p><img src="images/before-layout.png" alt="before-layout"></p>
<p><img src="images/after-layout.png" alt="after-layout"></p>
<ul>
<li><input disabled="" type="checkbox"> Determine the size and checksums for ECC ❓</li>
<li><input disabled="" type="checkbox"> Determine the scrambling method (XOR or INV)</li>
<li><input disabled="" type="checkbox"> Perform page allocation analysis. Which pages go into which blocks? What&rsquo;s the sequencial order of these blocks?</li>
<li><input disabled="" type="checkbox"> Block management constitutes the removal of all the blocks filtered by their headers except for the actual user data and then arranging it in the right order (using LBN from the service areas).</li>
</ul>
<h2 id="cmd42-lock">CMD42 Lock</h2>
<p>You probably are already familiar with the ATA locks on HDDs. Usually 2.5&rsquo;&rsquo; HDD, verify there is a lock with MHDD, PC 3000. This is usually set by the user in BIOS. No sectors can be read in this case. As far as I understand, it&rsquo;s called a 88 block. It&rsquo;s a little different for the eMMC chips.</p>
<p>In the case of an eMMC, if this lock is set (it&rsquo;s called a CMD42 lock 🔐),  the card <em>can still be queried</em> for reset, status, init and select, and access boot partition, RPMB and general partition area. RPMB (<strong>R</strong>eplay <strong>P</strong>rotect <strong>M</strong>emory <strong>B</strong>lock) - first introduced in eMMC4.4. Allows storing data in a special address space that&rsquo;s protected from replay attacks. Requires signing all read/write opeations.</p>
<h2 id="references">References</h2>
<p>[<a href="https://www.youtube.com/watch?v=GMQF9P_oGi0">1</a>] Presentation from Magnet Summit Webinar</p>
<p>[<a href="https://www.partitionwizard.com/partitionmagic/nand-ssd.html">2</a>] Low-level explanation</p>
<p>[<a href="https://developer.ridgerun.com/wiki/index.php/Introduction_to_Nand_Memories">3</a>] Introduction to Nand Memories</p>

  </div>
</article>
</div>
</div>

        </div>
      </div>
    </div>
    
  </div>

  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            <li class="zerostatic"><a href="https://www.zerostatic.io">www.zerostatic.io</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.302a6fc365d5139fb98cf60bdb8f715d96257ea189161d36c190ccfa8182e569.js"></script>
  

  
  
  
    
  


</body>

</html>
