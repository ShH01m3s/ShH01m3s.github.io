<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FAT - Analyst</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://bakerst221b.com/favicon.png">
  <link href="/css/style-classic.css"></link>
  
  
  <link rel="stylesheet" href="/css/style.min.564b5f4faf3af87992cb8ab298314448914c22dbdb3f2f9c584546b21b8d407c.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home üè°">
      <a href="/">
        <span>Home üè°</span>
      </a>
    </li>
    
    <li class="menu-item-blog ‚úçÔ∏è">
      <a href="/docs/blog">
        <span>Blog ‚úçÔ∏è</span>
      </a>
    </li>
    
    <li class="menu-item-dfir üîç">
      <a href="/docs/dfir">
        <span>DFIR üîç</span>
      </a>
    </li>
    
    <li class="menu-item-crypto üóùÔ∏è">
      <a href="/docs/cryptography">
        <span>Crypto üóùÔ∏è</span>
      </a>
    </li>
    
    <li class="menu-item-reverse üîß">
      <a href="/docs/reverse">
        <span>Reverse üîß</span>
      </a>
    </li>
    
    <li class="menu-item-toolkit üß∞">
      <a href="/docs/toolkit">
        <span>Toolkit üß∞</span>
      </a>
    </li>
    
    <li class="menu-item-threat hunting ü™§">
      <a href="/docs/thunting">
        <span>Threat Hunting ü™§</span>
      </a>
    </li>
    
    <li class="menu-item-about me üßùüèΩ‚Äç‚ôÄÔ∏è">
      <a href="/docs/about">
        <span>About me üßùüèΩ‚Äç‚ôÄÔ∏è</span>
      </a>
    </li>
    
    <li class="menu-item-tech reference üìö">
      <a href="/docs/reference">
        <span>Tech Reference üìö</span>
      </a>
    </li>
    
    <li class="menu-item-notes üìù">
      <a href="/docs/notes">
        <span>Notes üìù</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo.png" /></a>
    </div>
    <div class="logo-mobile">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo-mobile.svg" /></a>
    </div>
    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home üè°">
      <a href="/">
        <span>Home üè°</span>
      </a>
    </li>
    
    <li class="menu-item-blog ‚úçÔ∏è">
      <a href="/docs/blog">
        <span>Blog ‚úçÔ∏è</span>
      </a>
    </li>
    
    <li class="menu-item-dfir üîç">
      <a href="/docs/dfir">
        <span>DFIR üîç</span>
      </a>
    </li>
    
    <li class="menu-item-crypto üóùÔ∏è">
      <a href="/docs/cryptography">
        <span>Crypto üóùÔ∏è</span>
      </a>
    </li>
    
    <li class="menu-item-reverse üîß">
      <a href="/docs/reverse">
        <span>Reverse üîß</span>
      </a>
    </li>
    
    <li class="menu-item-toolkit üß∞">
      <a href="/docs/toolkit">
        <span>Toolkit üß∞</span>
      </a>
    </li>
    
    <li class="menu-item-threat hunting ü™§">
      <a href="/docs/thunting">
        <span>Threat Hunting ü™§</span>
      </a>
    </li>
    
    <li class="menu-item-about me üßùüèΩ‚Äç‚ôÄÔ∏è">
      <a href="/docs/about">
        <span>About me üßùüèΩ‚Äç‚ôÄÔ∏è</span>
      </a>
    </li>
    
    <li class="menu-item-tech reference üìö">
      <a href="/docs/reference">
        <span>Tech Reference üìö</span>
      </a>
    </li>
    
    <li class="menu-item-notes üìù">
      <a href="/docs/notes">
        <span>Notes üìù</span>
      </a>
    </li>
    
  </ul>
</div>
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
  </div>
</div>


    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <p>
   <a href="/docs/dfir/investigation/data-recovery/file-systems/fat/"> üëàüèº Back to </br> FAT </a>
  </p>
  <aside>
   <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#versions">Versions</a>
          <ul>
            <li><a href="#fat12">FAT12</a></li>
            <li><a href="#fat16">FAT16</a></li>
            <li><a href="#fat32">FAT32</a></li>
            <li><a href="#exfat">ExFAT</a></li>
          </ul>
        </li>
        <li><a href="#fat-structure">FAT Structure</a>
          <ul>
            <li><a href="#volume-boot-record">Volume Boot Record</a></li>
            <li><a href="#root-directory">Root Directory</a></li>
            <li><a href="#directories-not-root">Directories (not Root)</a></li>
            <li><a href="#file-allocation-table-fat">File Allocation Table (FAT)</a></li>
          </ul>
        </li>
        <li><a href="#timestamps">Timestamps</a></li>
        <li><a href="#fat-file-creation-and-deletion">FAT File Creation And Deletion</a>
          <ul>
            <li><a href="#creating">Creating</a></li>
            <li><a href="#deleting">Deleting</a></li>
          </ul>
        </li>
        <li><a href="#exfat-structure">exFAT Structure</a>
          <ul>
            <li><a href="#boot-record">Boot Record</a></li>
            <li><a href="#fat1">FAT1</a></li>
            <li><a href="#root-directory-1">Root Directory</a></li>
            <li><a href="#additional-files">Additional Files</a></li>
          </ul>
        </li>
        <li><a href="#timestamps-1">Timestamps</a></li>
        <li><a href="#exfat-file-creation-and-deletion">exFAT File Creation and Deletion</a>
          <ul>
            <li><a href="#creation">Creation</a></li>
            <li><a href="#deletion">Deletion</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
 </aside>
</div>



          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">FAT</h1>
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    <div class="meta">
      
      
      <div class="article-category">
          
            
              <i class="fab fa-windows"></i>          
            
            
            
            
            
            
          
          
            
            
            
              <i class="fab fa-apple"></i>
            
            
            
            
          
          
            
            
              <i class="fab fa-linux"></i>
            
            
            
            
            
          
          
      </div> <br />
      

      
      

      
    </div>
  </header>


  <div class="content" itemprop="articleBody">
    <p>Any FAT partition has two main parts: system area and data area. System area contains FAT boot record (every file system has a boot record), 1st FAT and 2nd FAT. FAT12 and FAT16 also have Root directory in the system area. Data area consists of Root directory in case of FAT32 and file and subdirectory data in clusters.</p>
<h3 id="versions">Versions</h3>
<h4 id="fat12">FAT12</h4>
<p>For the cluster addressing there were 12 bits available, which is 2^12 clusters at most (4096 clusters).</p>
<h4 id="fat16">FAT16</h4>
<p>For the cluster addressing there were 16 bits available, which is 2^16 clusters at most (65536 clusters).</p>
<h4 id="fat32">FAT32</h4>
<p>For the cluster addressing there were 28 bits available (not 32), which is 2^28 clusters at most (268 435 456 clusters). 4 bytes were reserved. Unlike in FAT12 and FAT16 the Root directory is in the data area, giving more space for data.</p>
<h4 id="exfat">ExFAT</h4>
<p>Uses all 32 bits for cluster addressing. Thus, the maximum number of clusters is 2^32 which gives us 4 294 967 296 clusters to call. First supported by Windows CE 2006. Max volume size was 64 zettabytes ‚ùì. File size limit - 16 exabytes ‚ùì. Cross-platform. Used for large external media.</p>
<h3 id="fat-structure">FAT Structure</h3>
<h4 id="volume-boot-record">Volume Boot Record</h4>
<blockquote>
<p>‚ö†Ô∏è Not the MBR!!!!</p>
</blockquote>
<p>Located at sector 0 of the volume (‚ùóÔ∏è not the physical sector 0). Starts with a jump instruction 3 bytes long at offset <code>0x0</code> (relative to VBR). Contains information about the volume (offset relative to the VBR start - size - name - description). Relevant information below:</p>
<ul>
<li><code>0x3</code> - 8 - <strong>OEM ID</strong>. Most likely MS-DOS5.0 for Win2000 and above.</li>
<li><code>0x0B</code> - 2- <strong>Bytes per sector</strong> (512 usually)</li>
<li><code>0x0D</code> - 1 - <strong>Sectors per cluster</strong></li>
<li><code>0x0E</code> - 2 - <strong>Reserved sectors</strong></li>
<li><code>0x10</code>  - 1 - <strong>Number of FATs</strong> (2, one of them is for backup purposes)</li>
<li><code>1C</code> - 4 - <strong>Hidden sectors</strong> üôà (preceding the volume)</li>
<li><strong>Total sectors</strong> (size of the volume)</li>
<li><code>0x16</code> - 2 - <strong>Sectors per FAT</strong> (FAT12 and 16)</li>
<li><code>0x24</code> - 4 - <strong>Sectors per FAT</strong> (FAT32)</li>
<li><code>0x2C</code> - 4 - <strong>Starting cluster of the root</strong> dir (2nd usually)</li>
<li><code>0x32</code> - 2 - <strong>Back-up boot sector</strong> location (6th usually)</li>
<li><code>0x43</code> - 4 - <strong>Volume serial number</strong>. In case of thumbdrive, this serial number can be used to track the device across the PC and other systems.</li>
<li><code>0x47</code> - 11 - <strong>Volume name/label</strong> üè∑ (not user defined, &ldquo;NONAME&rdquo; usually)</li>
<li><code>0x52</code> - 8 - <strong>FS type</strong></li>
</ul>
<p>Here is the full information available:</p>
<p><img src="images/fat-boot-struct.png" alt="img"></p>
<h4 id="root-directory">Root Directory</h4>
<p>The name speaks for itself. It&rsquo;s the highest node in the dir structure of this volume, consists of 32 byte dir entries. Lists files and dirs in the root directory. FS stops reading these entries when it sees anything starting with <code>0x0</code>. So, data written here won&rsquo;t be seen by the OS and this is one of the ways to hide data. Types of root dir entries:</p>
<ul>
<li>
<p>volume name (user created)</p>
</li>
<li>
<p>short file name (8 uppercase letters + &ldquo;.&rdquo; + 3 letters for extension)</p>
<ul>
<li>
<p>8 bytes for the file name (uppercase), always includes a <code>~</code> at the -2 offset.</p>
</li>
<li>
<p>3 bytes for extension</p>
</li>
<li>
<p>1 byte for attributes (hidden (<code>0x02</code>), read-only (<code>0x01</code>), system (<code>0x04</code>), volume label (<code>0x08</code>), directory (<code>0x10</code>) and archive (<code>0x20</code>)). These attributes can be combined. Flags occupy just one byte and when there are more than one flag, their values are combined (like the access flags on Unix systems). See the attributes on the picture below. Only the bit for <code>volume</code> is set, which, given its position, has the value <code>0x08</code>.</p>
<p><img src="images/fat-short-attr.png" alt="fat-short-attr"></p>
</li>
<li>
<p>1 reserved byte - <code>0x00</code> for the long file name (not-8.3 compliant) and <code>0x10</code> for short file name (8.3 compliant) [<a href="https://www.coursera.org/learn/windows-os-forensics/home/welcome">5</a>]. In my case, however, it was always <code>0x00</code>.</p>
</li>
<li>
<p>1 byte for created time in 10 milliseconds</p>
</li>
<li>
<p>4 bytes for created date and time. See how the data is converted in the Timestamps section below.</p>
</li>
<li>
<p>Two bytes for Last accessed date (‚ö†Ô∏è no time!)</p>
</li>
<li>
<p>Pointer to the first cluster of the file/directory (high word). If the file is somewhere close to the disk start, it will be equal to <code>00 00</code>.</p>
</li>
<li>
<p>Four bytes for modified date and time</p>
</li>
<li>
<p>Pointer to the first cluster of the file/directory (low word).</p>
</li>
<li>
<p>Four bytes for the file size in bytes. ‚ö†Ô∏è It&rsquo;s always <code>00 00 00 00</code> for directories!!!</p>
</li>
</ul>
</li>
<li>
<p>long file name. Can consist of several entries (each 32-bits). If the file name is more than 8 characters, there will be more than one long entry. These are called a <em>set</em>. The last one contains the last characters + extension.</p>
<ul>
<li>1 byte for a status byte. When the entry is the last in the set (1 set for each file), its sequence number starts with <code>4</code>. Otherwise, it indiacates the entries number.</li>
<li>10 bytes for the file name (Unicode chars), i.e. for 5 characters of the name since one Unicode character occupies 2 bytes. If the file name is not long enough, unused bytes are filled with <code>0xFF</code>.</li>
<li>1 byte that&rsquo;s always <code>0x0F</code> and indicates a long file name.</li>
<li>1 byte reserved. In case it&rsquo;s <code>0x00</code> - it&rsquo;s a long file name. If it&rsquo;s <code>0x10</code> - short file name. So, along with the previous byte it can be used to determine that&rsquo;s the long name entry [<a href="https://www.coursera.org/learn/windows-os-forensics/home/welcome">5</a>]. In my case, however, it was always <code>0x00</code>.</li>
<li>1 byte for error correction (checksum)</li>
<li>12 bytes for the next part of the file name (6 Unicode characters). If the file name is not long enough, unused bytes are filled with <code>0xFF</code>.</li>
<li>2 bytes of zeroes</li>
<li>4 bytes for the next part of the file name (2 Unicode characters). If the file name is not long enough, unused bytes are filled with <code>0xFF</code>.</li>
</ul>
</li>
</ul>
<p>See below the example of a long entry <em>set</em> for a file with the name <code>asdjasdlkjasldkjsalkdaskljdjaljdajd.txt</code>. The lowest part - the short file name. Then there are three long file name entries. The first byte in the yellow area is <code>0x01</code>, meaning, it&rsquo;s the first entry in the set. The next (green one), has the first byte (sequence byte) set to <code>0x02</code>, indicating it&rsquo;s the second entry in the set.The last one (on the top, colored in red) has the status byte <code>0x43</code>. The first nibble (<code>4</code>) indicates that this is the last long entry in the set. The second nibble (<code>3</code>) is the sequence number.</p>
<p><img src="images/fat-long-fragmented.png" alt="fat-long-fragmented"></p>
<p>If the entry is a folder, its size will be <code>00 00 00 00</code> (the last 4 bytes). In its short file name entry find the first cluster, go this cluster and you&rsquo;ll see another list of files but that are in this folder. Find the entry for the file you are looking for.</p>
<p><strong>FAT high word</strong>. Start at 65536 and continue as power of two.</p>
<p><em>‚ùì Hot to get there?</em></p>
<p>From the FAT32 Boot Record get the following information:</p>
<ul>
<li><input disabled="" type="checkbox"> bytes per sector (2 bytes at offset <code>0x0B</code>) - marked with orange üçä</li>
<li><input disabled="" type="checkbox"> sectors per cluster (1 byte at offset <code>0x0D</code>) - marked with green üçè</li>
<li><input disabled="" type="checkbox"> number of reserved sectors  (2 bytes at offset <code>0x0E</code>) - marked with dark blue ü´ê</li>
<li><input disabled="" type="checkbox"> number of FATs  (one byte at offset <code>0x10</code>) - marked with coral ü¶û</li>
<li><input disabled="" type="checkbox"> sector per FAT (four bytes ar offset <code>0x24</code>) - marked with blue üåä</li>
</ul>
<p>All this information is needed to get the offset to the start of data area (in sectors!!!!). Since root directory is the first in the data area (FAT32 only), this will give us what we are looking for. Root directory is usually at the 2nd cluster <strong>relative to the start of the VBR</strong>, but better check at the offset <code>0x2C</code> (keep in mind the endianness). Then, we need to calculate the number of bytes to the data area/root directory.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="p">(</span><span class="n">number_of_FATs</span> <span class="o">*</span> <span class="n">sectors_per_fat</span><span class="p">)</span> <span class="o">+</span> <span class="n">reserved_sectors</span>
</span></span></code></pre></div><p>Here is an example:</p>
<p><img src="images/fat32-root-dir-find.png" alt="fat32-root-dir-find"></p>
<p>The values on the right pane represent raw data in hex, and on the left - its human-readable interpretation by Active@Disk Editor using a FAT32 Boot Record template. We get the value at <code>0x0B</code> which is <code>0x200</code> (when coverted to little-endian) and which equals 512 in decimal (marked in red). These are <strong>bytes per sector</strong> üçä.</p>
<p>We then go to offset <code>0x0D</code> which is <code>0x8</code> and 8 in decimal (marked in green). That&rsquo;s <strong>sectors per cluster</strong> üçè. Reading at offset <code>0x0E</code> ü´ê I get the <strong>number of reserved sectors</strong> (4110 in decimal). The <strong>number of FATs</strong> ü¶û is 2 (standard for FAT32) at offset <code>0x10</code> and the <strong>number of sectors per FAT</strong> üåä is 2041 in decimal.</p>
<p>Let&rsquo;s use the data in the formula: <code>(2 * 2041) + 4110 = 8192</code>. This is the starting sector of data area and usually it&rsquo;s the same with the root directory. Now, to get the numbrer of bytes to this root directory, we need to multiply <code>8192</code> by bytes per sector (512) = 4194304 in decimal (<code>0x400000</code> in hex). Our VBR starts at <code>0x00010000</code> in hex or <code>65536</code> in decimal. Adding 4194304 to 65536 (or <code>0x400000</code> to <code>0x10000</code>) will give us the offset to root directory from the start of VBR ( ‚ö†Ô∏è not GUID/MBR header). This value is 4259840 (<code>0x410000</code>). Let&rsquo;s go there in hex editor or if you are using Active@Disk Editor, using <strong>Go to offset</strong> button on the top pane. Voila!</p>
<p><img src="images/fat32-root-found.png" alt="fat32-root-found"></p>
<p>You may ask, what&rsquo;s the use of this information (knowing exactly how to find the offset of the root directory). There might be cases when we need to perform manual file recovery using a hex editor (remember, Active@Disk Editor is for Windows and Linux only) or with limited tools. Also, I find it useful to understand what the tool does, since tools fail too sometimes, as well as humans. We need to verify each other from time to time.</p>
<blockquote>
<p>‚ùì One question that remains for me here: why the hell is the root cluster <code>0x2</code>? The second cluster is <code>2 * (8 * 512) = 8192</code> bytes away from the VBR start and there is no root dir there. However, when clicking on the field in Active@Disk Editor, you&rsquo;ll get to the root dir.</p>
</blockquote>
<h4 id="directories-not-root">Directories (not Root)</h4>
<p>Entries for directories have <code>00 00 00 00</code> as file size, <code>0x10</code> as attributes value and <code>20 20 20</code> as extension. They point to some location, where files are listed. So, basically, a folder is just a pointer.</p>
<p>Root directory is the first in the tree, but not the only one. Each directory on the drive will have its own &ldquo;<em>table of contents</em>&rdquo; and its structure is a little different. It also consists of file name entries, each - 32 bytes long for FAT32.</p>
<p>The first 32 bytes start with a <code>0x2E</code> byte (<code>.</code> in ASCII). The rest of the information has the same structure as an ordinary SFN (short file name). In this case, about this directory itself.</p>
<p>The next 32 bytes start with a double <code>0x2E</code> byte (<code>.</code> in ASCII), i.e. <code>..</code>. The first cluster number would be <code>00 00</code> if the parent is the root directory. The rest of the information has the same structure as an ordinary SFN (short file name). In this case, about the parent directory.</p>
<blockquote>
<p>üóí If you are using a Terminal or console or PowerShell and <code>cd</code> somewhere from time to time, these both entries are not mysterious for you. For those who are not - <code>.</code> denotes the current directory, <code>..</code> the parent one. For example, you have the following folder structure:</p>
<ul>
<li>root
<ul>
<li>folder1
<ul>
<li>folder4 <code>&lt; current directory</code></li>
</ul>
</li>
<li>folder2
<ul>
<li>folder5
<ul>
<li>folder6</li>
</ul>
</li>
</ul>
</li>
<li>folder3</li>
</ul>
</li>
</ul>
<p>If we opened folder4, the value of <code>.</code> (current directory) is the address of folder4. While remaining in this folder, <code>..</code> (parent directory) for folder4 is folder1. <code>..</code> (parent directory) for folder1 is root. So,</p>
</blockquote>
<h4 id="file-allocation-table-fat">File Allocation Table (FAT)</h4>
<p>Keeps track of clusters in use and free ones. There are FAT1 and FAT2 (the same). FAT2 for backup. Both are located in the system area. Also, singly-linked list, each entry points to the next cluster of a file (in case a file is fragmented, i.e. occupies more than one cluster). <code>0x00000000</code> - the cluster is free, <code>0xffffff0f</code> - end of file, then pointer to the next cluster (if any).</p>
<p>The first four bytes in the FAT32 (two bytes in FAT12 and FAT16) is the media descriptor (<code>0xF8FFFFFF</code>, usually indicates a fixed disk). The next four bytes are for the FAT type (<code>0xFFFFFFFF</code> in case of FAT32). Then each four bytes tell us about each cluster ordered sequencially, i.e. CL-2 (contains the root directory in FAT32), then CL-3, then CL-4 etc. It can have three possible values: <code>0x00000000</code> - if the cluster is free, <code>0xffffff0f</code> - if the cluster is the last in the chain (end of file, EOF marker) or a pointer to the next cluster (if any, convert to little-endian and then to decimal to find it).</p>
<p>üõ† Using Active@Disk Editor, press <code>Navigate &gt; Primary FAT32 &gt; FAT1</code> button on the top pane. Here is the example from my flash drive:</p>
<p><img src="images/fat-fat-file.png" alt="fat-fat-file"></p>
<p>Discarding the media descriptor and FAT version (the first 8 bytes) in the picture above we can see several clusters, most of them containing EOF marker (<code>0xFFFFFF0F</code>). That means, most of the files occupy one cluster only. Clusters 2-12 are marked with green and orange rectangles for better accessibly. Cluster 13 is marked in red and its value is <code>0x014A</code> (<code>330</code>) after converting to little-endian. That means that cluster 13 is not the last one in the chain and the next cluster is cluster number 330.</p>
<p>Now, this is what a contiguous file would look like in FAT table (a file that occupies more than 1 cluster and the clusters following one another on disk):</p>
<p><img src="images/fat-fat-contig-file.png" alt="fat-fat-contig-file"></p>
<p>Let&rsquo;s read each 4 bytes starting from the cluster with the value <code>0x70 00 00 00</code>. This is the first cluster in the chain that points to the next cluster (<code>0x70</code> cluster, i.e. cluster 112 in decimal). Cluster 112 (<code>0x70</code>), the next one, points to the next cluster in the chain (<code>0x71</code>, i.e. 113) and so on and so forth. But as you may notice it&rsquo;s easy to note such chains.</p>
<p>To make it easier to read FAT32 table (which has 4 bytes for each entry), you may change view preferences in Active@Disk Editor (<code>File &gt; Preferences &gt; Disk Editor &gt; Bytes per line &gt; 4</code>).</p>
<h3 id="timestamps">Timestamps</h3>
<p>Local times, not UTC! For Last Accessed we only have date, no time!</p>
<p>Four bytes for date and time created (first two bytes for time üï∞ and the second two bytes for date üìÜ). The time bytes are first converted from the little-endian notation (two bytes flipped). In the example below, for the yellow short entry the created date and time <code>0x55 0x6E 0x31 0x53</code>. Bytes <code>0x55 0x6E</code> are for the time and <code>0x31 0x53</code> are for the date. Let&rsquo;s take the time bytes <code>0x55 0x6E</code>. Flip them to convert from the little-endian notation: <code>06E 0x55</code>. Convert each nibble to a binary value: <code>b0110</code>, <code>b1110</code>, <code>b0101</code>, <code>b0101</code>. Now, write them in a row and separate with the following template in mind: 5 bits - 6 bits - 5 bits: <code>b01101 b110010 b10101</code>. The first five bits are for hours, the next 6 bits are for minutes and the last ones are for seconds. Then, each value is converted into a decimal separately to get us 13 hrs, 50 mins and 21 seconds in the end (see the above picture only shows hours and minutes). For the date üìÜ value the template is 7-4-5 but the process is the same.</p>
<p><img src="images/fat-entry-struct.png" alt="fat-entry-struct"></p>
<h3 id="fat-file-creation-and-deletion">FAT File Creation And Deletion</h3>
<h4 id="creating">Creating</h4>
<p>Steps that are taken when a file is created:</p>
<ol>
<li>A directory entry is created is written to the parent directory</li>
<li>Data is written to the first available cluster</li>
<li>Entries in the FAT1 and FAT2 are made for all the clusters used</li>
</ol>
<h4 id="deleting">Deleting</h4>
<p>Steps that are taken when a file is deleted:</p>
<ol>
<li>The first character of the directory entry is changed to <code>0xE5</code>.</li>
<li>The clusters in the FAT1 and FAT2 are filled with zeroes.</li>
<li>The data area remains unchanged (‚ö†Ô∏è data is still out there!).</li>
</ol>
<h3 id="exfat-structure">exFAT Structure</h3>
<p>Also consists of System (Boot sector, backup boot sector, FAT1) and Data areas. exFAT doesn&rsquo;t have FAT2.</p>
<h4 id="boot-record">Boot Record</h4>
<p>Located at sector <code>0</code> of the volume. It contains the information about the volume (as usual).</p>
<blockquote>
<p>‚ö†Ô∏è Offsets are relative to the start of the volume.</p>
</blockquote>
<p>In general, it looks very close to FAT32. Something new - <code>bytes per sector shift</code> (between 9 and 12) and <code>bytes per cluster shift</code> (~sectors per cluster, 0-25). The value in this field is the power to which we need raise 2 to get the result. For example, if the field <code>bytes per sector shift</code> is set to 9, we raise 2 to the power of 9 (<code>2^9 = 512</code>, which means each sector is 512 bytes long). The same math is applied to the <code>bytes per cluster shift </code> field.</p>
<h4 id="fat1">FAT1</h4>
<p>32-bit entries. Media descriptor is the same: <code>0xFF FF FF F8</code>. Only tracks file fragmentation and doesn&rsquo;t track file allocation (Bitmap is used for that instead)!</p>
<h4 id="root-directory-1">Root Directory</h4>
<p>Types of directory entries:</p>
<ul>
<li>volume label (critical primary), <code>0x83</code>. User-created name for the volume. ‚ö†Ô∏è <em>Must be there!</em></li>
<li>file directory (critical primary) üçá. Tracks attributes, MAC times (UTC), ‚ö†Ô∏è <em>but doesn&rsquo;t point to the parent directory (no <code>..</code> entry like in FAT32)</em>. <code>0x85</code> - in use, <code>0x05</code> - free. ‚ö†Ô∏è<em>All files will have this entry!</em></li>
<li>stream extension directory (critical secondary) üçá. Size and start of the file. ‚ö†Ô∏è <em>Size of the filename is here (in characters)!</em> Starts with <code>0xC0</code> if in use, <code>0x40</code> if not. <code>Not FAT chain</code> - if set, it&rsquo;s not a fragmented file. Also, there are two interesting values: <code>Valid data length</code> (init size) and <code>Data length</code>. If, say a file was downloaded, FS will allocate certain amount of space. But if that download was interrupted, then the file won&rsquo;t occupy all the space, thus these two values will be different.</li>
<li>file name (critical secondary) üçá. Unicode for file name. <code>0xC1</code> if in use, <code>0x41</code> if not. Up to 15 Unicode chars. Might be more than one (~like long file names in FAT, can be more than one entry in case it&rsquo;s a long name).</li>
<li>system files (critical primary)
<ul>
<li>Bitmap <code>0x81</code>. Usually starts at cluster 2.</li>
<li>Upcase <code>0x82</code>. Usually starts at cluster 4.</li>
</ul>
</li>
</ul>
<p>Entries mared with üçá are those, that make up a <strong>directory set</strong>. Below is the breakdown of a directory set. The first byte (<code>0x85</code> in this case) indicates that the file is currently in use. It could be <code>0x05</code> if it were deleted.</p>
<p>The next byte is the secondary count, which indicated how many other directory entries we have in this file directory entry set (‚ùì). The next two bytes are for error checking and then the next two <code>0x3A 00</code> are attributes. The we have MAC times. We have last accesssed time, which we didn&rsquo;t in FAT32.</p>
<p><img src="images/exfat-dir-entry-set.jpg" alt="exfat-dir-entry-set"></p>
<h4 id="additional-files">Additional Files</h4>
<p>exFAT has two additional files that FAT32 does not. They probably come from the NTFS&hellip;: <code>Bitmap</code> and <code>Upcase</code> (table of Unicode chars, used to convert characters for searching).</p>
<blockquote>
<p>‚ö†Ô∏è Both files have an entry in the root directory, but don&rsquo;t have a filename.</p>
</blockquote>
<h3 id="timestamps-1">Timestamps</h3>
<p>UTC! The timezone offset is in 15mins increments (see a breakdown below). So, we have created, modified and last accessed date/times. Each of these timestamps will have a corresponding UTC offset in the file directory entry. It makes sense that these are always the same. In my case, <code>0xF4</code> <code>-2</code> in decimal, which would make a <code>UTC-2</code> (London timezone). We now know (in this case) that MAC times are for London timezone.</p>
<blockquote>
<p>‚ö†Ô∏è We have last accesssed <strong>time</strong>, which we didn&rsquo;t in FAT32.</p>
</blockquote>
<p>Below is the breakdown of how to convert a UTC byte into a human-readable value.</p>
<p><img src="images/exfat-utc.jpg" alt="exfat-utc"></p>
<h3 id="exfat-file-creation-and-deletion">exFAT File Creation and Deletion</h3>
<h4 id="creation">Creation</h4>
<ul>
<li><input disabled="" type="checkbox"> directory set created</li>
<li><input disabled="" type="checkbox"> bitmap for allocated clusters set to <code>1</code></li>
<li><input disabled="" type="checkbox"> FAT updated (if fragmented)</li>
<li><input disabled="" type="checkbox"> data written to the allocated clusters</li>
</ul>
<blockquote>
<p>üß™ Are the timestamps updated for a deleted file in the directory entry? exFAT, FAT32 and NTFS as well.</p>
</blockquote>
<h4 id="deletion">Deletion</h4>
<ul>
<li><input disabled="" type="checkbox"> first bytes of each entry in the directory entry set is set in a way to show the file is not in use (<code>05</code> for a file directory entry, <code>40</code> for stream <code>41</code> for filename entries).</li>
<li><input disabled="" type="checkbox"> bitmap entries for this file clusters are set to <code>0</code></li>
<li><input disabled="" type="checkbox"> FAT may or may not be zeroed out</li>
<li><input disabled="" type="checkbox"> file/dir contents remains there until and if is overwritten</li>
</ul>
<blockquote>
<p>‚ö†Ô∏è If the parent folder is deleted, the child entries remain unchanged.</p>
</blockquote>

  </div>
</article>
</div>
</div>

        </div>
      </div>
    </div>
    
  </div>

  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            <li class="zerostatic"><a href="https://www.zerostatic.io">www.zerostatic.io</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.302a6fc365d5139fb98cf60bdb8f715d96257ea189161d36c190ccfa8182e569.js"></script>
  

  
  
  
    
  


</body>

</html>
