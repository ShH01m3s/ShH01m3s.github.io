<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>NTFS - Analyst</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://bakerst221b.com/favicon.png">
  <link href="/css/style-classic.css"></link>
  
  
  <link rel="stylesheet" href="/css/style.min.564b5f4faf3af87992cb8ab298314448914c22dbdb3f2f9c584546b21b8d407c.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home ğŸ¡">
      <a href="/">
        <span>Home ğŸ¡</span>
      </a>
    </li>
    
    <li class="menu-item-blog âœï¸">
      <a href="/docs/blog">
        <span>Blog âœï¸</span>
      </a>
    </li>
    
    <li class="menu-item-ttp ğŸ”">
      <a href="/docs/ttp">
        <span>TTP ğŸ”</span>
      </a>
    </li>
    
    <li class="menu-item-artefacts db ğŸº">
      <a href="/docs/artefacts">
        <span>Artefacts DB ğŸº</span>
      </a>
    </li>
    
    <li class="menu-item-attacks db âš”ï¸">
      <a href="/docs/attacks">
        <span>Attacks DB âš”ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-tools db ğŸ› ï¸">
      <a href="/docs/tools">
        <span>Tools DB ğŸ› ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-crypto ğŸ—ï¸">
      <a href="/docs/cryptography">
        <span>Crypto ğŸ—ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-about me ğŸ§ğŸ½â€â™€ï¸">
      <a href="/docs/about">
        <span>About me ğŸ§ğŸ½â€â™€ï¸</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo.png" /></a>
    </div>
    <div class="logo-mobile">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo-mobile.svg" /></a>
    </div>
    

    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home ğŸ¡">
      <a href="/">
        <span>Home ğŸ¡</span>
      </a>
    </li>
    
    <li class="menu-item-blog âœï¸">
      <a href="/docs/blog">
        <span>Blog âœï¸</span>
      </a>
    </li>
    
    <li class="menu-item-ttp ğŸ”">
      <a href="/docs/ttp">
        <span>TTP ğŸ”</span>
      </a>
    </li>
    
    <li class="menu-item-artefacts db ğŸº">
      <a href="/docs/artefacts">
        <span>Artefacts DB ğŸº</span>
      </a>
    </li>
    
    <li class="menu-item-attacks db âš”ï¸">
      <a href="/docs/attacks">
        <span>Attacks DB âš”ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-tools db ğŸ› ï¸">
      <a href="/docs/tools">
        <span>Tools DB ğŸ› ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-crypto ğŸ—ï¸">
      <a href="/docs/cryptography">
        <span>Crypto ğŸ—ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-about me ğŸ§ğŸ½â€â™€ï¸">
      <a href="/docs/about">
        <span>About me ğŸ§ğŸ½â€â™€ï¸</span>
      </a>
    </li>
    
  </ul>
</div>
    
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
    
    <div style="margin-left: 20pt;">
      <a href="/index.xml" type="application/rss+xml">
        <img src="/images/rss.png" alt="RSS Feed">
      </a>
    </div>
    
    <style>
      a[href="/index.xml"] {
        display: inline-block;
        vertical-align: middle;
        margin-right: 10px;
      }
    
      a[href="/index.xml"] img {
        height: 30px;
      }
    </style>
    
  </div>
</div>


    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <p>
   <a href="/docs/artefacts/fs/"> ğŸ‘ˆğŸ¼ Back to </br> File Systems </a>
  </p>
  <aside>
   <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#versions">Versions</a>
          <ul>
            <li><a href="#v10">V1.0</a></li>
            <li><a href="#v12">V1.2</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#features">Features</a></li>
    <li><a href="#-anatomy">ğŸ’€ Anatomy</a>
      <ul>
        <li><a href="#volume-boot-record">Volume Boot Record</a></li>
        <li><a href="#mft">MFT</a>
          <ul>
            <li><a href="#standard-attribute">Standard attribute</a></li>
            <li><a href="#file-name">File name</a></li>
            <li><a href="#data-attribute">Data attribute</a></li>
            <li><a href="#object-id-attribute">Object ID attribute</a></li>
            <li><a href="#bitmap-attribute">Bitmap attribute</a></li>
          </ul>
        </li>
        <li><a href="#logfile-and-usnjrnl"><code>$LogFile</code> And <code>$UsnJrnl</code></a></li>
      </ul>
    </li>
    <li><a href="#file-creation-and-deletion">File Creation and Deletion</a>
      <ul>
        <li><a href="#creating-files">Creating Files</a></li>
        <li><a href="#deleting-files">Deleting Files</a></li>
      </ul>
    </li>
    <li><a href="#-timestamps">â° Timestamps</a></li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
 </aside>
</div>



          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">NTFS</h1>
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    <div class="meta">
      
      
      <div class="article-category">
          
            
              <i class="fab fa-windows"></i>          
            
            
            
            
            
            
          
          
      </div> <br />
      

      
      <div class="article-category">
        <i class="fas fa-tools"></i>
          
          
          <a class="platform-link" href="/tools/active-killdisk">Active@ KillDisk</a> 
          
      </div> <br />
      
      

      
    </div>
    
    <b>Created:</b> 18.10.2020
    <br />

    

  </header>


  <div class="content" itemprop="articleBody">
    <p>Developed in collaboration with IBM. POSIX compliant. Official docs for NTFS <a href="http://ntfs.com/ntfs-mft.htm">here</a>.</p>
<blockquote>
<p>â—ï¸ Everything is a file!
â—ï¸ All offsets are relative to the start of the data structures.
â—ï¸ Apple macOS machines can read NTFS devices but do not support writing to them by default.</p>
</blockquote>
<p>The entire logical volume is a data area (in contrast to FAT where there is a system area as well â“).</p>
<p>In a Microsoft NT File System (NTFS), hot fixing of disk sectorsÂ <strong>prevents data from being stored in aÂ bad sectorÂ or cluster</strong>.</p>
<p>The NTFS (New Technology File System) file system provides file-level security:</p>
<ol>
<li>NTFS permissions allow you to set specific access rights for individual users or groups on a file or folder. These permissions include read, write, execute, and delete access and more advanced permissions like modify, full control, and take ownership.</li>
<li>You can also set permissions to allow or deny access to specific types of users or groups, such as administrators, authenticated users, or specific user accounts.</li>
<li>NTFS uses ACLs to define more complex access control policies. ACLs allow you to define sets of permissions for multiple users or groups, and can be used to define more fine-grained access control policies. For example, you can create an ACL that allows members of a certain group to read and modify files in a particular folder, but denies access to other users.</li>
<li>NTFS also provides other security features, such as file and folder encryption using BitLocker, and auditing to track access and modifications to files and folders. Overall, NTFS is a robust file system that provides a wide range of security features to help you protect your files and data.</li>
</ol>
<h3 id="versions">Versions</h3>
<h4 id="v10">V1.0</h4>
<p>The first release of Windows NT 3.1. Windows XP and above. It allowed for data recovery, rollback (restore the system to the last stable state) and larger volumes. Windows 8 + faster data recovery and cross platform. Windows 10 + extended logging features.</p>
<blockquote>
<p>âš ï¸ Windows Vista and above can obly be installed on a NTFS volume!</p>
</blockquote>
<h4 id="v12">V1.2</h4>
<p>Windows NT 3.51, included admin controls, compressed files and User Access Control (recycle bin for each user and own account).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="se">\$</span>Recycle.Bin<span class="se">\ </span><span class="o">(</span><span class="nv">$R</span><span class="p">&amp;</span><span class="nv">$I</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="se">\R</span>ECYCLER
</span></span></code></pre></div><h2 id="features">Features</h2>
<p>ğŸª¶ Journaling, aka transaction logging. Records change to the metadata of FS.
ğŸª¶ ACL
ğŸª¶ Compression
ğŸª¶ Change tracking
ğŸª¶ Disk usage quotas. So that one user won&rsquo;t eat up the entire volume.
ğŸª¶ VSC
ğŸª¶ Hard and Soft links (required to be POSIX compliant). One file has several names - hard links. Several pointers to the same file - soft links.
ğŸª¶ Reparse points. Different file usage types.
ğŸª¶ ADS
ğŸª¶ Distributed link tracking. Some files have an object ID to track them across the system (when the file was renamed, how many times, where it was moved, etc).
ğŸª¶ Volume mount points
ğŸª¶ Sparse file support
ğŸª¶ Encryption
ğŸª¶ Single instance storage. Similar to soft links. How is it different?</p>
<h2 id="-anatomy">ğŸ’€ Anatomy</h2>
<h3 id="volume-boot-record">Volume Boot Record</h3>
<p>In the <code>$MFT</code> is represented as <code>$Boot</code>. It&rsquo;s located at the sector <code>0</code> of the volume (not physical disk!). Below is the VBR structure for NTFS. The most important entries for forensic purposes are highlighted.</p>
<p><img src="images/ntfs-boot-record-struct.png" alt="img"></p>
<h3 id="mft">MFT</h3>
<p>The heart â™¥ï¸ of NTFS. Created once the disk/volume is formatted with NTFS. It&rsquo;s an index of every single file on disk (at least 1 entry of a file), including  NTFS metadata files (those that start with <code>$</code>). The first 26 records are for the system metadata files. Records 12-23 are reserved. Records 24-26 transaction log and error recovery. The first user-created file is usually at index 35.</p>
<p>Below is the full table of the files [<a href="https://flatcap.org/linux-ntfs/ntfs/files/index.html">6</a>].</p>
<table>
<thead>
<tr>
<th style="text-align:right">Inode</th>
<th style="text-align:left">Filename</th>
<th style="text-align:left">OS</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/mft.html">$MFT</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Master File Table - An index of every file. It describes the MFT itself.</td>
</tr>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/mftmirr.html">$MFTMirr</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">A <strong>backup copy</strong> of the first 4 records of the MFT that is required in case MFT gets damaged.</td>
</tr>
<tr>
<td style="text-align:right">2</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/logfile.html">$LogFile</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Transactional logging file</td>
</tr>
<tr>
<td style="text-align:right">3</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/volume.html">$Volume</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Serial number, creation time, dirty flag</td>
</tr>
<tr>
<td style="text-align:right">4</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/attrdef.html">$AttrDef</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Attribute definitions.</td>
</tr>
<tr>
<td style="text-align:right">5</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/dot.html">. (dot)</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Root directory of the disk</td>
</tr>
<tr>
<td style="text-align:right">6</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/bitmap.html">$Bitmap</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Contains volume&rsquo;s cluster map (in-use vs. free), used to identify open clusters. See more <a href="https://whereismydata.wordpress.com/2009/06/01/forensics-what-is-the-bitmap/">here</a></td>
</tr>
<tr>
<td style="text-align:right">7</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/boot.html">$Boot</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Boot record of the volume</td>
</tr>
<tr>
<td style="text-align:right">8</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/badclus.html">$BadClus</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Lists bad clusters on the volume</td>
</tr>
<tr>
<td style="text-align:right">9</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/quota.html">$Quota</a></td>
<td style="text-align:left">NT</td>
<td style="text-align:left">Quota information</td>
</tr>
<tr>
<td style="text-align:right">9</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/secure.html">$Secure</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Security descriptors used by the volume</td>
</tr>
<tr>
<td style="text-align:right">10</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/upcase.html">$UpCase</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Table of uppercase characters used for collating</td>
</tr>
<tr>
<td style="text-align:right">11</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/extend.html">$Extend</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">A directory: $ObjId, $Quota, $Reparse, $UsnJrnl</td>
</tr>
<tr>
<td style="text-align:right">12-15</td>
<td style="text-align:left">Unused</td>
<td style="text-align:left"></td>
<td style="text-align:left">Marked as in use but empty</td>
</tr>
<tr>
<td style="text-align:right">16-23</td>
<td style="text-align:left">Unused</td>
<td style="text-align:left"></td>
<td style="text-align:left">Marked as unused</td>
</tr>
<tr>
<td style="text-align:right">Any (25)</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/objid.html">$ObjId</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Unique Ids given to every file</td>
</tr>
<tr>
<td style="text-align:right">Any (24)</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/quota.html">$Quota</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Quota information</td>
</tr>
<tr>
<td style="text-align:right">Any (26)</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/reparse.html">$Reparse</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Reparse point information</td>
</tr>
<tr>
<td style="text-align:right">Any</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/usnjrnl.html">$UsnJrnl</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Journalling of Encryption (usually at <code>/$Extend</code> directory, see above). Known as a Change Journal.</td>
</tr>
</tbody>
</table>
<p>These files cannot be opened from the user space, it&rsquo;s maintained by NTFS driver. So, even if shown by Directory Snoop, you can&rsquo;t open it on a live system. You can view the hex data though in DS-NTFS. Another option would be to make a disk image and carve the files. View some more information here [<a href="http://blog.opensecurityresearch.com/2011/10/how-to-acquire-locked-files-from.html">3</a>].</p>
<p><strong><code>\$Extend\$UsnJrnl</code></strong>. Journal change log for NTFS system. EVERYTHING! File and directory deletion, creation, and encryption.</p>
<p><strong><code>$LogFile</code></strong>. It&rsquo;s a transaction journal of $MFT. Very similar to <code>$UsnJrnl</code>, but lives less. Tracks file creation, modification, renaming and deletion. May not exist, but since Windows Vista <code>$UsnJrnl</code> is there <strong>by default</strong>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ğŸ“˜ istat <span class="o">[</span>options<span class="o">]</span> image inode -z timezone <span class="c1"># parses the information in the MFT entries. </span>
</span></span></code></pre></div><p>A MFT record contains the following info and is usually 1024 bytes long:</p>
<ul>
<li>file allocation status</li>
<li>file dates</li>
<li>file name</li>
<li>location</li>
</ul>
<p>Every object gets an entry with attributes to describe it.</p>
<p><img src="images/ntfs-attr-overview.png" alt="img"></p>
<table>
<thead>
<tr>
<th>ğŸ—’ï¸ FILES</th>
<th>ğŸ“‚ DIRECTORIES</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x10</code> <code>$STANDARD_INFORMATION</code></td>
<td><code>0x10</code> <code>$STANDARD_INFORMATION</code></td>
</tr>
<tr>
<td><code>0x30</code> <code>$FILE_NAME</code> (long)</td>
<td><code>0x30</code> <code>$FILE_NAME</code> (long)</td>
</tr>
<tr>
<td><code>0x30</code> <code>$FILE_NAME</code> (short, sometimes)</td>
<td><code>0x30</code> <code>$FILE_NAME</code> (short, sometimes)</td>
</tr>
<tr>
<td><strong><code>0x80</code> <code>$DATA</code></strong></td>
<td><strong><code>0x90</code> <code>$INDEX_ROOT</code></strong></td>
</tr>
<tr>
<td><strong><code>0x80</code> <code>$DATA</code> (ADS, sometimes)</strong></td>
<td><strong><code>0xA0</code> <code>$INDEX_ALLOCATION</code> (sometimes)</strong></td>
</tr>
</tbody>
</table>
<p>Volume <strong>name</strong> also gets an entry (always <code>#3</code> for the <code>$VOLUME</code> system file).</p>
<p>Records start at index <code>0</code> (for the MFT record itself) and are numbered sequentially. Each record is usually 1024 bytes. New records are created on a first-available basis, i.e. if a record was deleted (deallocated), it gets overwritten once a new one is created, and the deallocated one is the first free index in the table.</p>
<p>A file record begins with a header (ASCII <code>FILE</code> or <code>BAAD</code> if corrupted). It contains info about the file. It&rsquo;s made up of attributes. Each of them contains specific information about the file record entry. Each record ends with a <code>0xFF FF FF FF</code>. It has a sequence number at offset <code>0x10</code> 2 bytes long, incremented each time the file is deleted (not allocated â—ï¸). At offset <code>0x16</code> there is an allocation status flags: <code>0x00</code> for deleted file, <code>0x01</code> for allocated one, <code>0x02</code> for deleted dir, <code>0x03</code> for allocated dir.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># if you have an MFT record number, you can pass to istat</span>
</span></span><span class="line"><span class="cl">ğŸ“˜ istat imagefile MFT_record_number
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># output:</span>
</span></span><span class="line"><span class="cl">&gt; allocation status
</span></span><span class="line"><span class="cl">&gt; MFT entry number 
</span></span><span class="line"><span class="cl">&gt; <span class="nv">$LogFile</span> sequence number
</span></span><span class="line"><span class="cl">&gt; <span class="nv">$Standard_Information</span> attribute <span class="o">(</span>flags, security info, <span class="nv">$UsnJrnl</span> number, MACB timestamps<span class="o">)</span>
</span></span></code></pre></div><p>At the offset 0x10 you can see aa sequence number that gets incremented when the file is deleted. When the MFT entry was created for the first time, the value is set to <code>1</code>. When the file is deleted, the value is incremented by <code>1</code>. Then, when this entry is reused, the sequence number remains the same and only gets incremented when the file is deleted, and the entry gets unallocated again.</p>
<p>Hard Link count at offset <code>0x12</code> specified how many <code>$FILE_NAME</code> attributes this file has. This includes both long and short names as well as real hard links.</p>
<p>At offset 0x16 we can see a flag which can have either of the following values:</p>
<p>ğŸ‡¬ğŸ‡§ <code>0x00</code> <code>0000</code> Not in use</p>
<p>ğŸ‡¬ğŸ‡§ <code>0x01</code> <code>0001</code> file in use</p>
<p>ğŸ‡¬ğŸ‡§ <code>0x02</code> <code>0010</code> dir deleted</p>
<p>ğŸ‡¬ğŸ‡§ <code>0x03</code> <code>0011</code> dir in use</p>
<p>When the file is deleted, the flag is set to <code>0x0</code>, but the rest of the MFT entry remains intact until it&rsquo;s reused by another file.</p>
<p>Data at <code>0x18</code> and <code>0x1C</code> show the real and allocated (including slack) space for this FILE record. At <code>0x20</code> we can see the File Reference to Base Record which can be something other than 0 sometimes when there are too many attributes for the given file to fit in 1024 bytes.</p>
<p>At the offset <code>0x28</code> we will see the Next available attribute ID. Each will have a unique ID that starts at 0.</p>
<p>At the offset <code>0x2C</code> we have the inode (MFT entry ID) number. This data was added to the newer NTFS versions, changing the length of the data. So, the pointer to the fix-up array at the beginning (offset <code>0x4</code>) used to be <code>0x2A</code> (<code>*</code> in ASCII) on older versions is now <code>0x30</code> (<code>0</code> in ASCII). Keep that in mind when carving for <code>FILE</code> records.</p>
<p>Finally, we have fix-up information at the <code>0x30</code> offset. <a href="https://dtidatarecovery.com/ntfs-master-file-table-fixup/">Here</a> is how the fix-up works:</p>
<ol>
<li>Read the records two sectors from the MFT.</li>
<li>Read the two byte offset of the Update Sequence Array located right after the four byte record magic value</li>
<li>Compare the first number in the array to the number at offset 510 in sector 1</li>
<li>If the values do not match indicate and error. This is when â€˜chkdskâ€™ could be run</li>
<li>Repeat steps 3 and 4 for sector 2</li>
<li>Take the next value in the Update Sequence Array and write it at offset 510 in sector 1</li>
<li>Repeat step 6 for sector 2</li>
</ol>
<p>Following the header, there are four attributes (each consists of a header and contents):</p>
<p><strong>Directories</strong>. A directory is almost a file, but instead of data, it contains references to other files. Sometimes, even unallocated <code>$INDEX_ALLOCATION</code> has a list of files&rsquo; <code>$FILE_NAME</code> values. <code>$INDEX_ROOT</code> is always present, and <code>$INDEX_ALLOCATION</code> is only needed when there are more entries. The latter looks pretty much like <code>$DATA</code> for files. <code>$INDEX_ROOT</code> + <code>$INDEX_ALLOCATIONS</code> (optional) = <code>$I30</code>.</p>
<p><code>$INDEX_ALLOCATION</code>/<code>$INDEX_ROOT</code> header starts with an <code>INDX</code> magic number (<code>0x49 0x4E 0x44 0x58</code>). At the offset 0x20 allocated size of entries is specified, and the offset 0x1C holds the real size of the entries. Given these two values, we can calculate the slack space which might contain some residual data from previously deleted/deallocated entries. The header takes 0x40 bytes.</p>
<p>At the offset <code>0x40</code> the <code>$I30</code> index entry starts. The first 8 bytes are MFT number. It points to the MFT entry that holds all the metadata about the file. Some info like â° timestamps (<code>$STANDARD_INFORMATION</code>) and filenames are copies from the MFT entry to improve performance. Each folder and file has its entry here. Each entry has a 16-byte long header. At the offset <code>0x60</code> we have four (<code>bmca</code>) â° timestamps 8-byte in size. At the offset <code>0x90</code> we have name length (2 bytes) and type followed by the file name itself.</p>
<p>This index is a B-tree that needs to be rebalanced from time to time, leaving some interesting data in the slack space during this process.</p>
<p>User ğŸ› ï¸ <code>indx2csv</code> and ğŸ› ï¸ <code>Velociraptor</code> can be both used to parse this artefact. Also, ğŸ› ï¸ <code>INDXparse.py</code> parses individual <code>$I30</code> only. Also, ğŸ› ï¸ <code>icat</code> can be used to extract the index from the image.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ğŸ“˜ icat image MFT_num-160-attr_id &gt; <span class="nv">$I30</span> <span class="c1"># extract the index from the disk image</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ğŸ“˜ indx2csv /IndxFile:G:<span class="se">\c</span>ases<span class="se">\$</span>I30 /OutputPath:G:<span class="se">\c</span>ases
</span></span><span class="line"><span class="cl">ğŸ“˜ Velociraptor artifacts collect Windows.NTFS.I30 --args <span class="nv">DerectoryGlobs</span><span class="o">=</span><span class="s2">&#34;F:\\Windows\\Temp\\Permon&#34;</span> --format<span class="o">=</span>csv
</span></span></code></pre></div><h4 id="standard-attribute">Standard attribute</h4>
<p>Starts with <code>0x10</code>. Standard attribute (file permissions, â° timestamps, security and admin info). Below is the attribute highlighted. Note, that there are very useful timestamps at <code>0x18</code>: file created/modified, record changed and last access time. â—ï¸ All UTC.</p>
<p><img src="images/ntfs-attr-10.png" alt="img"></p>
<p>At offset <code>0x38</code> we have flags, showing the file attributes. Possible values are:</p>
<p>ğŸ‡¬ğŸ‡§ <code>10 00 00 00</code> Directory</p>
<p>ğŸ‡¬ğŸ‡§ <code>20 00 00 00</code> Archive</p>
<p>ğŸ‡¬ğŸ‡§ <code>40 00 00 00</code> Device</p>
<p>ğŸ‡¬ğŸ‡§ <code>30 00 00 00</code> Normal</p>
<p>ğŸ‡¬ğŸ‡§ <code>01 00 00 00</code> Read Only</p>
<p>ğŸ‡¬ğŸ‡§ <code>02 00 00 00</code> Hidden</p>
<p>ğŸ‡¬ğŸ‡§ <code>04 00 00 00</code> System</p>
<p>ğŸ‡¬ğŸ‡§ <code>00 10 00 00</code> Offline</p>
<p>ğŸ‡¬ğŸ‡§ <code>00 20 00 00</code> Not Indexed</p>
<p>ğŸ‡¬ğŸ‡§ <code>00 40 00 00</code> Encrypted</p>
<p>ğŸ‡¬ğŸ‡§ <code>00 0100 00</code> Temporary</p>
<p>ğŸ‡¬ğŸ‡§ <code>00 02 00 00</code> Sparse File</p>
<p>ğŸ‡¬ğŸ‡§ <code>00 04 00 00</code> Reparse Point</p>
<p>ğŸ‡¬ğŸ‡§ <code>00 08 00 00</code> Compressed</p>
<p>Note that each flag has only one specific bit at a fixed offset set. When there are multiple flags for one file, their values are combined. For example, to calculate the final flag value for a file which is an archive (ğŸ‡¬ğŸ‡§ <code>20 00 00 00</code>) and is both a hidden (ğŸ‡¬ğŸ‡§ <code>02 00 00 00</code>) and a system file (ğŸ‡¬ğŸ‡§ <code>04 00 00 00</code>) we would have <code>20</code> as the first byte and <code>0x02</code> + <code>0x04</code> <code>as</code> the second, resulting in the flag value being set to <code>0x26</code>. If this file were also
encrypted, we would have <code>0x2640</code>.</p>
<h4 id="file-name">File name</h4>
<p>Starts with <code>0x30</code>. It also has â° timestamps, but for the <strong>filename</strong>. The first 6 bytes are for the parent directory&rsquo;s MFT record (it&rsquo;s not a cluster number like in FAT). The timestamps below are for the filename changes, not the changes for the file itself. For the file timestamps, see the attribute <code>0x10</code> (above). If the file is resident, its contents will be contained in the MFT. If the file is too big, there will be a <code>data run</code> instead (â“).</p>
<p><img src="images/ntfs-attr-30.png" alt="img"></p>
<p>Contains ğŸ¾ objects name, ğŸ¾ parent folder and â° filename timestamps which are not natively shown by Windows. It also includes ğŸ¾ file properties like if it&rsquo;s an archive or a hidden file.</p>
<p>At the offset <code>0x18</code> we have the parent directory reference specified. The first 6 bytes are the MFT entry number of the directory, and the remaining 2 represent the sequence number for this MFT record.</p>
<p>Another set of â° timestamps begins at the offset <code>0x20</code>.</p>
<p>The flags at the offset <code>0x50</code> are the same as in <code>$STANDARD_INFORMATION</code>.</p>
<p>At the offset <code>0x58</code> we have the number of Unicode characters that the filename consists of. Since Unicode characters are two bytes long, we need to double this number to get the exact number of bytes to read. Since this value is only one byte long, the max value it can have is <code>0xFF</code> which is <code>255</code> in decimal. That&rsquo;s why you can&rsquo;t have a filename longer than <code>255</code> characters. And then, at the offset <code>0x59</code> we have a namespace type which can be either of the following: <code>0x00</code> for POSIX (different case - different name), <code>0x01</code> for Win32 (case-sensitive long name), <code>0x02</code> for DOS (DOS-compatible short name) and <code>0x03</code> for Win32/DOS (the name is short enough to only have one <code>$FILE_NAME</code>, DOS-compatible). If the file name is long enough, the second <code>$FILE_NAME</code> attribute is created which preserves the case.</p>
<h4 id="data-attribute">Data attribute</h4>
<p>âš ï¸ Yes, data is considered an attribute in NTFS. Starts with <code>0x80</code>.  Contains data itself or the pointer to its location (depending on the file size). If the file is small enough, its contents will be here (below, green area). In this case the file is called <em>resident</em> file. Whether it&rsquo;s a resident file or not, you can determine by the <em>non-resident</em> byte (marked with a red rectangle in the picture below). In the picture below it&rsquo;s <code>0x00</code>, which means the file <em>is</em> resident and its contents is in the MFT record (right below). Marked with a green rectangle it&rsquo;s the offset to the data, for resident files it&rsquo;s always <code>0x0018</code> (little-endian), since the start of the data section is in the attribute itself at the fixed place.</p>
<p><img src="images/ntfs-attr-80.png" alt="img"></p>
<p>In the picture below there is an example of a record for a bigger file. Its non-resident flag is set to <code>0x01</code> (marked with a purple rectangle), meaning the contents is somewhere else on the disk. In order to find the file contents location, we need to perform the following steps:</p>
<ul>
<li><input disabled="" type="checkbox"> get the offset to data runs, which contain directions to the location of the content (pointer). In the picture below it&rsquo;s <code>0x0040</code> (little-endian). This offset is relative to the attribute start. So, we count <code>0x40</code> from the attribute start and get to the location marked with a dark-red rectangle: <code>21 10 89 09 00 00 00 00</code> (run list).</li>
<li><input disabled="" type="checkbox"> read the run list.</li>
</ul>
<p><img src="images/ntfs-nonresident-set.png" alt="img"></p>
<p>Now, what&rsquo;s a run list?</p>
<p><img src="images/ntfs-big-nonresident-run-list.png" alt="img"></p>
<p>In the picture below this structure is highlighted on the left and expalined on the right. The first byte is the run header, it tells the number of bytes, occupied by the run list. The second byte tells the length in clusters. The next two bytes are for the starting cluster number (<strong>signed</strong> 16-bit value). End the remaining 4 bytes of zeroes - end of run.</p>
<blockquote>
<p>âš ï¸ To interpret the run header, split the byte into two nibbles and add them together: <code>2</code> + <code>1</code> = <code>3</code>, meaning, in the example above the run list length is 3 bytes. The first nibble (<code>2</code>  in this example) tells that the size of the first cluster field is 2 bytes. The second nibble tells that the size of the cluster count field of 1 byte (<code>1</code>). Together combined it&rsquo;s 3. meaning that both cluster count and first cluster fields are 3 bytes long.</p>
</blockquote>
<p>If the file is fragmented, there will be more than 1 data run. If there are more than 1 data run, then each next first cluster field is relative to the previous one. For example, if the first cluster for the first fragment in the first data run was <code>0x42A9</code> (17065 in decimal), and the next first cluster for the next fragment in the next data run is <code>0xBFBF</code> (-16449 decimal) then in order to get the first cluster for the second fragment, we would substitute 16449 from 17065 which would give us 616 decimal value, which would be the first cluster of the second fragment [<a href="https://www.coursera.org/learn/windows-os-forensics/home/welcome">5</a>]. So, each value is relevant to the last piece. To get the first cluster of the next fragment you&rsquo;d add it&rsquo;s value to 616 and so on and so forth. Active@Disk Editor does that automatically.</p>
<h5 id="ads">ADS</h5>
<p>On Windows machines (NTFS file system), itâ€™s possible to â€œappendâ€ a file to another file in such a way that this file is not visible with standard tools. This notion is called an alternate data stream. A few things to note:</p>
<ol>
<li>The host fileâ€™s hash is not changed, because, technically, it is not a part of this file. To check use ğŸ› ï¸ <code>fciv</code></li>
<li>The host fileâ€™s size is not changed, again, because technically, it is not a part of this file.</li>
<li>These files are not visible for the file system and therefore, such tools as cmd, PowerShell, Explorer or others wonâ€™t see them if donâ€™t know the magic ğŸª„ word. Even if you run <code>ğŸ“˜ type filewithlitter.txt</code> you wonâ€™t see the stream fileâ€™s contents, only the main one.</li>
<li>When you copy files from and to a FAT partition - all residual files will be deleted.</li>
</ol>
<p>Now, if there are several streams for one MFT entry, the first one doesn&rsquo;t have a name specified and inherits it from the <code>$FILE_NAME</code> attribute. All other <code>$DATA</code> streams need to have a name and can all be either resident or not.</p>
<p>To extract the data from the $DATA stream:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ğŸ“˜ icat <span class="o">[</span>options<span class="o">]</span> imagefile inode &gt; data.data <span class="c1"># -r recovers deleted files, -s displays slack space. </span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># To extract ADS</span>
</span></span><span class="line"><span class="cl"><span class="c1"># You can also pipe this output through xxd to review the data in hex</span>
</span></span><span class="line"><span class="cl">ğŸ“˜ icat <span class="o">[</span>options<span class="o">]</span> imagefile inode-attributetype-id &gt; data.data <span class="c1"># where attribute type is also a number</span>
</span></span></code></pre></div><p><strong>Zone.Identifier</strong>. One of the ADS that can be of use and is present for some files is called <code>Zone.Identifier</code>. When a file is downloaded from the Internet using IE or Edge (or some other apps), an ADS is added to the file on an NTFS file system. This <code>Zone.Identifier</code> stream contains metadata about where the file came from. Here are possible values for this metadata:</p>
<p><code>ZoneId=0</code> for the Local Machine zone</p>
<p><code>ZoneId=1</code> for the Local Intranet zone</p>
<p><code>ZoneId=2</code> for the Trusted Sites zone</p>
<p><code>ZoneId=3</code> for the Internet zone. This is of particular interest for the investigation. What files are ok to be downloaded from the Internet? Would you expect <code>svchost.exe</code> to be downloaded?</p>
<p><code>ZoneId=4</code> for the Restricted Sites zone</p>
<p><strong>Custom</strong>. To ensure compatibility between NTFS and HFS. Allows hiding files.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ğŸ“˜ C:<span class="se">\t</span>ype C:<span class="se">\m</span>al.exe &gt; C:<span class="se">\r</span>eadme.txt:naughty.exe
</span></span><span class="line"><span class="cl">ğŸ“˜ start readme.txt:naughty.exe
</span></span><span class="line"><span class="cl">ğŸ“˜ C:<span class="se">\m</span>klink innocent.exe readme.txt:naughty.exe
</span></span><span class="line"><span class="cl">ğŸ“˜  dir /r <span class="c1"># displays all streams</span>
</span></span></code></pre></div><p>ğŸ› ï¸ <code>lns</code> and ğŸ› ï¸ <code>sfind</code> will hunt down such files.</p>
<h4 id="object-id-attribute">Object ID attribute</h4>
<p>Starts with <code>0x40</code>. This attribute contains a GUID of a file.</p>
<p><img src="images/ntfs-attr-40.png" alt="img"></p>
<h4 id="bitmap-attribute">Bitmap attribute</h4>
<p>Starts with <code>0xE0</code>?<code>0xB0</code>?. â‰ï¸</p>
<p>Each MFT entry needs to be allocated and can get unallocated. When the MFT is allocated, it points to a cluster the file contents reside (if non-resident, of course). However, if the entry was unallocated (the file was deleted), the metadata may or may not be filled out. Keep in mind that in that case, the clusters that were used by that data could be reused.</p>
<blockquote>
<p>âœï¸ MFT records often come in bunches if created in close proximity to each other. This doesn&rsquo;t happen all the time, but it can sometimes be used to see if the timestomping took place. For example, the file claims to be created a month ago, but it has the same ids as files that were created yesterday. When executables were saved to disk and then run shortly afterwards, expect to see MFT records corresponding to exe itself and its respective prefetch files to have similar ID values.</p>
</blockquote>
<h3 id="logfile-and-usnjrnl"><code>$LogFile</code> And <code>$UsnJrnl</code></h3>
<p>Both are parts of the journaling (transactional logging) capability of the NTFS. <code>$LogFile</code> tracks file system changes, <code>$UsnJrnl</code> however, is different.</p>
<p><code>$LogFile</code> records data that needs to be inserted into <code>$MFT</code>, <code>$I30</code> Indexes, <code>$UsnJrnl</code> etc. One simple file creation event can spawn numerous logs in <code>$LogFile</code>. It&rsquo;s default size is 64MB (that&rsquo;s usually around 4 hours worth of events on an active system).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="err">ğŸ“˜</span> <span class="n">chkdsk</span> <span class="n">volume</span> <span class="p">/</span><span class="n">L</span> <span class="c"># get the current size</span>
</span></span><span class="line"><span class="cl"><span class="err">ğŸ“˜</span> <span class="n">chkdsk</span> <span class="n">volume</span> <span class="p">/</span><span class="n">L:size</span> <span class="c"># change the size</span>
</span></span></code></pre></div><blockquote>
<p>â—ï¸ So, if the file is resident, it gets recorded. If not - the file content will not be recorded. Only the data changed or inserted will be logged in the payload. When the file is not resident, data run clusters can be recorded, which can help retrieve deleted data if it is not overwritten.</p>
</blockquote>
<p>ğŸ¾ operation
ğŸ¾ f_name
ğŸ¾ current attribute
ğŸ¾ â° timestamps (when changed)
ğŸ¾ payload</p>
<blockquote>
<p>â—ï¸<code>$LogFile</code> does not include timestamps for each event! Log Sequence Number is used instead. Timestamps in the <code>$LogFile</code> are only recorded when changed in the <code>$MFT</code>. However, <code>$LogFile</code> logs changed made to <code>$UsnJrnl</code> which contains the timestamps of the change.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ğŸ“˜ LogFileParser /ReconstructDataruns <span class="c1"># to retrieve clusters for deleted files.</span>
</span></span></code></pre></div><p>Two tools can be used ğŸ› ï¸ <code>LogFileParser</code> (freeware) and ğŸ› ï¸ TZWork&rsquo;s <code>mala</code> (ğŸ’° commercial).</p>
<p>See <a href="https://dfir.ru/2019/02/16/how-the-logfile-works/">here</a> and <a href="http://forensicinsight.org/wp-content/uploads/2013/06/F-INSIGHT-NTFS-Log-TrackerEnglish.pdf">here</a> for more info about this artefact. When reviewing the $LogFile you can filter by parent directory to only include relevant events (for example, System32 folder or by extension). You can also sort or filter by Parent Entry Number if you know the folder used by the attacker. Use ğŸ› ï¸ <code>LogFileParser</code> to process the file and output LogFile.csv (summary file), where some entries point to corresponding supplementary files for more info (for example, <code>LogFile_INDX_I30.csv</code>). LogFileNames.csv will list all file names present in the <code>$LogFile</code>.</p>
<p><code>$UsnJrnl</code> provides a high-level summary of the changes made to files and directories. The logs usually contain a few days or several weeks&rsquo; worth of data. Each event type has a corresponding code. Backup and scanning software might use this file to check the latest changes to be updated with. There will be fewer events in this file, unlike <code>$LogFile</code>. It can, for example, track <code>FileCreate</code> events.</p>
<blockquote>
<p>â“Does ğŸ› ï¸ ProcessMonitor use this file to find <code>FileCreate</code> events?</p>
</blockquote>
<p>ğŸ¾ f_name
ğŸ¾ MFT number
ğŸ¾ parent dir&rsquo;s MFT number
ğŸ¾ â° timestamp of the change
ğŸ¾ reason code
ğŸ¾ file size
ğŸ¾ attributes (hidden, archived etc)</p>
<p>The data recorded is stored in the <code>$J</code> ADS of <code>$UsnJrnl</code>. <code>$J</code> is a very large sparse data stream (much of it are zeroes). It has a lot of unallocated data. Another ADS <code>$Max</code> (32 bytes) contains metadata about the <code>$UsnJrnl</code> itself. For USN reason codes, see <a href="https://learn.microsoft.com/en-us/windows/win32/api/winioctl/ns-winioctl-usn_record_v2">this</a> Microsoft documentation.</p>
<blockquote>
<p>â—ï¸Records are not numbered and tracked based on their offset within this file. Each file and directory in <code>$MFT</code> had an Update Sequence Number pointing to the specific offset within <code>$UsnJrnl</code>:<code>$J</code> file.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ğŸ“˜ fsutil usn queryJournal <span class="c1"># check the size of UsnJrnl</span>
</span></span><span class="line"><span class="cl">ğŸ“˜ mftecmd.exe -f F:<span class="se">\C\$</span>Extent<span class="se">\$</span>J --csv pathtooutput --csvf results.csv <span class="c1"># if this is a KAPE triage image was mounted as F drive, point to the $J file directly </span>
</span></span><span class="line"><span class="cl">ğŸ“˜ mftecmd.exe -f F:<span class="se">\C\$</span>Extent<span class="se">\$</span>UsrJrnl<span class="se">\$</span>J --csv pathtooutput --csvf results.csv <span class="c1"># IF the full disk image was mounted as F:, point it to the $J file. </span>
</span></span></code></pre></div><p>Another tool to parse <code>$UsnJrnl</code> is TZWork&rsquo;s ğŸ› ï¸ <code>jp</code>.</p>
<table>
<thead>
<tr>
<th>action</th>
<th>$LogFile</th>
<th>$UsnJrnl</th>
</tr>
</thead>
<tbody>
<tr>
<td>F/D created</td>
<td><code>AddIndexEntryAllocation</code>, <code>InitializeFileRecordSegment</code></td>
<td><code>FileCreate</code></td>
</tr>
<tr>
<td>F/D deleted</td>
<td><code>DeletelndexEntryAllocation</code>, <code>DeallocateFileRecordSegment</code></td>
<td><code>FileCreate</code></td>
</tr>
<tr>
<td>F/D renamed or moved</td>
<td><code>DeletelndexEntryAllocation</code>, <code>AddlndexEntryAllocation</code></td>
<td><code>RenameOldName</code> and <code>RenameNewName</code></td>
</tr>
<tr>
<td>ADS created</td>
<td><code>CreateAttribute</code> with a name ending in <code>: ADS</code></td>
<td><code>StreamChange</code> and <code>NamedDataExtend</code></td>
</tr>
<tr>
<td>File meta modified</td>
<td>* Op codes for $LogFile often are not sufficient to determine file modification</td>
<td><code>DataOverwrite</code></td>
</tr>
</tbody>
</table>
<h2 id="file-creation-and-deletion">File Creation and Deletion</h2>
<h3 id="creating-files">Creating Files</h3>
<p>Steps to create a file:</p>
<ul>
<li><input disabled="" type="checkbox"> A file record (<code>FILE</code>) is created in <code>$MFT</code></li>
<li><input disabled="" type="checkbox"> The bitmap for the $MFT is changed to indicate the record is allocatedâ“</li>
<li><input disabled="" type="checkbox"> The record header allocation flag shows it as an allocated file or directory</li>
<li><input disabled="" type="checkbox"> Attributes are written to the $MFT file record</li>
<li><input disabled="" type="checkbox"> If the data is non-resident, the $BitMap file is updated to represent the clusters allocated to store the data</li>
</ul>
<p>Go to &ldquo;Browse File Records&rdquo; on the top pane, choose the newly created file and see its attributes. The most important are sequence number and flags. I&rsquo;ve noticed that when I create and delete files several times, the MFT file record remains the same, the sequence number just gets incremented. That&rsquo;s because NTFS uses the first free record when the file is created. If you know at which sector a resident file was located before deletion, you can view its contents before it gets overwritten. The sector number is shown on the very rightmost bottom pane in Active@Disk Editor:</p>
<p><img src="images/ntfs-activediskedit-sector-createdfile.png" alt="img"></p>
<h3 id="deleting-files">Deleting Files</h3>
<p>Steps taken:</p>
<ul>
<li><input disabled="" type="checkbox"> In the <code>$MFT</code> the record header sequence number (see above) is incremented (allocation flag)</li>
<li><input disabled="" type="checkbox"> <code>$MFT</code> record is marked as available but not overwritten.</li>
<li><input disabled="" type="checkbox"> <code>$Bitmap</code> file marks clusters as free, but the data at those clusters is not yet touched. If the data is non-resident, the $BitMap file is updated to indicate the clusters are unallocated.</li>
<li><input disabled="" type="checkbox"> The parent directory marks this entry as available, possibly triggering rebalancing (may or may not overwrite the index entry).</li>
<li><input disabled="" type="checkbox"> <code>$LogFile</code> updated.</li>
<li><input disabled="" type="checkbox"> <code>$Secure</code>, <code>$ObjID</code> and <code>$Quota</code> are updated.</li>
<li><input disabled="" type="checkbox"> <code>$UsnJrnl</code> updated.</li>
</ul>
<blockquote>
<p>â—ï¸<code>$FILE_NAME</code> is not changed until the <code>$MFT</code> entry is reused.</p>
<p>â—ï¸<code>$I30</code> maybe preserved.</p>
</blockquote>
<h2 id="-timestamps">â° Timestamps</h2>
<p>ğŸ“† <code>Jan 1, 1601</code>. UTC?</p>
<p>Modified, Accessed, Created, MFT Modified.</p>
<p>Sources: <code>$Standart_Information</code>,  <code>$Filename</code> (if the file name is long enough, there will be two <code>$FILE_NAME</code> attributes, each with its own <code>MACB</code> timestamps set, <code>$I30_Index</code>.</p>
<p><strong>Modified</strong></p>
<p><strong>Created</strong></p>
<p><strong>Accessed</strong></p>
<p>Sometimes this option might be turned off. To check, check the <code>NTFSLastAccessUpdate</code> key at <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem</code> in Windows Registry.</p>
<p>Can be changed with <code>fsutils</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">fsutil behavior <span class="nb">set</span> disablelastaccess <span class="o">[</span>0<span class="p">|</span>1<span class="p">|</span>2<span class="p">|</span>3<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># restart the PC</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th><strong>Value</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>User Managed, Last Access Time Updates Enabled</td>
</tr>
<tr>
<td>â—ï¸<strong>1</strong></td>
<td>â—ï¸<strong>User Managed, Last Access Time Updates Disabled</strong></td>
</tr>
<tr>
<td><strong>2</strong> (default)</td>
<td>System Managed, Last Access Time Updates Enabled</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>System Managed, Last Access Time Updates Disabled</td>
</tr>
</tbody>
</table>
<p>Use the poster to help. It will show how different file system timestamps change depending on the activity performed with the file. There are 4 timestamps used on NTFS: <code>M</code> (modification ğŸ‰), <code>A</code> (access ğŸ), <code>C</code> (Metadata change ğŸ’) and <code>B</code> (file created/born ğŸŒ).</p>
<ol>
<li>File Renamed: <code>$Standard_Information</code> ğŸ’, <code>$Filename</code> - none</li>
<li>Local file move: <code>$Standard_Information</code> ğŸ’, <code>$Filename</code> - ğŸ‰ğŸ’</li>
<li>Volume file move: <code>$Standard_Information</code> ğŸğŸ’, <code>$Filename</code> - ğŸ‰ğŸğŸŒ ğŸ’</li>
<li>File copy: <code>$Standard_Information</code> ğŸğŸŒğŸ’ , <code>$Filename</code> - ğŸ‰ğŸğŸŒ ğŸ’</li>
<li>File Access: <code>$Standard_Information</code> ğŸ (old Win) , <code>$Filename</code> - none</li>
<li>File Modify: <code>$Standard_Information</code> ğŸ‰ ğŸ ğŸ’ , <code>$Filename</code> - ğŸ‰ ğŸ ğŸ’</li>
<li>File Creation: <code>$Standard_Information</code> ğŸ‰ğŸğŸŒ ğŸ’, <code>$Filename</code> - ğŸ‰ğŸğŸŒ ğŸ’</li>
<li>File Deletion: <code>$Standard_Information</code> none, <code>$Filename</code> - none</li>
</ol>
<blockquote>
<p>âœï¸ If you see that a file was created ğŸŒ AFTER it was modified ğŸ‰, it is indicative of a file copy, even when the file was copied from another system. It can sometimes highlight the lateral movement event.</p>
</blockquote>
<blockquote>
<p>â—ï¸Each file and directory will have <code>$STANDARD_INFORMATION</code> (4 timestamps) and at least one <code>$FILE_NAME</code> (another 4 timestamps). If the filename is long enough, the second $FILE_NAME attribute will have the additional 4 timestamps.</p>
</blockquote>
<h2 id="references">References</h2>
<p>[<a href="">1</a>] Windows OS file system for 27 years</p>
<p>[<a href="https://www.magnetforensics.com/resources/demystifying-mac-investigations-mac-vs-windows-artifacts-comparison/?submission=https://go.magnetforensics.com/l/52162/2020-08-25/kqxr57">2</a>] Demystifying Mac Investigations: Mac vs. Windows Artifacts Comparison, Magnet Webinar</p>
<p>NTFS file system, Suhanov&rsquo;s blog: [<a href="https://dfir.ru/2021/07/15/playing-with-case-insensitive-file-names/">1</a>] Playing with case-insensitive file names, [<a href="https://dfir.ru/2021/01/10/standard_information-vs-file_name/">2</a>] $STANDARD_INFORMATION vs. $FILE_NAME, [<a href="https://dfir.ru/2020/10/03/exporting-registry-hives-from-a-live-system/">3</a>] Exporting registry hives from a live system, [<a href="https://dfir.ru/2020/06/12/trim-and-unallocated-space/">4</a>] Trim and unallocated space, [<a href="https://dfir.ru/2020/05/23/onedrive-and-ntfs-last-access-timestamps/">5</a>] OneDrive and NTFS last access timestamps, [<a href="https://dfir.ru/2020/05/18/deceptive-ntfs-short-file-names/">6</a>] Deceptive NTFS short file names, [<a href="https://dfir.ru/2020/02/23/you-write-to-a-logical-drive-when-you-read-from-it/">7</a>] You write to a logical drive when you read from it, [<a href="https://dfir.ru/2019/04/23/ntfs-large-clusters/">8</a>] NTFS: large clusters, [<a href="https://dfir.ru/2019/02/28/ntfs-unallocated-data-marked-as-allocated/">9</a>] NTFS: unallocated data marked as allocated, [<a href="https://dfir.ru/2019/02/16/how-the-logfile-works/">10</a>] How the $LogFile works?, [<a href="https://dfir.ru/2019/01/19/ntfs-today/">11</a>] NTFS today, [<a href="https://dfir.ru/2019/01/08/hibernation-and-ntfs/">12</a>] Hibernation and NTFS, [<a href="https://dfir.ru/2018/12/16/the-inconsistency-of-last-access-timestamps/">13</a>] The (in)consistency of last access timestamps, [<a href="https://dfir.ru/2018/12/08/the-last-access-updates-are-almost-back/">14</a>] The â€œLast Accessâ€ updates are almost back.</p>
<p>[<a href="http://blog.opensecurityresearch.com/2011/10/how-to-acquire-locked-files-from.html">3</a>] How to acquire &ldquo;locked&rdquo; files from a running Windows system, By PÃ¤r Ã–sterberg Medina</p>
<p>[<a href="https://stackoverflow.com/questions/19499257/opening-mft-file-causes-access-denied-even-if-run-as-administrator">4</a>] Opening $MFT file causes Access denied even if run as administrator, StackOverflow, answered by <a href="https://stackoverflow.com/users/175201/eric-brown">Eric Brown</a></p>
<p>[<a href="https://www.coursera.org/learn/windows-os-forensics/home/welcome">5</a>] Digital Forensics Specialization, Windows OS Forensics course, InfoSec Institute, Coursera</p>
<p>[<a href="https://flatcap.org/linux-ntfs/ntfs/files/index.html">6</a>] NTFS Documentation</p>
<p>[<a href="http://www.cs.fsu.edu/~cop4610t/lectures/project3/Week11/Slides_week11.pdf">7</a>] About FAT32</p>

  </div>
</article>
</div>
</div>

        </div>
      </div>
    </div>
    
  </div>

  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            <li class="zerostatic"><a href="https://www.zerostatic.io">www.zerostatic.io</a></li>
            </ul>
        </div>
      </div>
    </div>
  </div>
</div>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.302a6fc365d5139fb98cf60bdb8f715d96257ea189161d36c190ccfa8182e569.js"></script>
  

  
  
  
    
  


</body>

</html>
