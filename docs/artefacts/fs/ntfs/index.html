<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>NTFS - Analyst</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://bakerst221b.com/favicon.png">
  <link href="/css/style-classic.css"></link>
  
  
  <link rel="stylesheet" href="/css/style.min.564b5f4faf3af87992cb8ab298314448914c22dbdb3f2f9c584546b21b8d407c.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home 🏡">
      <a href="/">
        <span>Home 🏡</span>
      </a>
    </li>
    
    <li class="menu-item-blog ✍️">
      <a href="/docs/blog">
        <span>Blog ✍️</span>
      </a>
    </li>
    
    <li class="menu-item-ttp 🔍">
      <a href="/docs/ttp">
        <span>TTP 🔍</span>
      </a>
    </li>
    
    <li class="menu-item-artefacts db 🏺">
      <a href="/docs/artefacts">
        <span>Artefacts DB 🏺</span>
      </a>
    </li>
    
    <li class="menu-item-attacks db ⚔️">
      <a href="/docs/attacks">
        <span>Attacks DB ⚔️</span>
      </a>
    </li>
    
    <li class="menu-item-tools db 🛠️">
      <a href="/docs/tools">
        <span>Tools DB 🛠️</span>
      </a>
    </li>
    
    <li class="menu-item-crypto 🗝️">
      <a href="/docs/cryptography">
        <span>Crypto 🗝️</span>
      </a>
    </li>
    
    <li class="menu-item-about me 🧝🏽‍♀️">
      <a href="/docs/about">
        <span>About me 🧝🏽‍♀️</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo.png" /></a>
    </div>
    <div class="logo-mobile">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo-mobile.svg" /></a>
    </div>
    

    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home 🏡">
      <a href="/">
        <span>Home 🏡</span>
      </a>
    </li>
    
    <li class="menu-item-blog ✍️">
      <a href="/docs/blog">
        <span>Blog ✍️</span>
      </a>
    </li>
    
    <li class="menu-item-ttp 🔍">
      <a href="/docs/ttp">
        <span>TTP 🔍</span>
      </a>
    </li>
    
    <li class="menu-item-artefacts db 🏺">
      <a href="/docs/artefacts">
        <span>Artefacts DB 🏺</span>
      </a>
    </li>
    
    <li class="menu-item-attacks db ⚔️">
      <a href="/docs/attacks">
        <span>Attacks DB ⚔️</span>
      </a>
    </li>
    
    <li class="menu-item-tools db 🛠️">
      <a href="/docs/tools">
        <span>Tools DB 🛠️</span>
      </a>
    </li>
    
    <li class="menu-item-crypto 🗝️">
      <a href="/docs/cryptography">
        <span>Crypto 🗝️</span>
      </a>
    </li>
    
    <li class="menu-item-about me 🧝🏽‍♀️">
      <a href="/docs/about">
        <span>About me 🧝🏽‍♀️</span>
      </a>
    </li>
    
  </ul>
</div>
    
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
    
    <div style="margin-left: 20pt;">
      <a href="/index.xml" type="application/rss+xml">
        <img src="/images/rss.png" alt="RSS Feed">
      </a>
    </div>
    
    <style>
      a[href="/index.xml"] {
        display: inline-block;
        vertical-align: middle;
        margin-right: 10px;
      }
    
      a[href="/index.xml"] img {
        height: 30px;
      }
    </style>
    
  </div>
</div>


    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <p>
   <a href="/docs/artefacts/fs/"> 👈🏼 Back to </br> File Systems </a>
  </p>
  <aside>
   <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#versions">Versions</a>
          <ul>
            <li><a href="#v10">V1.0</a></li>
            <li><a href="#v12">V1.2</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#features">Features</a></li>
    <li><a href="#-anatomy">💀 Anatomy</a>
      <ul>
        <li><a href="#volume-boot-record">Volume Boot Record</a></li>
        <li><a href="#mft">MFT</a></li>
      </ul>
    </li>
    <li><a href="#file-creation-and-deletion">File Creation and Deletion</a>
      <ul>
        <li><a href="#creating-files">Creating Files</a></li>
        <li><a href="#deleting-files">Deleting Files</a></li>
      </ul>
    </li>
    <li><a href="#-timestamps">⏰ Timestamps</a></li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
 </aside>
</div>



          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">NTFS</h1>
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    <div class="meta">
      
      
      <div class="article-category">
          
            
              <i class="fab fa-windows"></i>          
            
            
            
            
            
            
          
          
      </div> <br />
      

      
      <div class="article-category">
        <i class="fas fa-tools"></i>
          
          
          <a class="platform-link" href="/tools/active-killdisk">Active@ KillDisk</a> 
          
      </div> <br />
      
      

      
    </div>
    
    <b>Created:</b> 18.10.2020
    <br />

    

  </header>


  <div class="content" itemprop="articleBody">
    <p>Developed in collaboration with IBM. POSIX compliant. Official docs for NTFS <a href="http://ntfs.com/ntfs-mft.htm">here</a>.</p>
<blockquote>
<p>⚠️ Everything is a file!</p>
<p>⚠️ All offsets are relative to the start of the data structures.</p>
<p>⚠️ Apple macOS machines can read NTFS devices, but do not support writing to them by default.</p>
</blockquote>
<p>Entire logical volume is a data erea (in contrast to FAT where there is a system area as well ❓).</p>
<p>In a Microsoft NT File System (NTFS), hot fixing of disk sectors <strong>prevents data from being stored in a bad sector or cluster</strong>.</p>
<p>The NTFS (New Technology File System) file system provides file-level security:</p>
<ol>
<li>NTFS permissions allow you to set specific access rights for individual users or groups on a file or folder. These permissions include read, write, execute, and delete access and more advanced permissions like modify, full control, and take ownership.</li>
<li>You can also set permissions to allow or deny access to specific types of users or groups, such as administrators, authenticated users, or specific user accounts.</li>
<li>NTFS uses ACLs to define more complex access control policies. ACLs allow you to define sets of permissions for multiple users or groups, and can be used to define more fine-grained access control policies. For example, you can create an ACL that allows members of a certain group to read and modify files in a particular folder, but denies access to other users.</li>
<li>NTFS also provides other security features, such as file and folder encryption using BitLocker, and auditing to track access and modifications to files and folders. Overall, NTFS is a robust file system that provides a wide range of security features to help you protect your files and data.</li>
</ol>
<h3 id="versions">Versions</h3>
<h4 id="v10">V1.0</h4>
<p>The first release of Windows NT 3.1. Windows XP and above. It allowed for data recovery, rollback (restore the system to the last stable state) and larger volumes. Windows 8 + faster data recovery and cross platform. Windows 10 + extended logging features.</p>
<blockquote>
<p>⚠️ Windows Vista and above can obly be installed on a NTFS volume!</p>
</blockquote>
<h4 id="v12">V1.2</h4>
<p>Windows NT 3.51, included admin controls, compressed files and User Access Control (recycle bin for each user and own account).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="se">\$</span>Recycle.Bin<span class="se">\ </span><span class="o">(</span><span class="nv">$R</span><span class="p">&amp;</span><span class="nv">$I</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="se">\R</span>ECYCLER
</span></span></code></pre></div><h2 id="features">Features</h2>
<p>🪶 Journaling, aka transaction logging. Records change to the metadata of FS.
🪶 ACL
🪶 Compression
🪶 Change tracking
🪶 Disk usage quotas. So that one user won&rsquo;t eat up the entire volume.
🪶 VSC
🪶 Hard and Soft links (required to be POSIX compliant). One file has several names - hard links. Several pointers to the same file - soft links.
🪶 Reparse points. Different file usage types.
🪶 ADS
🪶 Distributed link tracking. Some files have an object ID to track them across the system (when the file was renamed, how many times, where it was moved, etc).
🪶 Volume mount points
🪶 Sparse file support
🪶 Encryption
🪶 Single instance storage. Similar to soft links. How is it different?</p>
<h2 id="-anatomy">💀 Anatomy</h2>
<h3 id="volume-boot-record">Volume Boot Record</h3>
<p>In the <code>$MFT</code> is represented as <code>$Boot</code>. It&rsquo;s located at the sector <code>0</code> of the volume (not physical disk!). Below is the VBR structure for NTFS. The most important entries for forensic purposes are highlighted.</p>
<p><img src="images/ntfs-boot-record-struct.png" alt="img"></p>
<h3 id="mft">MFT</h3>
<p>The heart ♥️ of NTFS. Created once the disk/volume is formatted with NTFS. It&rsquo;s an index of every single file on disk (at least 1 entry of a file), including  NTFS metadata files (those that start with <code>$</code>). The first 26 records are for the system metadata files. Records 12-23 are reserved. Records 24-26 transaction log and error recovery. The first user-created file is usually at index 35.</p>
<p>Below is the full table of the files [<a href="https://flatcap.org/linux-ntfs/ntfs/files/index.html">6</a>].</p>
<table>
<thead>
<tr>
<th style="text-align:right">Inode</th>
<th style="text-align:left">Filename</th>
<th style="text-align:left">OS</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/mft.html">$MFT</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Master File Table - An index of every file. It describes the MFT itself.</td>
</tr>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/mftmirr.html">$MFTMirr</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">A <strong>backup copy</strong> of the first 4 records of the MFT that is required in case MFT gets damaged.</td>
</tr>
<tr>
<td style="text-align:right">2</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/logfile.html">$LogFile</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Transactional logging file</td>
</tr>
<tr>
<td style="text-align:right">3</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/volume.html">$Volume</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Serial number, creation time, dirty flag</td>
</tr>
<tr>
<td style="text-align:right">4</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/attrdef.html">$AttrDef</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Attribute definitions.</td>
</tr>
<tr>
<td style="text-align:right">5</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/dot.html">. (dot)</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Root directory of the disk</td>
</tr>
<tr>
<td style="text-align:right">6</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/bitmap.html">$Bitmap</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Contains volume&rsquo;s cluster map (in-use vs. free), used to identify open clusters. See more <a href="https://whereismydata.wordpress.com/2009/06/01/forensics-what-is-the-bitmap/">here</a></td>
</tr>
<tr>
<td style="text-align:right">7</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/boot.html">$Boot</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Boot record of the volume</td>
</tr>
<tr>
<td style="text-align:right">8</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/badclus.html">$BadClus</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Lists bad clusters on the volume</td>
</tr>
<tr>
<td style="text-align:right">9</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/quota.html">$Quota</a></td>
<td style="text-align:left">NT</td>
<td style="text-align:left">Quota information</td>
</tr>
<tr>
<td style="text-align:right">9</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/secure.html">$Secure</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Security descriptors used by the volume</td>
</tr>
<tr>
<td style="text-align:right">10</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/upcase.html">$UpCase</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Table of uppercase characters used for collating</td>
</tr>
<tr>
<td style="text-align:right">11</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/extend.html">$Extend</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">A directory: $ObjId, $Quota, $Reparse, $UsnJrnl</td>
</tr>
<tr>
<td style="text-align:right">12-15</td>
<td style="text-align:left">Unused</td>
<td style="text-align:left"></td>
<td style="text-align:left">Marked as in use but empty</td>
</tr>
<tr>
<td style="text-align:right">16-23</td>
<td style="text-align:left">Unused</td>
<td style="text-align:left"></td>
<td style="text-align:left">Marked as unused</td>
</tr>
<tr>
<td style="text-align:right">Any (25)</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/objid.html">$ObjId</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Unique Ids given to every file</td>
</tr>
<tr>
<td style="text-align:right">Any (24)</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/quota.html">$Quota</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Quota information</td>
</tr>
<tr>
<td style="text-align:right">Any (26)</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/reparse.html">$Reparse</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Reparse point information</td>
</tr>
<tr>
<td style="text-align:right">Any</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/usnjrnl.html">$UsnJrnl</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Journalling of Encryption (usually at <code>/$Extend</code> directory, see above). Known as a Change Journal.</td>
</tr>
</tbody>
</table>
<p>These files cannot be opened from the user space, it&rsquo;s maintained by NTFS driver. So, even if shown by Directory Snoop, you can&rsquo;t open it on a live system. You can view the hex data though in DS-NTFS. Another option would be to make a disk image and carve the files. View some more information here [<a href="http://blog.opensecurityresearch.com/2011/10/how-to-acquire-locked-files-from.html">3</a>].</p>
<p><strong><code>\$Extend\$UsnJrnl</code></strong>. Journal change log for NTFS system. EVERYTHING! File and directory deletion, creation, and encryption.</p>
<p><strong><code>$LogFile</code></strong>. It&rsquo;s a transaction journal of $MFT. Very similar to <code>$UsnJrnl</code>, but lives less. Tracks file creation, modification, renaming and deletion. May not exist, but since Windows Vista <code>$UsnJrnl</code> is there <strong>by default</strong>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">📘 istat <span class="o">[</span>options<span class="o">]</span> image inode -z timezone <span class="c1"># parses the information in the MFT entries. </span>
</span></span></code></pre></div><p>A MFT record contains the following info and is usually 1024 bytes long:</p>
<ul>
<li>file allocation status</li>
<li>file dates</li>
<li>file name</li>
<li>location</li>
</ul>
<p>Every object gets an entry with attributes to describe it.</p>
<p><img src="images/ntfs-attr-overview.png" alt="img"></p>
<table>
<thead>
<tr>
<th>🗒️ FILES</th>
<th>📂 DIRECTORIES</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x10</code> <code>$STANDARD_INFORMATION</code></td>
<td><code>0x10</code> <code>$STANDARD_INFORMATION</code></td>
</tr>
<tr>
<td><code>0x30</code> <code>$FILE_NAME</code> (long)</td>
<td><code>0x30</code> <code>$FILE_NAME</code> (long)</td>
</tr>
<tr>
<td><code>0x30</code> <code>$FILE_NAME</code> (short, sometimes)</td>
<td><code>0x30</code> <code>$FILE_NAME</code> (short, sometimes)</td>
</tr>
<tr>
<td><strong><code>0x80</code> <code>$DATA</code></strong></td>
<td><strong><code>0x90</code> <code>$INDEX_ROOT</code></strong></td>
</tr>
<tr>
<td><strong><code>0x80</code> <code>$DATA</code> (ADS, sometimes)</strong></td>
<td><strong><code>0xA0</code> <code>$INDEX_ALLOCATION</code> (sometimes)</strong></td>
</tr>
</tbody>
</table>
<p>Volume <strong>name</strong> also gets an entry (always <code>#3</code> for the <code>$VOLUME</code> system file).</p>
<p>Records start at index <code>0</code> (for the MFT record itself) and are numbered sequentially. Each record is usually 1024 bytes. New records are created on a first-available basis, i.e. if a record was deleted (deallocated), it gets overwritten once a new one is created, and the deallocated one is the first free index in the table.</p>
<p>A file record begins with a header (ASCII <code>FILE</code> or <code>BAAD</code> if corrupted). It contains info about the file. It&rsquo;s made up of attributes. Each of them contains specific information about the file record entry. Each record ends with a <code>0xFF FF FF FF</code>. It has a sequence number at offset <code>0x10</code> 2 bytes long, incremented each time the file is deleted (not allocated ❗️). At offset <code>0x16</code> there is an allocation status flags: <code>0x00</code> for deleted file, <code>0x01</code> for allocated one, <code>0x02</code> for deleted dir, <code>0x03</code> for allocated dir.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># if you have an MFT record number, you can pass to istat</span>
</span></span><span class="line"><span class="cl">📘 istat imagefile MFT_record_number
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># output:</span>
</span></span><span class="line"><span class="cl">&gt; allocation status
</span></span><span class="line"><span class="cl">&gt; MFT entry number 
</span></span><span class="line"><span class="cl">&gt; <span class="nv">$LogFile</span> sequence number
</span></span><span class="line"><span class="cl">&gt; <span class="nv">$Standard_Information</span> attribute <span class="o">(</span>flags, security info, <span class="nv">$UsnJrnl</span> number, MACB timestamps<span class="o">)</span>
</span></span></code></pre></div><p>At the offset 0x10 you can see aa sequence number that gets incremented when the file is deleted. When the MFT entry was created for the first time, the value is set to <code>1</code>. When the file is deleted, the value is incremented by <code>1</code>. Then, when this entry is reused, the sequence number remains the same and only gets incremented when the file is deleted, and the entry gets unallocated again.</p>
<p>Hard Link count at offset <code>0x12</code> specified how many <code>$FILE_NAME</code> attributes this file has. This includes both long and short names as well as real hard links.</p>
<p>At offset 0x16 we can see a flag which can have either of the following values:</p>
<p>🇬🇧 <code>0x00</code> <code>0000</code> Not in use</p>
<p>🇬🇧 <code>0x01</code> <code>0001</code> file in use</p>
<p>🇬🇧 <code>0x02</code> <code>0010</code> dir deleted</p>
<p>🇬🇧 <code>0x03</code> <code>0011</code> dir in use</p>
<p>When the file is deleted, the flag is set to <code>0x0</code>, but the rest of the MFT entry remains intact until it&rsquo;s reused by another file.</p>
<p>Data at <code>0x18</code> and <code>0x1C</code> show the real and allocated (including slack) space for this FILE record. At <code>0x20</code> we can see the File Reference to Base Record which can be something other than 0 sometimes when there are too many attributes for the given file to fit in 1024 bytes.</p>
<p>At the offset <code>0x28</code> we will see the Next available attribute ID. Each will have a unique ID that starts at 0.</p>
<p>At the offset <code>0x2C</code> we have the inode (MFT entry ID) number. This data was added to the newer NTFS versions, changing the length of the data. So, the pointer to the fix-up array at the beginning (offset <code>0x4</code>) used to be <code>0x2A</code> (<code>*</code> in ASCII) on older versions is now <code>0x30</code> (<code>0</code> in ASCII). Keep that in mind when carving for <code>FILE</code> records.</p>
<p>Finally, we have fix-up information at the <code>0x30</code> offset. <a href="https://dtidatarecovery.com/ntfs-master-file-table-fixup/">Here</a> is how the fix-up works:</p>
<ol>
<li>Read the records two sectors from the MFT.</li>
<li>Read the two byte offset of the Update Sequence Array located right after the four byte record magic value</li>
<li>Compare the first number in the array to the number at offset 510 in sector 1</li>
<li>If the values do not match indicate and error. This is when ‘chkdsk’ could be run</li>
<li>Repeat steps 3 and 4 for sector 2</li>
<li>Take the next value in the Update Sequence Array and write it at offset 510 in sector 1</li>
<li>Repeat step 6 for sector 2</li>
</ol>
<p>Following the header, there are four attributes (each consists of a header and contents):</p>
<p><strong>Standard attribute</strong>. Starts with <code>0x10</code>. Standard attribute (file permissions, ⏰ timestamps, security and admin info). Below is the attribute highlighted. Note, that there are very useful timestamps at <code>0x18</code>: file created/modified, record changed and last access time. ❗️ All UTC.</p>
<p><img src="images/ntfs-attr-10.png" alt="img"></p>
<p>At offset <code>0x38</code> we have flags, showing the file attributes. Possible values are:</p>
<p>🇬🇧 <code>10 00 00 00</code> Directory</p>
<p>🇬🇧 <code>20 00 00 00</code> Archive</p>
<p>🇬🇧 <code>40 00 00 00</code> Device</p>
<p>🇬🇧 <code>30 00 00 00</code> Normal</p>
<p>🇬🇧 <code>01 00 00 00</code> Read Only</p>
<p>🇬🇧 <code>02 00 00 00</code> Hidden</p>
<p>🇬🇧 <code>04 00 00 00</code> System</p>
<p>🇬🇧 <code>00 10 00 00</code> Offline</p>
<p>🇬🇧 <code>00 20 00 00</code> Not Indexed</p>
<p>🇬🇧 <code>00 40 00 00</code> Encrypted</p>
<p>🇬🇧 <code>00 0100 00</code> Temporary</p>
<p>🇬🇧 <code>00 02 00 00</code> Sparse File</p>
<p>🇬🇧 <code>00 04 00 00</code> Reparse Point</p>
<p>🇬🇧 <code>00 08 00 00</code> Compressed</p>
<p>Note that each flag has only one specific bit at a fixed offset set. When there are multiple flags for one file, their values are combined. For example, to calculate the final flag value for a file which is an archive (🇬🇧 <code>20 00 00 00</code>) and is both a hidden (🇬🇧 <code>02 00 00 00</code>) and a system file (🇬🇧 <code>04 00 00 00</code>) we would have <code>20</code> as the first byte and <code>0x02</code> + <code>0x04</code> <code>as</code> the second, resulting in the flag value being set to <code>0x26</code>. If this file were also encrypted, we would have <code>0x2640</code>.</p>
<p><strong>File name</strong>. Starts with <code>0x30</code>. It also has ⏰ timestamps, but for the <strong>filename</strong>. The first 6 bytes are for the parent directory&rsquo;s MFT record (it&rsquo;s not a cluster number like in FAT). The timestamps below are for the filename changes, not the changes for the file itself. For the file timestamps, see the attribute <code>0x10</code> (above). If the file is resident, its contents will be contained in the MFT. If the file is too big, there will be a <code>data run</code> instead (❓).</p>
<p><img src="images/ntfs-attr-30.png" alt="img"></p>
<p>Contains 🐾 objects name, 🐾 parent folder and ⏰ filename timestamps which are not natively shown by Windows. It also includes 🐾 file properties like if it&rsquo;s an archive or a hidden file.</p>
<p>At the offset <code>0x18</code> we have the parent directory reference specified. The first 6 bytes are the MFT entry number of the directory, and the remaining 2 represent the sequence number for this MFT record.</p>
<p>Another set of ⏰ timestamps begins at the offset <code>0x20</code>.</p>
<p>The flags at the offset <code>0x50</code> are the same as in <code>$STANDARD_INFORMATION</code>.</p>
<p>At the offset <code>0x58</code> we have the number of Unicode characters that the filename consists of. Since Unicode characters are two bytes long, we need to double this number to get the exact number of bytes to read. Since this value is only one byte long, the max value it can have is <code>0xFF</code> which is <code>255</code> in decimal. That&rsquo;s why you can&rsquo;t have a filename longer than <code>255</code> characters. And then, at the offset <code>0x59</code> we have a namespace type which can be either of the following: <code>0x00</code> for POSIX (different case - different name), <code>0x01</code> for Win32 (case-sensitive long name), <code>0x02</code> for DOS (DOS-compatible short name) and <code>0x03</code> for Win32/DOS (the name is short enough to only have one <code>$FILE_NAME</code>, DOS-compatible). If the file name is long enough, the second <code>$FILE_NAME</code> attribute is created which preserves the case.</p>
<p><strong>Data attribute</strong>. ⚠️ Yes, data is considered an attribute in NTFS. Starts with <code>0x80</code>.  Contains data itself or the pointer to its location (depending on the file size). If the file is small enough, its contents will be here (below, green area). In this case the file is called <em>resident</em> file. Whether it&rsquo;s a resident file or not, you can determine by the <em>non-resident</em> byte (marked with a red rectangle in the picture below). In the picture below it&rsquo;s <code>0x00</code>, which means the file <em>is</em> resident and its contents is in the MFT record (right below). Marked with a green rectangle it&rsquo;s the offset to the data, for resident files it&rsquo;s always <code>0x0018</code> (little-endian), since the start of the data section is in the attribute itself at the fixed place.</p>
<p><img src="images/ntfs-attr-80.png" alt="img"></p>
<p>In the picture below there is an example of a record for a bigger file. Its non-resident flag is set to <code>0x01</code> (marked with a purple rectangle), meaning the contents is somewhere else on disk. In order to find the file contents location we need to perform the following steps:</p>
<ul>
<li><input disabled="" type="checkbox"> get the offset to data runs, which contain directions to the contents location (pointer). In the picture below it&rsquo;s <code>0x0040</code> (little-endian). This offset is relative to the attribute start. So, we count <code>0x40</code> from the attribute start and get to the location marked with a dark-red rectangle: <code>21 10 89 09 00 00 00 00</code> (run list).</li>
<li><input disabled="" type="checkbox"> read the run list.</li>
</ul>
<p><img src="images/ntfs-nonresident-set.png" alt="img"></p>
<p>Now, what&rsquo;s a run list?</p>
<p><img src="images/ntfs-big-nonresident-run-list.png" alt="img"></p>
<p>In the picture below this structure is highlighted on the left and expalined on the right. The first byte is the run header, it tells the number of bytes, occupied by the run list. The second byte tells the length in clusters. The next two bytes are for the starting cluster number (<strong>signed</strong> 16-bit value). End the remaining 4 bytes of zeroes - end of run.</p>
<blockquote>
<p>⚠️ To interpret the run header, split the byte into two nibbles and add them together: <code>2</code> + <code>1</code> = <code>3</code>, meaning, in the example above the run list length is 3 bytes. The first nibble (<code>2</code>  in this example) tells that the size of the first cluster field is 2 bytes. The second nibble tells that the size of the cluster count field of 1 byte (<code>1</code>). Together combined it&rsquo;s 3. meaning that both cluster count and first cluster fields are 3 bytes long.</p>
</blockquote>
<p>If the file is fragmented, there will be more than 1 data run. If there are more than 1 data run, then each next first cluster field is relative to the previous one. For example, if the first cluster for the first fragment in the first data run was <code>0x42A9</code> (17065 in decimal), and the next first cluster for the next fragment in the next data run is <code>0xBFBF</code> (-16449 decimal) then in order to get the first cluster for the second fragment, we would substitute 16449 from 17065 which would give us 616 decimal value, which would be the first cluster of the second fragment [<a href="https://www.coursera.org/learn/windows-os-forensics/home/welcome">5</a>]. So, each value is relevant to the last piece. To get the first cluster of the next fragment you&rsquo;d add it&rsquo;s value to 616 and so on and so forth. Active@Disk Editor does that automatically.</p>
<p><strong>Object ID attribute</strong>. Starts with <code>0x40</code>. This attribute contains a GUID of a file.</p>
<p><img src="images/ntfs-attr-40.png" alt="img"></p>
<p><strong>Bitmap attribute</strong>. Starts with <code>0xE0</code>?<code>0xB0</code>?. ⁉️</p>
<p>Each MFT entry needs to be allocated and can get unallocated. When the MFT is allocated, it points to a cluster the file contents reside (if non-resident, of course). However, if the entry was unallocated (the file was deleted), the metadata may or may not be filled out. Keep in mind that in that case, the clusters that were used by that data could be reused.</p>
<blockquote>
<p>✍️ MFT records often come in bunches if created in close proximity to each other. This doesn&rsquo;t happen all the time, but it can sometimes be used to see if the timestomping took place. For example, the file claims to be created a month ago, but it has the same ids as files that were created yesterday. When executables were saved to disk and then run shortly afterwards, expect to see MFT records corresponding to exe itself and its respective prefetch files to have similar ID values.</p>
</blockquote>
<h2 id="file-creation-and-deletion">File Creation and Deletion</h2>
<h3 id="creating-files">Creating Files</h3>
<p>Steps to create a file:</p>
<ul>
<li><input disabled="" type="checkbox"> A file record (<code>FILE</code>) is created in <code>$MFT</code></li>
<li><input disabled="" type="checkbox"> The bitmap for the $MFT is changed to indicate the record is allocated❓</li>
<li><input disabled="" type="checkbox"> The record header allocation flag shows it as an allocated file or directory</li>
<li><input disabled="" type="checkbox"> Attributes are written to the $MFT file record</li>
<li><input disabled="" type="checkbox"> If the data is non-resident, the $BitMap file is updated to represent the clusters allocated to store the data</li>
</ul>
<p>Go to &ldquo;Browse File Records&rdquo; on the top pane, choose the newly created file and see its attributes. The most important are sequence number and flags. I&rsquo;ve noticed that when I create and delete files several times, the MFT file record remains the same, the sequence number just gets incremented. That&rsquo;s because NTFS uses the first free record when the file is created. If you know at which sector a resident file was located before deletion, you can view its contents before it gets overwritten. The sector number is shown on the very rightmost bottom pane in Active@Disk Editor:</p>
<p><img src="images/ntfs-activediskedit-sector-createdfile.png" alt="img"></p>
<h3 id="deleting-files">Deleting Files</h3>
<p>Steps taken:</p>
<ul>
<li><input disabled="" type="checkbox"> The record header sequence number (see above) is incremented</li>
<li><input disabled="" type="checkbox"> The record header allocation flag indicates a deleted file or dir</li>
<li><input disabled="" type="checkbox"> The bitmap for the MFT is changed to show this file/dir is unallocated</li>
<li><input disabled="" type="checkbox"> If the data is non-resident, the $BitMap file is updated to indicate the clusters are unallocated</li>
</ul>
<h2 id="-timestamps">⏰ Timestamps</h2>
<p>📆 <code>Jan 1, 1601</code>. UTC?</p>
<p>Modified, Accessed, Created, MFT Modified.</p>
<p>Sources: <code>$Standart_Information</code>,  <code>$Filename</code> (if the file name is long enough, there will be two <code>$FILE_NAME</code> attributes, each with its own <code>MACB</code> timestamps set, <code>$I30_Index</code>.</p>
<p><strong>Modified</strong></p>
<p><strong>Created</strong></p>
<p><strong>Accessed</strong></p>
<p>Sometimes this option might be turned off. To check, check the <code>NTFSLastAccessUpdate</code> key at <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem</code> in Windows Registry.</p>
<p>Can be changed with <code>fsutils</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">fsutil behavior <span class="nb">set</span> disablelastaccess <span class="o">[</span>0<span class="p">|</span>1<span class="p">|</span>2<span class="p">|</span>3<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># restart the PC</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th><strong>Value</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>User Managed, Last Access Time Updates Enabled</td>
</tr>
<tr>
<td>❗️<strong>1</strong></td>
<td>❗️<strong>User Managed, Last Access Time Updates Disabled</strong></td>
</tr>
<tr>
<td><strong>2</strong> (default)</td>
<td>System Managed, Last Access Time Updates Enabled</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>System Managed, Last Access Time Updates Disabled</td>
</tr>
</tbody>
</table>
<h2 id="references">References</h2>
<p>[<a href="">1</a>] Windows OS file system for 27 years</p>
<p>[<a href="https://www.magnetforensics.com/resources/demystifying-mac-investigations-mac-vs-windows-artifacts-comparison/?submission=https://go.magnetforensics.com/l/52162/2020-08-25/kqxr57">2</a>] Demystifying Mac Investigations: Mac vs. Windows Artifacts Comparison, Magnet Webinar</p>
<p>NTFS file system, Suhanov&rsquo;s blog: [<a href="https://dfir.ru/2021/07/15/playing-with-case-insensitive-file-names/">1</a>] Playing with case-insensitive file names, [<a href="https://dfir.ru/2021/01/10/standard_information-vs-file_name/">2</a>] $STANDARD_INFORMATION vs. $FILE_NAME, [<a href="https://dfir.ru/2020/10/03/exporting-registry-hives-from-a-live-system/">3</a>] Exporting registry hives from a live system, [<a href="https://dfir.ru/2020/06/12/trim-and-unallocated-space/">4</a>] Trim and unallocated space, [<a href="https://dfir.ru/2020/05/23/onedrive-and-ntfs-last-access-timestamps/">5</a>] OneDrive and NTFS last access timestamps, [<a href="https://dfir.ru/2020/05/18/deceptive-ntfs-short-file-names/">6</a>] Deceptive NTFS short file names, [<a href="https://dfir.ru/2020/02/23/you-write-to-a-logical-drive-when-you-read-from-it/">7</a>] You write to a logical drive when you read from it, [<a href="https://dfir.ru/2019/04/23/ntfs-large-clusters/">8</a>] NTFS: large clusters, [<a href="https://dfir.ru/2019/02/28/ntfs-unallocated-data-marked-as-allocated/">9</a>] NTFS: unallocated data marked as allocated, [<a href="https://dfir.ru/2019/02/16/how-the-logfile-works/">10</a>] How the $LogFile works?, [<a href="https://dfir.ru/2019/01/19/ntfs-today/">11</a>] NTFS today, [<a href="https://dfir.ru/2019/01/08/hibernation-and-ntfs/">12</a>] Hibernation and NTFS, [<a href="https://dfir.ru/2018/12/16/the-inconsistency-of-last-access-timestamps/">13</a>] The (in)consistency of last access timestamps, [<a href="https://dfir.ru/2018/12/08/the-last-access-updates-are-almost-back/">14</a>] The “Last Access” updates are almost back.</p>
<p>[<a href="http://blog.opensecurityresearch.com/2011/10/how-to-acquire-locked-files-from.html">3</a>] How to acquire &ldquo;locked&rdquo; files from a running Windows system, By Pär Österberg Medina</p>
<p>[<a href="https://stackoverflow.com/questions/19499257/opening-mft-file-causes-access-denied-even-if-run-as-administrator">4</a>] Opening $MFT file causes Access denied even if run as administrator, StackOverflow, answered by <a href="https://stackoverflow.com/users/175201/eric-brown">Eric Brown</a></p>
<p>[<a href="https://www.coursera.org/learn/windows-os-forensics/home/welcome">5</a>] Digital Forensics Specialization, Windows OS Forensics course, InfoSec Institute, Coursera</p>
<p>[<a href="https://flatcap.org/linux-ntfs/ntfs/files/index.html">6</a>] NTFS Documentation</p>
<p>[<a href="http://www.cs.fsu.edu/~cop4610t/lectures/project3/Week11/Slides_week11.pdf">7</a>] About FAT32</p>

  </div>
</article>
</div>
</div>

        </div>
      </div>
    </div>
    
  </div>

  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            <li class="zerostatic"><a href="https://www.zerostatic.io">www.zerostatic.io</a></li>
            </ul>
        </div>
      </div>
    </div>
  </div>
</div>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.302a6fc365d5139fb98cf60bdb8f715d96257ea189161d36c190ccfa8182e569.js"></script>
  

  
  
  
    
  


</body>

</html>
