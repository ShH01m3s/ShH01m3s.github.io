<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Algorithms - Graphs - Observer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://bakerst221b.com/favicon.png">

  
  
  <link rel="stylesheet" href="/css/style.min.aad43d4ecb69a264f2539b89d7f779d5f3cdff22e7585fe5fc3c77272f1c2696.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-docs">
      <a href="/docs/">
        <span>Docs</span>
      </a>
    </li>
    
    <li class="menu-item-articles">
      <a href="/docs/articles">
        <span>Articles</span>
      </a>
    </li>
    
    <li class="menu-item-blog">
      <a href="/docs/blog">
        <span>Blog</span>
      </a>
    </li>
    
    <li class="menu-item-about me">
      <a href="/docs/about">
        <span>About me</span>
      </a>
    </li>
    
    <li class="menu-item-achievements">
      <a href="/docs/achievements">
        <span>Achievements</span>
      </a>
    </li>
    
    <li class="menu-item-contacts">
      <a href="/docs/contact">
        <span>Contacts</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo.svg" /></a>
    </div>
    <div class="logo-mobile">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo-mobile.svg" /></a>
    </div>
    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-docs">
      <a href="/docs/">
        <span>Docs</span>
      </a>
    </li>
    
    <li class="menu-item-articles">
      <a href="/docs/articles">
        <span>Articles</span>
      </a>
    </li>
    
    <li class="menu-item-blog">
      <a href="/docs/blog">
        <span>Blog</span>
      </a>
    </li>
    
    <li class="menu-item-about me">
      <a href="/docs/about">
        <span>About me</span>
      </a>
    </li>
    
    <li class="menu-item-achievements">
      <a href="/docs/achievements">
        <span>Achievements</span>
      </a>
    </li>
    
    <li class="menu-item-contacts">
      <a href="/docs/contact">
        <span>Contacts</span>
      </a>
    </li>
    
  </ul>
</div>
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
  </div>
</div>


    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <h4>Docs</h4>
  <ul>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/mobile/android/fundamentals/activities/">Activities</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/mobile/android/fieldmanuals/btfm/">Btfm Android</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/mobile/android/attacks/ipc-attacks/">IPC Attacks</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2018/04/dot-net-confuser/">.NET Confuser</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2018/07/analytic-protiv-khishnika/">Analytic Protiv Khishnika</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2018/07/undesirable-mail/">Undesirable Mail</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/mobile/android/fieldmanuals/rtfm/">Rtfm Android</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2020/09/how-i-met-hugo/">How I Met Hugo</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/forensics/linux/plan/">Linux</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/forensics/macos/plan/">MacOSX Forensics Plan</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/forensics/memory/plan/">Plan for Memory Forensics</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/forensics/reveng/plan/">Plan for Reverse Engineering</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/forensics/net/plan/">Windows Forensics Plan</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/forensics/win/plan/">Windows Forensics Plan</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2020-06-06-changes-in-java-string/">Changes to String in java (from 1.7.0_06)</a>
    </li>
    
    <li class="active ">
      <a href="https://bakerst221b.com/docs/blog/2020-05-01-algorithms-graphs/">Algorithms - Graphs</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2020-04-29-subtyping/">Programming Language - Subtyping</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2020-02-29-racket/">Racket notes</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2019-12-30-standardml-notes/">Standard ML notes</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2019-03-28-javascript-comparison/">JavaScript Comparison operation at a glance</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2019-03-22-js-tips/">Js tips I can&#39;t remember</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2019-03-08-es6-bind-trick/">Bind specific arguments of a function</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2019-03-08-object-assign-with-accessor-descriptor/">Object.assign() with accessor descriptor</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2019-01-19-vue-navigation-guards/">VueのNavigation Guards</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2019-01-18-es6/">ES6について</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/mobile/ios/rtfm/"></a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/about/">About me</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/achievements/">Achievements</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/contact/">Contact</a>
    </li>
    
  </ul>
</div>

          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">Algorithms - Graphs</h1>
<div class="content ">
  <h2 id="undirected-graphs">Undirected Graphs</h2>
<h3 id="some-problems">Some problems</h3>
<ul>
<li>Path</li>
<li>Shortest path</li>
<li>Cycle</li>
<li>Ehler tour: A cycle that uses each edge excatly once.</li>
<li>Hamilton tour: A cycle that uses each vertex exactly once
<ul>
<li>classical NP-complete problem.</li>
</ul>
</li>
<li>Connectivity</li>
<li>MST:</li>
<li>Biconnectivity: A vertex whose removal disconnects the graph</li>
<li>Planarity</li>
<li>Graph isomorphism: Are two graphs identical?
<ul>
<li>No one knows so far. A lonstanding open problem</li>
</ul>
</li>
</ul>
<h3 id="representations">Representations</h3>
<p>Real-world graphs tend to be <strong>sparse</strong> (huge number of vertices, small average vertex degree).</p>
<ul>
<li>Set-of-edges representation
<ul>
<li>unefficient</li>
</ul>
</li>
<li>Adjacency-matrix representation
<ul>
<li>space cost is prohibitive</li>
</ul>
</li>
<li>Adjacency-list array representation
<ul>
<li>GOOD</li>
</ul>
</li>
</ul>
<h3 id="adjacency-list-data-structure">Adjacency-list Data structure</h3>
<ul>
<li>Space usage proportional to V + E</li>
<li>Constant time to add an edge</li>
<li>Time proportional to the degree of v to iterate through vertices adjacent to v</li>
</ul>
<h3 id="depth-first-search-dfs">Depth-first Search (DFS)</h3>
<p>Typical applications:</p>
<ul>
<li>Find all vertices connected to a given source vertex</li>
<li>Find a path between two vertices</li>
</ul>
<p>Algorithm:</p>
<ul>
<li>Use recursion (a function-call stack) or an explicit stack.</li>
<li>Mark each visited vertex (and keep track of edge taken to visit it)</li>
<li>Return (retrace steps) when no unvisited options</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DepthFirstPaths</span><span class="o">{</span>
    <span class="kd">private</span> <span class="n">blloean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">edgeTO</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">DepthFirstPaths</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">// ...
</span><span class="c1"></span>        <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Graph</span> <span class="n">Gm</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span>
            <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span>
                <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
            <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>Propositions:</p>
<ol>
<li>DFS marks all vertices connected to s in time proportional to the sum of their degrees.</li>
<li>After DFS, can find vertices connected to s in constant time and can find a path to s in time proportional to its length.</li>
</ol>
<h3 id="breadth-first-search-bfs">Breadth-first Search (BFS)</h3>
<p>Typical applications:</p>
<ul>
<li>shortest path</li>
</ul>
<p>Algorithm:</p>
<ul>
<li>Put s onto a queue, and mark s as visited</li>
<li>Take the next vertex v from the queue and mark it</li>
<li>Put onto the queue all unmarked vertices that are adjacent to v</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BreadthFirstPaths</span>
<span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="n">marked</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="n">ture</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
        <span class="o">{</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span><span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
            <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span>
                <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
                    <span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>Proposition:</p>
<ol>
<li>BFS computes shortest paths (fewest number of edges) from s to all other vertices in a graph in time proportional to E + V</li>
</ol>
<h3 id="applications-of-dfs">Applications of DFS</h3>
<h4 id="connected-components">Connected components</h4>
<p>The goal is to preprocess graph to answer queries of the form <em>is v connected to w?</em> in constant time.</p>
<p>The relation <em>is connected to</em> is an equivalence relation:</p>
<ul>
<li>Reflexive: v is connected to v</li>
<li>Symmetric: if v is connected to w, then w is connected to v</li>
<li>Transitive: if v connected to w and w connected to x, then v connected to x</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CC</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CC</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
        <span class="n">id</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// ...
</span><span class="c1"></span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">id</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h4 id="cycle-detection">Cycle detection</h4>
<p>Problem: Is a given graph acylic?</p>
<p><strong>TODO</strong></p>
<h4 id="two-colorability">Two-colorability</h4>
<p>Problem: Is the graph bipartite?</p>
<p><strong>TODO</strong></p>
<h4 id="symbol-graphs">Symbol graphs</h4>
<p><strong>TODO</strong></p>
<h4 id="degrees-of-separation">Degrees of separation</h4>
<p><strong>TODO</strong></p>
<h2 id="directed-graphs">Directed Graphs</h2>
<blockquote>
<p>A directed graph (or digraph) is a set of vertices and a collection of directed edges. Each directed edge connects an ordered pair of vertices.</p>
</blockquote>
<ul>
<li><em>outdegree</em>: the number of edges going <strong>from</strong> it</li>
<li><em>indegree</em>: the number fo edges going <strong>into</strong> it</li>
<li><em>directed path</em>: a sequence of vertices in which there is a (directed) edge pointing from each vertex in the sequence to its successor in the sequence</li>
<li><em>directed cycle</em></li>
<li><em>simple cycle</em>: a cycle with no repeated edges or vertices</li>
</ul>
<h3 id="representations-1">Representations</h3>
<p>Again, use <a href="#Adjacency-list-Data-structure">adjacency-lists representation</a></p>
<ul>
<li>Based on iterating over vertices pointing from v</li>
<li>Real-world digraphs tend to be sparse</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Digraph</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">V</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;[]</span> <span class="n">adj</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Digraph</span><span class="o">(</span><span class="kt">int</span> <span class="n">V</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">;</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="o">(</span><span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">[</span><span class="n">V</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;[];</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">adj</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="digraph-search">Digraph search</h3>
<p>Reachabiliity problem: Find all vertices reachable from s along a directed path.</p>
<p>We can use <a href="#Depth-first-Search-(DFS)">the same dfs method as for undirected graphs</a>.</p>
<ul>
<li>Every undirected graph is a digraph with edges in both directions.</li>
<li>DFS is a digraph algorithm,</li>
</ul>
<p>Reachability applications:</p>
<ul>
<li>program control-flow analysis
<ul>
<li>Dead-code elimination</li>
<li>infinite-loop detection</li>
</ul>
</li>
<li>mark-sweep garbage collector</li>
</ul>
<p>Other DFS problems:</p>
<ul>
<li>Path findind</li>
<li>Topological sort</li>
<li>Directed cycle detection</li>
<li>&hellip;</li>
</ul>
<p>BFS problems:</p>
<ul>
<li>shortest path</li>
<li>multiple-source shortest paths</li>
<li>web crawler application</li>
</ul>
<h3 id="topological-sort">Topological Sort</h3>
<blockquote>
<p>Topological sort: Given a digraph, put the vertices in order such that all its directed edges point from a vertix earlier in the order to a vertex later in the order (or report impossible).</p>
</blockquote>
<p>A digraph has a topological order <strong>if and only if</strong> it is a <em>directed acyclic graph</em> (DAG).
Topological sort redraws DAG so all edges poitn upwards.</p>
<p>use <strong>DFS</strong> again. It can be proved that reverse postorder of a DAG is a topological order.
(check P578 for the definition of Preorder/Postorder)</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DepthFirstOrder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">reversePost</span><span class="o">;</span>

    <span class="n">publiv</span> <span class="nf">DepthFirstOrder</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">reversePost</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
        <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Digrapg</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">)</span>
        <span class="o">}</span>
        <span class="n">reversePost</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h4 id="directed-cycle-detection">Directed cycle detection</h4>
<p>To find out if a given digraph is a DAG, we can try to find a directec cycle in the digraph.
Use DFS and a stack to track the cycle.</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="c1">// TODO
</span></code></pre></div><p>Some very typical applications of directed cycle detection and topological sort:
(A directed cycle means the problem is infeasible)</p>
<ul>
<li>job schedule</li>
<li>course scuedule</li>
<li>inheritance</li>
<li>spreadsheet
<ul>
<li>vertex: cell</li>
<li>edge: formula</li>
</ul>
</li>
<li>symbolic links</li>
</ul>
<h3 id="strong-components">Strong components</h3>
<p>Vertices v and w are <strong>strongly connected</strong> if there is both a directed path from v to w and a directed path from w to v.
Strong connectivity is an equvicalence relation.</p>
<h4 id="kosaraju-sharir-algorithm">Kosaraju-Sharir Algorithm</h4>
<p>Kosaraju-Sharir is easy to implement but difficutl to understand. It runs DFS twice:</p>
<ul>
<li>Given a digraph G, run DFS to compute the topological order of its reverse $G^R$</li>
<li>Run DFS on G in the order given by first DFS</li>
</ul>
<p>TODO: ADD Proof</p>
<p><a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/KosarajuSharirSCC.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/KosarajuSharirSCC.java.html</a></p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KosarajuSharirSCC</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>     <span class="c1">// marked[v] = has vertex v been visited?
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">id</span><span class="o">;</span>             <span class="c1">// id[v] = id of strong component containing v
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>            <span class="c1">// number of strongly-connected components
</span><span class="c1"></span>
    <span class="cm">/**
</span><span class="cm">     * Computes the strong components of the digraph {@code G}.
</span><span class="cm">     * @param G the digraph
</span><span class="cm">     */</span>
    <span class="kd">public</span> <span class="nf">KosarajuSharirSCC</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// compute reverse postorder of reverse graph
</span><span class="c1"></span>        <span class="n">DepthFirstOrder</span> <span class="n">dfs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DepthFirstOrder</span><span class="o">(</span><span class="n">G</span><span class="o">.</span><span class="na">reverse</span><span class="o">());</span>

        <span class="c1">// run DFS on G, using reverse postorder to guide calculation
</span><span class="c1"></span>        <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
        <span class="n">id</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">dfs</span><span class="o">.</span><span class="na">reversePost</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// DFS on graph G
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span> 
        <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">id</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// ...
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><h2 id="minimum-spanning-trees">Minimum Spanning Trees</h2>
<p>An edge-weighted-graph is a graph where we associate weight or costs with each edge.
A spanning tree of an undirected edge-weighted graph G is a subgraph T that is both <strong>a tree (conneted and acyclic)</strong> and <strong>spanning (includes all of the vertices)</strong>.
Given an (connected) undirected edge-weighted graph G with V vertices and E edges, the MST of it must have <strong>V - 1</strong> edges.
If the graph is not connceted, we compute minimum spanning forest (MST of each component).</p>
<ul>
<li>A <em>cut</em> in a graph is a partition of its vertices into two (nonempty) sets</li>
<li>A <em>crossing edge</em> connects a vertex in one set with a vertex in the other.</li>
<li>Cut property: Given any cut, the crossing edge of min weight is in the MST.</li>
</ul>
<h3 id="edge-weight-graph-data-type">Edge-weight Graph Data Type</h3>
<p>Edge:
<a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/Edge.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/Edge.java.html</a></p>
<p>EdgeWeigthedGraph:
<a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html</a></p>
<h3 id="greedy-mst-algorithm"><strong>Greedy MST Algorithm:</strong></h3>
<ul>
<li>Start with all edges colored gray.</li>
<li>Find cut with no blacked crossing edges; color its min-weight edge black.</li>
<li>Repeat until V-1 edges are colored black.</li>
</ul>
<h3 id="implementations-1-kruskals-algorithm">Implementations 1: Kruskal&rsquo;s algorithm</h3>
<p>For edges in ascending order of weight:</p>
<ul>
<li>Add next edge to Tree unless doing so would create a cycle.</li>
</ul>
<p>To efficiently solve this problem, use union-find :</p>
<ol>
<li>use a priority queue to maintain all the edges in V</li>
<li>union-find data structure:
<ul>
<li>maintain a set for each connected component in T.</li>
<li>if v and w are in saome set, then adding v-&gt;w would create a cycle</li>
<li>to add v&gt;w to T, merge sets containing v and w.</li>
</ul>
</li>
</ol>
<p>TODO: Add code</p>
<h3 id="implementations-2-prims-algorithm">Implementations 2: Prim&rsquo;s algorithm</h3>
<ul>
<li>Start with vertex 0 and greedily grow tree T.</li>
<li>Add To T the min weight edge with exactly oue endpoint in T.</li>
<li>Reapeat unitl V - 1 edges.</li>
</ul>
<p>The key to solve this problem is how do we find the crossing edge of minimal weight efficiently.</p>
<p>A lazy solution (in time proportional to $ElogE$, fair enough):</p>
<ol>
<li>Maintain a PQ of edges with (at least) one endpoint in T
<ul>
<li>Key = edge, priority = weight</li>
</ul>
</li>
<li>Delete-min to determine next edge e = v-&gt;w to add to T</li>
<li>Disregard if both endpoints v and w are marked (both in T)</li>
<li>Otherwise, let w be the unmarked vertex (not in T)
<ul>
<li>add to PQ and edge incident to w (assuming other endpoint not in T)</li>
<li>add e to T and mark w</li>
</ul>
</li>
</ol>
<p>TODO: add code</p>
<p>A eager solution (in time proprotional to $ElogV$, better):</p>
<ol>
<li>Maintain a PQ of vertices connected by an edge to T, where priority of v = weight of shortedt edge connecting v to T</li>
<li>Delete min vertex v and add its associated edge e = v-&gt;w to T</li>
<li>Update PQ by considering all edges e = v-&gt;x incident to v
<ul>
<li>ignore if x is already in T</li>
<li>add x to PQ if not alread on it</li>
<li>decrease priority of x if v-&gt;x becomes shortest edge connecting x to T</li>
</ul>
</li>
</ol>
<p>This solution uses an <a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/IndexMinPQ.java.html">indexed priority queue</a> data structure.</p>
<p>TODO: add code</p>
<h2 id="shortest-paths">Shortest Paths</h2>
<p><strong>Some variants:</strong></p>
<ul>
<li>Which vertices?
<ul>
<li>Single source</li>
<li>Source-sink</li>
<li>All pairs</li>
</ul>
</li>
<li>Edge weights
<ul>
<li>Nonegative weights</li>
<li>Euclidean weights</li>
<li>Arbitrary weights</li>
</ul>
</li>
<li>Cycles?
<ul>
<li>No directed cycles</li>
<li>No negative cycles</li>
</ul>
</li>
</ul>
<h3 id="edge-weighted-digraph-data-strcuture">Edge-weighted digraph data strcuture</h3>
<p>Weighted directed edge:
<a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/DirectedEdge.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/DirectedEdge.java.html</a></p>
<p>Edge-weighted digraph:
<a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedDigraph.java.html">https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedDigraph.java.html</a></p>
<p>Use adjacency-lists implementation same as <a href="https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/EdgeWeightedGraph.java.html">EdgeWeightedGraph</a></p>
<h3 id="generic-single-source-shortest-paths">Generic Single-source Shortest paths</h3>
<p>Our goal is to find the shortest path from s to every other vertex. As a result, what we find will be the <strong>shortest-paths tree (SPT)</strong> for source s.</p>
<h4 id="relax-edge-e--v-w">Relax edge e = v-&gt;w</h4>
<ul>
<li>distTo[v] is length of shortest known path from s to v</li>
<li>distTo[w] is length of shortest known path from s to w</li>
<li>esgeTo[w] is last edge on shortest known pathh from s to w</li>
<li>if e = v-&gt;w gives shorter path to w through v, update both distTo[w] and edgeTo[w]</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">(),</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
        <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h4 id="optimality-conditions">Optimality conditions</h4>
<p>Given an edge-weighted digraph G, distTo[] are the shortest path distances from s <strong>iff</strong>:</p>
<ul>
<li>distTo[s] = 0</li>
<li>For each vertex v, distTo[v] is the length of some path from s to v.</li>
<li>For each edge e = v-&gt;w, distTo[w] &lt;= distTo[v] + e.weight()</li>
</ul>
<h4 id="generic-algorithm">Generic algorithm</h4>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">Generic algorithm (to compute SPT from s) {
    Initialize distTo[s] = 0 and distTo[v] = $\infty$

    Repeat until optimality conditions are satisfied:
        - Relax any edge
}
</code></pre></div><p>Efficient implementations:</p>
<ul>
<li>Nonnegative weights: <a href="#implement-1-dijkstras-algorithm">Dijkstra&rsquo;s algorithm</a></li>
<li>No directed cycles (DAGs): <a href="#implement-2-topological-sort-algorithm">Topological sort algorithm</a></li>
<li>No negative cycles: <a href="#implement-3-bellman-ford-algorithm">Bellman-Ford</a></li>
</ul>
<h3 id="implement-1-dijkstras-algorithm">Implement 1: Dijkstra&rsquo;s algorithm</h3>
<p>When there is no nonnegative weight exists, we can use Dijkstra&rsquo;s algorithm.</p>
<ul>
<li>Consider vertices in increasing order of distance from s (non-tree vertex with the lowest distTo[] value)</li>
<li>add vertex to tree and relax all edges pointing from that vertex</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DijkstraSP</span><span class="o">{</span>
        <span class="c1">// ...
</span><span class="c1"></span>    <span class="kd">public</span> <span class="nf">DijkstraSP</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">edgeTo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedEdge</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
        <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IndexMinPQ</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;(</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">());</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">0</span><span class="o">.</span><span class="na">0</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">v</span><span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">relax</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">(),</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
            <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">w</span><span class="o">))</span> <span class="n">pq</span><span class="o">.</span><span class="na">decreaseKey</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
            <span class="k">else</span> <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p><strong>Compare to Prim&rsquo;s algorithm:</strong></p>
<ul>
<li>Both are computing a graph&rsquo;s spanning tree</li>
<li>Prim&rsquo;s algorithm choose closest vertex to tree as next vertex, while Dijkstra&rsquo;s algorithm choose closest vertex to the source</li>
</ul>
<h3 id="implement-2-topological-sort-algorithm">Implement 2: Topological sort algorithm</h3>
<p>When the graph is a DAG, we can consider vertices in topological order and do relaxing.</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java">    <span class="c1">// ...
</span><span class="c1"></span>    <span class="n">Topological</span> <span class="n">topological</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Topological</span><span class="o">(</span><span class="n">G</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">topological</span><span class="o">.</span><span class="na">order</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">relax</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div><p><strong><a href="https://en.wikipedia.org/wiki/Seam_carving">Seam carving</a></strong>: Resize an image without distortion.</p>
<p><strong>Longest paths</strong>:</p>
<ul>
<li>Formuate as a shortest paths problem in edge-weighted DAGs
<ul>
<li>Negate all weights</li>
<li>Find shortest paths</li>
<li>Negate weights in result</li>
</ul>
</li>
<li>Allpication: Parallel job scheduling (<a href="https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AA%E3%83%86%E3%82%A3%E3%82%AB%E3%83%AB%E3%83%91%E3%82%B9%E6%B3%95">Critical path method, CPM</a>).</li>
</ul>
<h3 id="implement-3-bellman-ford-algorithm">Implement 3: Bellman-Ford algorithm</h3>
<blockquote>
<p>A SPT exists iff no negative cycles (a directed cycle whose sum of edge weights is negative).</p>
</blockquote>
<p>When we want to find shortest paths with nagative weights, Dijkstra&rsquo;s algorithms doesn&rsquo;t work.
We can use Bellman-Ford algorithm as long as there is no negative cycle in the graph.
(Bellman-Ford algorithm is a dynamic programming algorithm)</p>
<ul>
<li>Initialize distTo[s] = 0 and distTo[v] = $\infty$</li>
<li>Maintain a queue and repeat until the queue is empty or find a cycle:
<ul>
<li>Pop vertex v from q</li>
<li>Relax each edge pointing from v to  any vertex w:
<ul>
<li>if distTo[w] can be de decreased, update distTo[w] and add w to the queue</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="c1">// ...
</span><span class="c1"></span>    <span class="kd">public</span> <span class="nf">BellmanFordSP</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">distTo</span>  <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
        <span class="n">edgeTo</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedEdge</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
        <span class="n">onQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
            <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
        <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">.</span><span class="na">0</span><span class="o">;</span>

        <span class="c1">// Bellman-Ford algorithm
</span><span class="c1"></span>        <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="n">onQueue</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hasNegativeCycle</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>
            <span class="n">onQueue</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">relax</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
                <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">onQueue</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
                    <span class="n">onQueue</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(++</span><span class="n">cost</span> <span class="o">%</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">findNegativeCycle</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">hasNegativeCycle</span><span class="o">())</span> <span class="k">return</span><span class="o">;</span>  <span class="c1">// found a negative cycle
</span><span class="c1"></span>            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

</code></pre></div><p>Bellman-Ford algorithm can also be used for finding a negative cycle.</p>
<p>Negative cycle application: arbitrage detection.</p>

</div>
</div>

        </div>
      </div>
    </div>
    
  </div>

  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            <li class="zerostatic"><a href="https://www.zerostatic.io">www.zerostatic.io</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.1237ff71925bb8625c97a9af8db4c54525258bedfd7c47493daaff723bea755e.js"></script>
  

  
  
  
    
  


</body>

</html>
