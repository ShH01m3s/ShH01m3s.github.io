<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Standard ML notes - Observer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://bakerst221b.com/favicon.png">

  
  
  <link rel="stylesheet" href="/css/style.min.aad43d4ecb69a264f2539b89d7f779d5f3cdff22e7585fe5fc3c77272f1c2696.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-docs">
      <a href="/docs/">
        <span>Docs</span>
      </a>
    </li>
    
    <li class="menu-item-articles">
      <a href="/docs/articles">
        <span>Articles</span>
      </a>
    </li>
    
    <li class="menu-item-blog">
      <a href="/docs/blog">
        <span>Blog</span>
      </a>
    </li>
    
    <li class="menu-item-about me">
      <a href="/docs/about">
        <span>About me</span>
      </a>
    </li>
    
    <li class="menu-item-achievements">
      <a href="/docs/achievements">
        <span>Achievements</span>
      </a>
    </li>
    
    <li class="menu-item-contacts">
      <a href="/docs/contact">
        <span>Contacts</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo.svg" /></a>
    </div>
    <div class="logo-mobile">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo-mobile.svg" /></a>
    </div>
    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home">
      <a href="/">
        <span>Home</span>
      </a>
    </li>
    
    <li class="menu-item-docs">
      <a href="/docs/">
        <span>Docs</span>
      </a>
    </li>
    
    <li class="menu-item-articles">
      <a href="/docs/articles">
        <span>Articles</span>
      </a>
    </li>
    
    <li class="menu-item-blog">
      <a href="/docs/blog">
        <span>Blog</span>
      </a>
    </li>
    
    <li class="menu-item-about me">
      <a href="/docs/about">
        <span>About me</span>
      </a>
    </li>
    
    <li class="menu-item-achievements">
      <a href="/docs/achievements">
        <span>Achievements</span>
      </a>
    </li>
    
    <li class="menu-item-contacts">
      <a href="/docs/contact">
        <span>Contacts</span>
      </a>
    </li>
    
  </ul>
</div>
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
  </div>
</div>


    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <h4>Docs</h4>
  <ul>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/mobile/android/fundamentals/activities/">Activities</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/mobile/android/fieldmanuals/btfm/">Btfm Android</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/mobile/android/attacks/ipc-attacks/">IPC Attacks</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2018/04/dot-net-confuser/">.NET Confuser</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2018/07/analytic-protiv-khishnika/">Analytic Protiv Khishnika</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2018/07/undesirable-mail/">Undesirable Mail</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/mobile/android/fieldmanuals/rtfm/">Rtfm Android</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2020/09/how-i-met-hugo/">How I Met Hugo</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/forensics/linux/plan/">Linux</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/forensics/macos/plan/">MacOSX Forensics Plan</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/forensics/memory/plan/">Plan for Memory Forensics</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/forensics/reveng/plan/">Plan for Reverse Engineering</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/forensics/net/plan/">Windows Forensics Plan</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/forensics/win/plan/">Windows Forensics Plan</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2020-06-06-changes-in-java-string/">Changes to String in java (from 1.7.0_06)</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2020-05-01-algorithms-graphs/">Algorithms - Graphs</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2020-04-29-subtyping/">Programming Language - Subtyping</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2020-02-29-racket/">Racket notes</a>
    </li>
    
    <li class="active ">
      <a href="https://bakerst221b.com/docs/blog/2019-12-30-standardml-notes/">Standard ML notes</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2019-03-28-javascript-comparison/">JavaScript Comparison operation at a glance</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2019-03-22-js-tips/">Js tips I can&#39;t remember</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2019-03-08-es6-bind-trick/">Bind specific arguments of a function</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2019-03-08-object-assign-with-accessor-descriptor/">Object.assign() with accessor descriptor</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2019-01-19-vue-navigation-guards/">VueのNavigation Guards</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/blog/2019-01-18-es6/">ES6について</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/articles/mobile/ios/rtfm/"></a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/about/">About me</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/achievements/">Achievements</a>
    </li>
    
    <li class="">
      <a href="https://bakerst221b.com/docs/contact/">Contact</a>
    </li>
    
  </ul>
</div>

          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">Standard ML notes</h1>
<div class="content ">
  <h2 id="basics">Basics</h2>
<h3 id="comments">Comments</h3>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">(* SML comment *)
</code></pre></div><h3 id="variable-bindings-and-expressions">Variable bindings and Expressions</h3>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">val x = 34;
(* static environment: x : int *)
(* dynamic environment: x --&gt; 34 *)
val y = x + 1;

(* Use tilde character instead of minus to reprsent negation *)
val z = ~1;

(* Integer Division *)
val w = y div x
</code></pre></div><p>Strings:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">(* `\n`のようなエスケープシーケンスが利用できる *)
val x = &#34;hello\n&#34;; 
(* 文字列の連結には&#39;^&#39;を使う *)
val y = &#34;hello &#34; ^ &#34;world&#34;;
</code></pre></div><p>An ML program is a sequence of bindings. Each binding gets <strong>type-checked</strong> and then <strong>evaluated</strong>.
What type a binding has depends on a static environment. How a binding is evaluated depends on a dynamic environment.
Sometimes we use just <code>environment</code> to mean dynamic environment and use <code>context</code> as a synonym for static environment.</p>
<ul>
<li>Syntaxs : How to write it.</li>
<li>Semantics: How it type-checks and evaluates</li>
<li>Value: an expression that has no more computation to do</li>
</ul>
<h3 id="shadowing">Shadowing</h3>
<p><strong>Bindings are immutable</strong> in SML. Given <code>val x = 8 + 9;</code> we produce a dynamic environment where x maps to 17.
In this environment x will always map to 17; there is no &ldquo;assignment statement&rdquo; in ML for changing what x maps to.
You can have another binding later, say <code>val x = 19;</code>, but that just creates a differnt environment
where the later binding for x <strong>shadows</strong> the earlier one.</p>
<h3 id="function-bindings">Function Bindings</h3>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun pow (x:int, y:int) = (* correct only for y &gt;= 0 *)
    if y = 0
    then 1
    else x * pow(x, y-1);

fun cube (x : int) = 
    pow(x, 3);

val ans = cube(4);
(* The parentheses are not necessary if there is only one argument
     val ans = cube 4; *)
</code></pre></div><ul>
<li>Syntax: <code>fun x0 (x1 : t1, ..., xn : tn) = e</code></li>
<li>Type-checking:
<ul>
<li><code>t1 * ... * tn -&gt; t</code></li>
<li>The type of a function is &ldquo;argument types&rdquo; -&gt; &ldquo;reslut types&rdquo;</li>
</ul>
</li>
<li>Evaluation:
<ul>
<li>A function is a value</li>
<li>The environment we extends arguments with is that “was current” when the function was defined, not the one where it is being called.</li>
</ul>
</li>
</ul>
<h3 id="pairs-and-other-tuples">Pairs and other Tuples</h3>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun swap (pr : int*bool) =
    (#2 pr, #1 pr);

fun sum_two_pairs (pr1 : int * int, pr2 : int * int) =
    (#1 pr1) + (#2 pr1 ) + (#1 pr2) + (#2 pr2);

fun div_mod (x : int, y: int) =
    (x div y, x mod y);

fun sort_pair(pr : int * int) =
    
    if (#1 pr) &lt; (#2 pr) then
	pr
    else
	(#2 pr, #1 pr);
</code></pre></div><p>ML supportstuplesby allowing any number of parts. Pairs and tuples can be nested however you want. For example, a 3-tuple (i.e., a triple) of integers has type int<em>int</em>int. An example is (7,9,11) and you retrieve the parts with #1 e, #2 e, and #3 e where e is an expression that evaluates to a triple.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">val a = (7, 9, 11) (* int * int * int *)
val x = (3, (4, (5,6))); (* int * (int * (int * int)) *)
val y = (#2 x, (#1 x, #2 (#2 x))); (* (int * (int * int)) * (int * (int * int)) *)
val ans = (#2 y, 4); (* (int * (int * int)) * int *)
</code></pre></div><h3 id="lists">Lists</h3>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">val x = [7,8,9];
5::x; (* 5 consed onto x *)
6::5::x;
[6]::[[1,2],[3,4];
</code></pre></div><p>To append a list t a list, use list-append operator <code>@</code>:
<a href="%5Bhttp://sml-family.org/Basis/list.html%5D(http://sml-family.org/Basis/list.html)">Reference：# The Standard ML Basis Library</a></p>
<blockquote>
<p>Interface:
<strong>val</strong>  <a href="http://sml-family.org/Basis/list.html#SIG:LIST.@:VAL">@</a>  <strong>:</strong>  <em>&lsquo;a</em> list *  <em>&lsquo;a</em> list <strong>-&gt;</strong>  <em>&lsquo;a</em> list</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">val x = [1,2] @ [3,4,5]; (* [1,2,3,4,5] *)
</code></pre></div><p>Accessing:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">val x = [7,8,9];
null x; (* False *)
null []; (* True *)
hd x; (* 7 *)
tl x; (* [8, 9] *)
</code></pre></div><h3 id="list-functions">List Functions</h3>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun sum_list(xs : int list) =
    if null xs
    then 0
    else hd xs + sum_list(tl xs);

fun list_product(xs : int list) =
    if null xs
    then 1
    else hd xs * list_product(tl xs);

fun countdown(x : int) =
    if x = 0
    then []
    else x :: countdown(x - 1);

fun append (xs : int lisst, ys : int list) =
    if null xs
    then ys
    else (hd xs) :: append((tl xs), ys);

fun sum_pair_list(xs : (int * int) list) =
    if null xs
    then 0
    else #1 (hd xs) + #2 (hd xs) + sum_pair_list(tl xs);

fun firsts (xs : (int * int) list) =
    if null xs
    then []
    else (#1 (hd xs)) :: firsts(tl xs);

fun seconds (xs : (int * int) list) =
    if null xs
    then []
    else (#2 (hd xs)) :: seconds(tl xs);

fun sum_pair_list2 (xs : (int * int) list) =
    (sum_list(firsts xs)) + (sum_list(seconds xs));

</code></pre></div><p>Functions that make and us lists are almost always recursice becasue a list has an unknown length. To write a recursive function the thought process involves two steps:</p>
<ul>
<li>think about the <em>base case</em></li>
<li>think about the <em>recursive case</em></li>
</ul>
<h3 id="let-expressions">Let Expressions</h3>
<ul>
<li>Syntax: <code>let b1 b2 ... bn in e end</code>
<ul>
<li>Each <code>bi</code> is any binding an <code>e</code> is any expression</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">let val x = 1
in
    (let val x = 2 in x+1 end) + (let val y = x+2 in y+1 end)
end

fun countup_from1 (x:int) =
    let fun count (from:int) =
        if from=x
        then x::[]
        else from :: count(from+1)
    in
        count(1)
    end
</code></pre></div><h3 id="options">Options</h3>
<p>An option value has either 0 or 1 thing: <code>None</code> is an option value carrying nothing whereas <code>SOME e</code> evaluates e to a value v and becomes the option carrying the one value v. The type of <code>NONE</code> is <code>'a option</code> and the type of <code>SOME e</code> is <code>t option</code> if e has type t.</p>
<p>We have:</p>
<ul>
<li><code>isSome</code> which evaluates to false if its argument is NONE</li>
<li><code>valOf</code> to get the value carried by <code>SOME</code>(raising exception for <code>NONE</code>)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun max1( xs : int list) =
    if null xs
    then NONE
    else
	let val tl_ans = max1(tl xs)
	in
	    if isSome tl_ans andalso valOf tl_ans &gt; hd xs
	    then tl_ans
	    else SOME (hd xs)
	end;
</code></pre></div><h2 id="some-more-expressions">Some More Expressions</h2>
<p>Boolean operations:</p>
<ul>
<li><code>e1 andalso e2</code>
<ul>
<li>if result of e1 is false then false else result of e2</li>
</ul>
</li>
<li><code>e1 orelse e2</code></li>
<li><code>not e1</code></li>
</ul>
<p><strong>※Syntax <code>&amp;&amp;</code> and <code>||</code> don&rsquo;t exist in ML and <code>!</code> means something different.</strong></p>
<p><strong>※<code>andalso</code> and <code>orelse</code> are just keywords. <code>not</code> is a pre-defined function.</strong></p>
<p>Comparisons:</p>
<ul>
<li><code>=</code> <code>&lt;&gt;</code> <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code>
<ul>
<li><code>=</code> and <code>&lt;&gt;</code> can be used with any &ldquo;equality type&rdquo; but not with real</li>
</ul>
</li>
</ul>
<h2 id="build-new-types">Build New Types</h2>
<p>To Create a compound type, there are really only three essential building blocks:</p>
<ul>
<li><strong>Each-of</strong> : A compound type t describes values that contain each of values of type <code>t1</code> <code>t2</code> &hellip; <code>tn</code></li>
<li><strong>One-of</strong>: A compound type t describes values that contain a value of one of the types <code>t1</code> <code>t2</code> &hellip; <code>tn</code></li>
<li><strong>Self-refenence</strong>: A compound type t may refer to itself in its definition in order to describe recursive data structures like lists and trees.</li>
</ul>
<h3 id="records">Records</h3>
<p>Record types are &ldquo;each-of&rdquo; types where each component is a named field. The order of fields never matters.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">val x = {bar = (1+2,true andalso true), foo = 3+4, baz = (false,9) }
#bar x (* (3, true) *)
</code></pre></div><p>Tupels are actually syntactic sugar for records. <code>#1 e</code>, <code>#2 e</code>, etc. mean: get the contents of the field named 1, 2, etc.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">- val x = {1=&#34;a&#34;,2=&#34;b&#34;};
val x = (&#34;a&#34;,&#34;b&#34;) : string * string
- val y = {1=&#34;a&#34;, 3=&#34;b&#34;};
val y = {1=&#34;a&#34;,3=&#34;b&#34;} : {1:string, 3:string}
</code></pre></div><h3 id="datatype-bindings">Datatype bindings</h3>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">datatype mytype = TwoInts of int*int
		                       | Str of string
                               | Pizza;
val a = Str &#34;hi&#34;; (* Str &#34;hi&#34; : mytype *)
val b = Str; (* fn : string -&gt; mytype *)
val c = Pizza; (* Pizza : mytype *)
val d = TwoInts(1+2, 3+4); (* TwoInts (3,7) : mytype *)
val e = a; (* Str &#34;hi&#34; : mytype *)
</code></pre></div><p>The example above adds four things to the environment:</p>
<ul>
<li>A new type mytype that we can now use just like any other types</li>
<li>Three constructors <code>TwoInts</code>, <code>Str</code>, <code>Pizza</code></li>
</ul>
<p>We can also create a type synonmy which is entirely interchangeable with the existing type.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">type foo = int
(* we can write foo wherever we write int and vice-versa *)
</code></pre></div><h2 id="case-expressions">Case Expressions</h2>
<p>To access to datatype values, we can use a case expression:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun f (x : mytype) =
    case x of
	    Pizza =&gt; 3
      | Str s =&gt; 8
      | TwoInts(i1, i2) =&gt; i1 + i2;

f(Str(&#34;a&#34;)); (* val it = 8 : int *)
</code></pre></div><p>We separate the branches with the <code>|</code> character. Each branch has the form <code>p =&gt; e</code> where p is a pattern and e is an expression. Patterns are used to match against the result of evaluating the case&rsquo;s first expression. This is why evaluating a case-expression is called pattern-matching.</p>
<h2 id="lists-and-options-are-datatypes-too">Lists and Options are Datatypes too</h2>
<p><code>SOME</code> and <code>NONE</code> are actually constructors. So you can use them in a case like:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun inc_or_zero intoption =
    case intoption of
	    NONE =&gt; 0
      | SOME i =&gt; i+1;
</code></pre></div><p>As for list, <code>[]</code> and <code>::</code> are also constructors. <code>::</code> is a little unusual because it is an infix operator so when in patterns:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun sum_list xs =
    case xs of
	    [] =&gt; 0
      | x::xs&#39; =&gt; x + sum_list xs&#39;;

fun append(xs, ys) =
    case xs of
	    [] =&gt; ys
      | x::xs&#39; =&gt; x :: append(xs&#39;, ys);
</code></pre></div><h2 id="pattern-matching">Pattern-matching</h2>
<p>Val-bindings are actually using pattern-matching.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">val (x, y, z) = (1,2,3);
(*
    val x = 1 : int
    val y = 2 : int
    val z = 3 : int
*)
</code></pre></div><p>When defining a function, we can also use pattern-matching</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun sum_triple (x, y, z) =
    x + y + z;
</code></pre></div><p>Actually, all functions in ML takes one tripple as an argument. There is no such thing as a mutli-argument function  or zero-argument function in ML.
The binding <code>fun () = e</code> is using the unit-pattern <code>()</code> to match against calls that pass the unit value <code>()</code>, which is the only value fo a pre-defined datatype <code>unit</code>.</p>
<p>The definition of patterns is recursive. We can use nested patterns instead of nested cae expressions.</p>
<p>We can use wildcard pattern <code>_</code> in patterns.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun len xs =
    case xs of
	[] =&gt; 0
      | _::xs&#39; =&gt; 1 + len xs&#39;;

</code></pre></div><h3 id="function-patterns">Function Patterns</h3>
<p>In a function binding, we can use a syntactic sugar instead of using case expressions:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun f p1 = e1
  | f p2 = e2
  ...
  | f pn = en
</code></pre></div><p>for example</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun append ([], ys) = ys
  | append (x::xs&#39;, ys) = x :: append(xs&#39;, ys);
</code></pre></div><h2 id="exceptions">Exceptions</h2>
<p>To create new kinds of exceptions we can use exception bindings.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">exception MyUndesirableCondition;
exception MyOtherException of int * int;
</code></pre></div><p>Use <code>raise</code> to raise exceptions. Use <code>handle</code> to catch exceptions.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun hd xs =
    case xs of
	[] =&gt; raise List.Empty
      | x::_ =&gt; x;

(* The type of maxlist will be int list * exn -&gt; int *)
fun maxlist(xs, ex) =
    case xs of
	[] =&gt; raise ex
      | x::[] =&gt; x
      | x::xs&#39; =&gt; Int.max(x, maxlist(xs&#39;, ex));

(* e1 handle ex =&gt; e2 *)
val y = maxlist([], MyUndesirableCondition)
	handle MyUndesirableCondition =&gt; 42;
</code></pre></div><h2 id="tail-recursion">Tail Recursion</h2>
<p>There is a situation in a recursive call called <strong>tail call</strong>:</p>
<blockquote>
<p>when f makes a recursive call to f, there is nothing more for the caller to do after the callee returns except return the callee&rsquo;s result.</p>
</blockquote>
<p>Consider a sum function:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun sum1 xs =
    case xs of
        [] =&gt; 0
      | i::xs&#39; =&gt; i + sum1 xs&#39;
</code></pre></div><p>When the function runs, it will keep a call-stack for each recursive call . But if we change a little bit using tail call :</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun sum2 xs =
    let fun f (xs,acc) =
        case xs of
            [] =&gt; acc
          | i::xs&#39; =&gt; f(xs&#39;,i+acc)
    in
        f(xs,0)
    end
</code></pre></div><p>we use a local helper <code>f</code> and a accumulator <code>acc</code> so that the return value  of <code>f</code>  is just the return value of <code>sum2</code> . As a result, there is no need to keep every call in stack, just the current <code>f</code> is enough. And that&rsquo;s ML and most of other functional programming languages do.
Another example: when reversing a list:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun rev1 lst =
    case lst of
        [] =&gt; []
      | x::xs =&gt; (rev1 xs) @ [x]

fun rev2 lst =
    let fun aux(lst,acc) =
	    case lst of
		[] =&gt; acc
	      | x::xs =&gt; aux(xs, x::acc)
    in
	aux(lst,[])
    end
</code></pre></div><p><code>rev1</code> is <code>O(n^2)</code> but rev2 is almost as simple as <code>O(n)</code>.</p>
<p>To make sure which calls are tail calls, we can use a recursive defination of <strong>tail position</strong> like:</p>
<ul>
<li>In <code>fun f(x) = e</code>, <code>e</code> is in tail position.</li>
<li>If an expression is not in tail position, then none of its subexpressions are</li>
<li>If <code>if e1 then e2 else e3</code> is in tail position, then <code>e2</code> and <code>e3</code> are in tail position (but not <code>e1</code>). (Case-expressions are similar.)</li>
<li>If <code>let b1 ... bn in e end</code> is in tail position, then e is in tail position (but no expressions in the bindings are).</li>
<li>Function-call arguments are not in tail position.</li>
</ul>
<h2 id="first-class-functions">First-class Functions</h2>
<p>The most common use of first class functions is passing them as arguments to other functions.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun n_times (f, n, x) =
    if n=0
    then x
    else f (n_times(f, n-1,x))
</code></pre></div><p>The function <code>n_times</code> is called higher-order funciton.  Its type is:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fn : (&#39;a -&gt; &#39;a) * int * &#39;a -&gt; &#39;a
</code></pre></div><p><code>'a</code> means they can be any type. This is called <em>parametric polymorphism</em> , or <em>generic types</em> .</p>
<p>Instead, consider a function that is not polymorphic:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">(* (int -&gt; int) * int -&gt; int *)
fun times_until_zero (f, x) =
    if x = 0
    then 0
    else 1 + times_until_zero(f, f x)
</code></pre></div><h3 id="anonymous-functions">Anonymous Functions</h3>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun triple_n_times (n, x) =
    n_times((fn x =&gt; 3*x), n, x)
</code></pre></div><p>Maps:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">(* (&#39;a -&gt; &#39;b) * &#39;a list -&gt; &#39;b list *)
fun map (f, xs) =
    case xs of
	[] =&gt; []
      | x::xs&#39; =&gt; (f x)::(map(f, xs&#39;));
</code></pre></div><p>Filters:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">(* (&#39;a -&gt; bool) * &#39;a list -&gt; &#39;a list *)
fun filter (f, xs) =
    case xs of
	[] =&gt; []
      | x::xs&#39; =&gt; if f x
		  then x::(filter (f, xs&#39;))
		  else filter (f, xs&#39;);
</code></pre></div><h3 id="lexical-scope-vs-dynamic-scope">Lexical scope VS dynamic scope</h3>
<h3 id="combining-functions">Combining Functions</h3>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"> fun sqrt_of_abs i = (Math.sqrt o Real.fromInt o abs) i;
</code></pre></div><p>Use our own infix operator to define a left-to-right syntax.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">infix |&gt;
fun x |&gt; f = f x;
fun sqrt_of_abs i = i |&gt; abs |&gt; Real.fromInt |&gt; Math.sqrt;
</code></pre></div><h3 id="currying">Currying</h3>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">(* fun sorted(x, y z) = z &gt;= y andalso y &gt;= x *)
val sorted = fn x =&gt; fn y =&gt; fn z =&gt; z &gt;= y andalso y &gt;= x;

(* just syntactic sugar for code above *)
fun sorted_nicer x y z = z &gt;= y andalso y &gt;= x;
</code></pre></div><p>when calling curried the function:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">(* ((sorted_nicer x) y) z *)
(* or just: *)
sorted_nicer x y z
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">
</code></pre></div><h2 id="type-inference">Type Inference</h2>
<p>Key steps in ML:</p>
<ul>
<li>Determine types of bindings in order</li>
<li>For each val of fun binding:
<ul>
<li>Analyze definition for all necessary facts</li>
<li>Type erro if no way for all facts to hold</li>
</ul>
</li>
<li>Use type variables like <code>'a</code> for any unconstrained type</li>
<li>Enforce the value restriction</li>
</ul>
<p>One example:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">(*
	compose : T1 * T2 -&gt; T3
	f : T1
	g : T2
	x : T4
	body being a function has type T3=T4-&gt;T5
	from g being passed x, T2=T4-&gt;T6 for some T6
	from f being passed the result of g, T1=T6-&gt;T7
	from call to f being body of anonymous function, T7 = T5
	all together, (T6-&gt;T5) * (T4-&gt;T6) -&gt; (T4-&gt;T5)
	so (&#39;a-&gt;&#39;b) * (&#39;c-&gt;&#39;a) -&gt; (&#39;c-&gt;&#39;b) 
*)
fun compose (f, g) = fn x =&gt; f (g x)
</code></pre></div><h3 id="value-restriction">Value restriction</h3>
<p>A variable-binding can have a polymorphic type only if the expression is a variable or value:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">val r = ref NONE
val _ = r := SOME &#34;hi&#34;
val i - 1 + valOf (!r)
</code></pre></div><p>If there is is no value-restriction, the code above will type check, which shouldn&rsquo;t.
With value restriction, ML will give a warning when type-checking:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">- val r = ref NONE;
stdIn:2.5-2.17 Warning: type vars not generalized because of
   value restriction are instantiated to dummy types (X1,X2,...)
val r = ref NONE : ?.X1 option ref
</code></pre></div><h2 id="mutual-recursion">Mutual Recursion</h2>
<p>Mutual recursion allows <code>f</code> to call <code>g</code> and <code>g</code> to call <code>f</code>.
In ML, There is an <code>and</code> keyword to allow that:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">fun p1 = e1
and p2 = e2
and p3 = p3
</code></pre></div><h2 id="modules">Modules</h2>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">structure MyMathLib =
struct
fun fact x = x
val half_pi = Math.pi / 2.0
fun doubler x = x * 2
end
</code></pre></div><h3 id="signatures">Signatures</h3>
<p>A signature is a type for a module.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">signature SIGNAME  =
sig types-for-bindings
end
</code></pre></div><p>Ascribing a signature to a module:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">structure myModule :&gt; SIGNAME =
struct bindings end;
</code></pre></div><p>Anything not in the signature cannot be used outside the module.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">signature MATHLIB =
sig
    val fact : int -&gt; int
    val half_pi : real
    (* make doubler unaccessable outside the MyMathLib *)
    (* val doubler : int -&gt; int *)
end

structure MyMathLib :&gt; MATHLIB =
struct
fun fact x = x
val half_pi = Math.pi / 2.0
fun doubler x = x * 2
end 
</code></pre></div><h3 id="signature-matching">Signature matching</h3>
<h2 id="equivalence">Equivalence</h2>
<ul>
<li>PL Equivalence</li>
<li>Asymptotic equivalence</li>
<li>System equivalence</li>
</ul>

</div>
</div>

        </div>
      </div>
    </div>
    
  </div>

  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            <li class="zerostatic"><a href="https://www.zerostatic.io">www.zerostatic.io</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.1237ff71925bb8625c97a9af8db4c54525258bedfd7c47493daaff723bea755e.js"></script>
  

  
  
  
    
  


</body>

</html>
