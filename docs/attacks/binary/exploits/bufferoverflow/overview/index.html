<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview - Analyst</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://bakerst221b.com/favicon.png">
  <link href="/css/style-classic.css"></link>
  
  
  <link rel="stylesheet" href="/css/style.min.564b5f4faf3af87992cb8ab298314448914c22dbdb3f2f9c584546b21b8d407c.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home ğŸ¡">
      <a href="/">
        <span>Home ğŸ¡</span>
      </a>
    </li>
    
    <li class="menu-item-blog âœï¸">
      <a href="/docs/blog">
        <span>Blog âœï¸</span>
      </a>
    </li>
    
    <li class="menu-item-ttp ğŸ”">
      <a href="/docs/ttp">
        <span>TTP ğŸ”</span>
      </a>
    </li>
    
    <li class="menu-item-artefacts db ğŸº">
      <a href="/docs/tools">
        <span>Artefacts DB ğŸº</span>
      </a>
    </li>
    
    <li class="menu-item-attacks db âš”ï¸">
      <a href="/docs/tools">
        <span>Attacks DB âš”ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-tools db ğŸ› ï¸">
      <a href="/docs/tools">
        <span>Tools DB ğŸ› ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-crypto ğŸ—ï¸">
      <a href="/docs/cryptography">
        <span>Crypto ğŸ—ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-about me ğŸ§ğŸ½â€â™€ï¸">
      <a href="/docs/about">
        <span>About me ğŸ§ğŸ½â€â™€ï¸</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo.png" /></a>
    </div>
    <div class="logo-mobile">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo-mobile.svg" /></a>
    </div>
    

    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home ğŸ¡">
      <a href="/">
        <span>Home ğŸ¡</span>
      </a>
    </li>
    
    <li class="menu-item-blog âœï¸">
      <a href="/docs/blog">
        <span>Blog âœï¸</span>
      </a>
    </li>
    
    <li class="menu-item-ttp ğŸ”">
      <a href="/docs/ttp">
        <span>TTP ğŸ”</span>
      </a>
    </li>
    
    <li class="menu-item-artefacts db ğŸº">
      <a href="/docs/tools">
        <span>Artefacts DB ğŸº</span>
      </a>
    </li>
    
    <li class="menu-item-attacks db âš”ï¸">
      <a href="/docs/tools">
        <span>Attacks DB âš”ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-tools db ğŸ› ï¸">
      <a href="/docs/tools">
        <span>Tools DB ğŸ› ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-crypto ğŸ—ï¸">
      <a href="/docs/cryptography">
        <span>Crypto ğŸ—ï¸</span>
      </a>
    </li>
    
    <li class="menu-item-about me ğŸ§ğŸ½â€â™€ï¸">
      <a href="/docs/about">
        <span>About me ğŸ§ğŸ½â€â™€ï¸</span>
      </a>
    </li>
    
  </ul>
</div>
    
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
    
    <div style="margin-left: 20pt;">
      <a href="/index.xml" type="application/rss+xml">
        <img src="/images/rss.png" alt="RSS Feed">
      </a>
    </div>
    
    <style>
      a[href="/index.xml"] {
        display: inline-block;
        vertical-align: middle;
        margin-right: 10px;
      }
    
      a[href="/index.xml"] img {
        height: 30px;
      }
    </style>
    
  </div>
</div>


    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <p>
   <a href="/docs/attacks/binary/exploits/bufferoverflow/"> ğŸ‘ˆğŸ¼ Back to </br> Buffer Overflow </a>
  </p>
  <aside>
   <nav id="TableOfContents">
  <ul>
    <li><a href="#mechanics">Mechanics</a></li>
    <li><a href="#exploitation-steps">Exploitation Steps</a>
      <ul>
        <li><a href="#-rtfm">ğŸ“• RTFM</a></li>
      </ul>
    </li>
    <li><a href="#mitigation">Mitigation</a>
      <ul>
        <li><a href="#check-the-boundaries">Check the boundaries</a></li>
        <li><a href="#stack-canaries-">Stack canaries ğŸ¥</a>
          <ul>
            <li><a href="#bypass-techniques">Bypass Techniques</a></li>
          </ul>
        </li>
        <li><a href="#dep">DEP</a>
          <ul>
            <li><a href="#bypass-techniques-1">Bypass Techniques</a></li>
          </ul>
        </li>
        <li><a href="#aslr--pie">ASLR &amp; PIE</a>
          <ul>
            <li><a href="#bypass-techniques-2">Bypass Techniques</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
 </aside>
</div>



          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">Overview</h1>
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    <div class="meta">
      
      
      <div class="article-category">
          
            
            
            
            
            
              <i class="fab fa-linux"></i>&nbsp;<i class="fab fa-apple"></i>&nbsp;<i class="fab fa-windows"></i>&nbsp;<i class="fas fa-mobile"></i>
            
            
          
          
      </div> <br />
      

      
      

      
      <div class="article-tag">
          <i class="fas fa-tag"></i>
          
          
          <a class="tag-link" href="/tags/reverse" rel="tag">reverse</a>
          
      </div> 
      
    </div>
    
    <b>Created:</b> 27.09.2020
    <br />

    

  </header>


  <div class="content" itemprop="articleBody">
    <p><em>The idea of a buffer overflow attack is quite simple, though the implementation might initially be difficult to digest. I am exploring this notion and visualising it in this article.</em> <!-- raw HTML omitted --></p>
<h2 id="mechanics">Mechanics</h2>
<p>Imagine you have a job you don&rsquo;t really like (I think most of us have had such an experience at least once in our life ğŸ˜¢). And also, imagine that you are being highly underpaid. Your job is simple and ridiculous: place rabbits ğŸ‡ into one set of boxes and foxes ğŸ¦Š - into another. You happen to have 6 boxes ğŸ“¦ğŸ“¦ğŸ“¦ğŸ“¦ğŸ“¦ğŸ“¦ for foxes ğŸ¦Š and 4 ğŸ“¦ğŸ“¦ğŸ“¦ğŸ“¦ for rabbits ğŸ‡. However, you were given 4 rabbits ğŸ‡ğŸ‡ğŸ‡ğŸ‡ and 7 foxes ğŸ¦ŠğŸ¦ŠğŸ¦ŠğŸ¦ŠğŸ¦ŠğŸ¦ŠğŸ¦Š. So, one fox ğŸ¦Š doesn&rsquo;t have its fox box ğŸ“¦. However, there are also rabbit ğŸ‡ boxes ğŸ“¦ right nearby. So, even though you were explicitly told not to place foxes into rabbit boxes and vice versa since you don&rsquo;t give a shit, you put a fox into a rabbit fox. What happens? One can only guess&hellip; ğŸ¤”. Long story short: the fox eats the rabbit, and now you have 7 foxes and only 3 rabbits ğŸ‡. Alas! If only you&rsquo;d followed the manual ğŸ“–&hellip;. Most likely, one would get fired after such a mistake, but we can&rsquo;t fire the compiler, so that would happen if the developer was not using a memory-safe language or wasn&rsquo;t careful enough. Now, to the technicalities.</p>
<p>Below is a short example of such a vulnerability in code (C language). Let&rsquo;s read it line by line and understand the mechanics.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//init two arrays (buffers), 4 bytes for rabbits and 6 bytes for foxes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">char</span> <span class="n">rabbit_boxes</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">foxes_boxes</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">//put 4 rabbits into rabbit boxes and 6 foxes into foxes boxes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">strcpy</span><span class="p">(</span><span class="n">rabbit_boxes</span><span class="p">,</span> <span class="s">&#34;rrrr&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">strcpy</span><span class="p">(</span><span class="n">foxes_boxes</span><span class="p">,</span> <span class="s">&#34;ffffff&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">//print the contents of these two arrays in memory before buffer overflow occurs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[BEFORE] Foxes boxes are at %p and contain %s&#34;</span><span class="p">,</span> <span class="n">foxes_boxes</span><span class="p">,</span> <span class="n">foxes_boxes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[BEFORE] Rabbit boxes are at %p and contain %s&#34;</span><span class="p">,</span> <span class="n">rabbit_boxes</span><span class="p">,</span> <span class="n">rabbit_boxes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">//if the length of the argv[1] exceeds the size of the foxes boxes array, you&#39;ll have your overflow. Some amount of rabbits in rabbit boxes will be &#34;overflown&#34;, i.e. eaten
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[STRCPY] Putting %d foxes (bytes) into foxes boxes&#34;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">//print the contents of these two arrays in memory after and if buffer overflow occurs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[AFTER] Foxes boxes are at %p and contain %s&#34;</span><span class="p">,</span> <span class="n">foxes_boxes</span><span class="p">,</span> <span class="n">foxes_boxes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[AFTER] Rabbit boxes are at %p and contain %s&#34;</span><span class="p">,</span> <span class="n">rabbit_boxes</span><span class="p">,</span> <span class="n">rabbit_boxes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The above example is just a technical representation of the story at the beginning of this article.</p>
<p>A stack is a data structure and an area in memory that stores local variables, arguments, return addresses, return values, and frame stack pointers. It&rsquo;s also used to save data temporarily. When a function calls another function, the caller&rsquo;s data (registry data, EIP and EBP) is temporarily stored in the stack until the callee returns.</p>
<p>Let&rsquo;s assume we have a cruel <code>kill_rabbit</code> ğŸ‡ function:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">kill_rabbit</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">rabbit_names</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">  <span class="n">strcpy</span><span class="p">(</span><span class="n">rabbit_names</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">kill_rabbit</span><span class="p">(</span><span class="s">&#34;VeryLongRabbitNameThatWillOverflowBuffer&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;The rabbit is alive and will eat all your carrots ğŸ¥•</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;You&#39;ve killed the rabbit! The ğŸ¥•s are saved. Was it worth it?</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>At the moment of the function call, the stack is arranged in the following way:</p>
<p><img src="images/stack-kill-rabbit.png" alt="img">
But what if the fox ğŸ¦Š still wants to kill Roger ğŸ‡? How to help him? If the fox types a long name of a rabbit, like, <code>IHateThisRabbitIHateThisRabbitIHateThisRabbitIHateThisRabbitIHateThisRabbitIHateThisRabbitIHateThisRabbitDieRabbitDieDieRabbitDieDieRabbitDieDieRabbitDieDieRabbitDieDieRabbitDieDieRabbitDie</code>, the <code>strcpy</code> function will still copy this name to the buffer. And here are two problems from the ğŸ‡ perspective:</p>
<ol>
<li><code>strcpy</code> function does what it says and trusts the user entirely. It does not check the length of the provided input before copying it. It will continue copying character by character until it sees an end of the string symbol, usually a null byte <code>/0x00</code>.</li>
</ol>
<p><img src="https://media.giphy.com/media/8oozhYtChXKC1qasiA/giphy.gif" alt="img">
4. The second problem is that the buffer is on the stack alongside other data, including our return address. At some point, the <code>strcpy</code> will overwrite something valuable. The trick is to find out the exact length of the string needed to</p>
<h2 id="exploitation-steps">Exploitation Steps</h2>
<ul>
<li><input disabled="" type="checkbox"> Identify a buffer to overflow.</li>
<li><input disabled="" type="checkbox"> Find a value you want to overflow.</li>
<li><input disabled="" type="checkbox"> Â Calculate the distance in bytes between the buffer and the value:
<ul>
<li><input disabled="" type="checkbox"> <code>msf-pattern create -l 1400</code> (to generate an excessively long string of random characters). For example, we have developed a string, and some portion of it contained <code>[...]lksdjfk[...]</code>.</li>
<li><input disabled="" type="checkbox"> Look at the value of the registry or other buffer that is the target of BO. Translate the hex to ASCII and search this sequence in the above-generated string. Let&rsquo;s say we see the <code>EIP</code> registry set to <code>0x73646a66</code>, which in ASCII is <code>sdjf</code>.</li>
<li><input disabled="" type="checkbox"> Find the exact offset of the substring above within the string: <code>msf-pattern_offset -q 73646a66</code>.</li>
</ul>
</li>
</ul>
<h3 id="-rtfm">ğŸ“• RTFM</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">  x/s buffer <span class="c1"># represents the value at buffer as a string</span>
</span></span><span class="line"><span class="cl">  x/x value <span class="c1"># represents the value as a hex integer 4 bytes long</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  print <span class="p">&amp;</span>value - <span class="p">&amp;</span>buffer <span class="o">(</span>or <span class="p">&amp;</span>buffer - <span class="p">&amp;</span>value<span class="o">)</span> <span class="c1"># for arithmetic operation</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  x/16xw buffer <span class="c1"># print 16 words starting from the beginning of the buffer</span>
</span></span></code></pre></div><h2 id="mitigation">Mitigation</h2>
<p>How does one stop vulnerabilities of this type? How do we save the rabbit ğŸ‡?</p>
<h3 id="check-the-boundaries">Check the boundaries</h3>
<p>The first problem was that strcpy did not check if the data fit into the buffer. The solution is simple - check! In other words, use the function that does or implements that check on the interpreter&rsquo;s or compiler&rsquo;s level.</p>
<h3 id="stack-canaries-">Stack canaries ğŸ¥</h3>
<p>Stack canaries are an integrity check mechanism.</p>
<p>There are several types of canaries:</p>
<ol>
<li>XOR random</li>
<li>random</li>
<li>null</li>
<li>terminator ğŸ¦¾</li>
<li>64-bit</li>
<li>custom</li>
</ol>
<p>Most canaries start with a null byte. That prevents some buffer overflow attacks, since it&rsquo;s a tricky business to write several null bytes to a location, the string ends with the first one. Other null bytes will be discarded. However, some functions can still write several null bytes to memory (<code>read</code>, for example).</p>
<p>It&rsquo;s still a practised technique, but in the past, miners would use a canary to determine if a mine was safe to enter. They would release a canary into the mine and observe if it would return. It was indeed a cruel method, and I acknowledge that. However, this is the historical origin of the term.</p>
<p>It means that we put some random value on the stack and keep a copy of it in some safe place. Before the function returns and passes the torch ğŸ—½ to the calling function. The CPU then can check that the data is not corrupted by comparing the value on the stack and someplace safe. Look at the following picture:</p>
<p><img src="images/stack-overflown-canary.png" alt="img">
First, look at the picture on the left. This is what the stack looks like when all is in order, nothing is overflown, and the rabbits ğŸ‡ are safe. The canary value goes between the local variables that are potentially dangerous and the data we are trying to protect. Now, look at the picture on the right. The buffer was overflown, corrupting the EBP and EIP saved on the stack, and also the canary ğŸ¥. When the CPU checks this canary value, it doesn&rsquo;t match the one it remembers, and an exception can be raised.</p>
<p><img src="https://media.giphy.com/media/znstOyoW1SEP5u7pdy/giphy.gif" alt="img"></p>
<p>Since the value of the canary ğŸ¥ is random, you won&rsquo;t be able to overwrite the buffer so that the canary remains intact. How to circumvent it, then?</p>
<h4 id="bypass-techniques">Bypass Techniques</h4>
<ol>
<li>Recompile the executable without the canary flag set.</li>
<li>See if there is a way to guess/calculate the canary&rsquo;s value.</li>
<li>Use another vulnerability (memory leak) to see the canary value, for example, format strings.</li>
<li><strong>Brute force</strong>. Less feasible for 64-bit systems but for 32-bit systems. One byte (8 bits) is reserved for the null byte. So, we have only 24 bits to guess. In the worst-case scenario, it would take 2^24 guesses to get the correct value (some compilers use the same canary during execution.</li>
<li>Overwrite the values, overwrite the SEH AND trigger an exception before the canary is checked.  # Binary Exploit Development - SEH Based Overflow <a href="https://www.youtube.com/@GuidedHacking">SEH Exploit</a></li>
</ol>
<h3 id="dep">DEP</h3>
<p>DEP stands for Data Execution Prevention and is a flag that marks some regions as non-executable. For example, stack and heap are not supposed to contain code, only data. Something is only executed from the stack or heap when something malicious occurs. It only makes sense that the data is locked for execution.</p>
<h4 id="bypass-techniques-1">Bypass Techniques</h4>
<ol>
<li><strong>ROP</strong> - return-oriented programming.</li>
<li><code>WriteProcessMemory</code></li>
<li><code>VirtualAlloc</code> <a href="https://www.youtube.com/watch?v=phVz8CqEng8">https://www.youtube.com/watch?v=phVz8CqEng8</a></li>
</ol>
<h3 id="aslr--pie">ASLR &amp; PIE</h3>
<p>ASLR stands for Address Space Layout Randomisation (ASLR). PIE stands for Position Independent Executables.</p>
<p>If you haven&rsquo;t already, I suggest reading about memory addressing <a href="https://bakerst221b.com/docs/reverse/basics/memory-addressing/">here</a>. In short, when a program is loaded into memory, it has specific preferred base addresses for different sections of the program (code, stack, heap). Without ASLR, these base addresses are usually the same and therefore predictable. This is why carrying out buffer overflow attacks can be easier when you know where things are. ASLR removes this advantage from the attacker. However, it doesn&rsquo;t mean that it completely eliminates buffer overflow attacks; it just makes them harder to execute.</p>
<p>PIE is the feature of an executable that makes it work when ASLR is enabled. Without PIE a program would not be able to run and would likely crush or would not even be able to launch.</p>
<h4 id="bypass-techniques-2">Bypass Techniques</h4>
<ol>
<li><strong>Brute-force</strong>. Obviously, We have limited number of addresses and we still need to maintain the general memory layout. So, the chances are at some point you&rsquo;ll guess. Would you try?</li>
<li><strong>Information leaks</strong>. Format string vulnerabilties can be leveraged to leak the addresses and help calculate the offsets and base.</li>
<li><strong>ROP</strong>. More about it later.</li>
<li><strong>NOP sled or JOP</strong> (jump-oriented programming).</li>
</ol>
<h2 id="references">References</h2>
<details>
    <summary>Expand&hellip;</summary>
    <p>Hacking: the Art of Exploitation, J. Ericson
<a href="https://www.sans.org/blog/stack-canaries-gingerly-sidestepping-the-cage/">https://www.sans.org/blog/stack-canaries-gingerly-sidestepping-the-cage/</a>
<a href="https://book.hacktricks.xyz/reversing-and-exploiting/linux-exploiting-basic-esp/bypassing-canary-and-pie">https://book.hacktricks.xyz/reversing-and-exploiting/linux-exploiting-basic-esp/bypassing-canary-and-pie</a></p>
<p><a href="https://www.youtube.com/watch?v=8kYTDK9oKV8">https://www.youtube.com/watch?v=8kYTDK9oKV8</a> - bypass DEP with WriteProcessMemory
<a href="https://www.youtube.com/watch?v=phVz8CqEng8">https://www.youtube.com/watch?v=phVz8CqEng8</a> - bypass DEP with VirtualAlloc</p>

</details>

  </div>
</article>
</div>
</div>

        </div>
      </div>
    </div>
    
  </div>

  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            <li class="zerostatic"><a href="https://www.zerostatic.io">www.zerostatic.io</a></li>
            </ul>
        </div>
      </div>
    </div>
  </div>
</div>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.302a6fc365d5139fb98cf60bdb8f715d96257ea189161d36c190ccfa8182e569.js"></script>
  

  
  
  
    
  


</body>

</html>
