<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>File Systems - Analyst</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://bakerst221b.com/favicon.png">
  <link href="/css/style-classic.css"></link>
  
  
  <link rel="stylesheet" href="/css/style.min.9d91cbb32c96c334ae7b38c3d99d30727e0836e1182125cc5f007d215f0b9e59.css">
  

  

</head>

<body class='page page-default-single'>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-home 🏡">
      <a href="/">
        <span>Home 🏡</span>
      </a>
    </li>
    
    <li class="menu-item-blog ✍️">
      <a href="/docs/blog">
        <span>Blog ✍️</span>
      </a>
    </li>
    
    <li class="menu-item-forensics 🔍 and incident response 🥷">
      <a href="/docs/dfir">
        <span>Forensics 🔍 and Incident Response 🥷</span>
      </a>
    </li>
    
    <li class="menu-item-crypto 🗝️">
      <a href="/docs/cryptography">
        <span>Crypto 🗝️</span>
      </a>
    </li>
    
    <li class="menu-item-reverse 🔧">
      <a href="/docs/reverse">
        <span>Reverse 🔧</span>
      </a>
    </li>
    
    <li class="menu-item-toolkit 🧰">
      <a href="/docs/toolkit">
        <span>Toolkit 🧰</span>
      </a>
    </li>
    
    <li class="menu-item-about me 🧝🏽‍♀️">
      <a href="/docs/about">
        <span>About me 🧝🏽‍♀️</span>
      </a>
    </li>
    
    <li class="menu-item-tech reference 📚">
      <a href="/docs/reference">
        <span>Tech Reference 📚</span>
      </a>
    </li>
    
    <li class="menu-item-notes 📝">
      <a href="/docs/notes">
        <span>Notes 📝</span>
      </a>
    </li>
    
  </ul>
</div>
  <div class="wrapper">
    <div class='header'>
  <div class="container">
    <div class="logo">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo.svg" /></a>
    </div>
    <div class="logo-mobile">
      <a href="https://bakerst221b.com"><img alt="Logo" src="/images/logo-mobile.svg" /></a>
    </div>
    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-home 🏡">
      <a href="/">
        <span>Home 🏡</span>
      </a>
    </li>
    
    <li class="menu-item-blog ✍️">
      <a href="/docs/blog">
        <span>Blog ✍️</span>
      </a>
    </li>
    
    <li class="menu-item-forensics 🔍 and incident response 🥷">
      <a href="/docs/dfir">
        <span>Forensics 🔍 and Incident Response 🥷</span>
      </a>
    </li>
    
    <li class="menu-item-crypto 🗝️">
      <a href="/docs/cryptography">
        <span>Crypto 🗝️</span>
      </a>
    </li>
    
    <li class="menu-item-reverse 🔧">
      <a href="/docs/reverse">
        <span>Reverse 🔧</span>
      </a>
    </li>
    
    <li class="menu-item-toolkit 🧰">
      <a href="/docs/toolkit">
        <span>Toolkit 🧰</span>
      </a>
    </li>
    
    <li class="menu-item-about me 🧝🏽‍♀️">
      <a href="/docs/about">
        <span>About me 🧝🏽‍♀️</span>
      </a>
    </li>
    
    <li class="menu-item-tech reference 📚">
      <a href="/docs/reference">
        <span>Tech Reference 📚</span>
      </a>
    </li>
    
    <li class="menu-item-notes 📝">
      <a href="/docs/notes">
        <span>Notes 📝</span>
      </a>
    </li>
    
  </ul>
</div>
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
  </div>
</div>


    
    
    
    
    
    

    
    <div class="container pt-2 pt-md-6 pb-3 pb-md-6">
      <div class="row">
        <div class="col-12 col-md-3 mb-3">
          <div class="sidebar">
            
<div class="docs-menu">
  <p>
   <a href="/docs/reference/"> Back to 📚 Technical Reference Section 👈🏼 </a>
  </p>
  <aside>
   <nav id="TableOfContents">
  <ul>
    <li><a href="#file-systems-overview">File Systems Overview</a>
      <ul>
        <li><a href="#data-structures-and-flags">Data structures and Flags</a></li>
        <li><a href="#bootcode-and-booting-process">Bootcode and Booting Process</a></li>
        <li><a href="#posix">POSIX</a></li>
      </ul>
    </li>
    <li><a href="#fat">FAT</a>
      <ul>
        <li><a href="#versions">Versions</a>
          <ul>
            <li><a href="#fat12">FAT12</a></li>
            <li><a href="#fat16">FAT16</a></li>
            <li><a href="#fat32">FAT32</a></li>
            <li><a href="#exfat">ExFAT</a></li>
          </ul>
        </li>
        <li><a href="#fat-structure">FAT Structure</a>
          <ul>
            <li><a href="#volume-boot-record">Volume Boot Record</a></li>
            <li><a href="#root-directory">Root Directory</a></li>
            <li><a href="#directories-not-root">Directories (not Root)</a></li>
            <li><a href="#file-allocation-table-fat">File Allocation Table (FAT)</a></li>
          </ul>
        </li>
        <li><a href="#timestamps">Timestamps</a></li>
        <li><a href="#fat-file-creation-and-deletion">FAT File Creation And Deletion</a>
          <ul>
            <li><a href="#creating">Creating</a></li>
            <li><a href="#deleting">Deleting</a></li>
          </ul>
        </li>
        <li><a href="#exfat-structure">exFAT Structure</a>
          <ul>
            <li><a href="#boot-record">Boot Record</a></li>
            <li><a href="#fat1">FAT1</a></li>
            <li><a href="#root-directory-1">Root Directory</a></li>
            <li><a href="#additional-files">Additional Files</a></li>
          </ul>
        </li>
        <li><a href="#timestamps-1">Timestamps</a></li>
        <li><a href="#exfat-file-creation-and-deletion">exFAT File Creation and Deletion</a>
          <ul>
            <li><a href="#creation">Creation</a></li>
            <li><a href="#deletion">Deletion</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#extx">ExtX</a>
      <ul>
        <li><a href="#2">2</a></li>
        <li><a href="#3">3</a></li>
        <li><a href="#4">4</a></li>
      </ul>
    </li>
    <li><a href="#reiserfs">ReiserFS</a></li>
    <li><a href="#xfs">XFS</a></li>
    <li><a href="#hfs">HFS</a></li>
    <li><a href="#hfs-1">HFS+</a></li>
    <li><a href="#apfs">APFS</a>
      <ul>
        <li><a href="#timestamps-2">Timestamps</a>
          <ul>
            <li><a href="#modified">Modified</a></li>
            <li><a href="#created">Created</a></li>
            <li><a href="#accessed">Accessed</a></li>
            <li><a href="#changed">Changed</a></li>
            <li><a href="#added">Added</a></li>
          </ul>
        </li>
        <li><a href="#metadata">Metadata</a>
          <ul>
            <li><a href="#fsevents">FSEvents</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#ntfs">NTFS</a>
      <ul>
        <li><a href="#versions-1">Versions</a>
          <ul>
            <li><a href="#v10">V1.0</a></li>
            <li><a href="#v12">V1.2</a></li>
          </ul>
        </li>
        <li><a href="#structure">Structure</a>
          <ul>
            <li><a href="#volume-boot-record-1">Volume Boot Record</a></li>
            <li><a href="#mft">MFT</a></li>
          </ul>
        </li>
        <li><a href="#file-creation-and-deletion">File Creation and Deletion</a>
          <ul>
            <li><a href="#creating-files">Creating Files</a></li>
            <li><a href="#deleting-files">Deleting Files</a></li>
          </ul>
        </li>
        <li><a href="#timestamps-3">Timestamps</a></li>
        <li><a href="#ntfs-metadata">NTFS Metadata</a>
          <ul>
            <li><a href="#extendusnjrnl"><code>\$Extend\$UsnJrnl</code></a></li>
            <li><a href="#logfile"><code>$LogFile</code></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
 </aside>
 </div>



          </div>
        </div>
        <div class="col-12 col-md-9">
          
<h1 class="title">File Systems</h1>
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    <div class="meta">
      
      <div class="article-category">domain: 
          
              
                <i class="fas fa-archive"></i>
              
          <a class="category-link" href="/domain/general">general</a>
          
      </div> <br />
      
      <div class="article-category">doctype:
          
            
              
                <i class="fa fa-graduation-cap"></i>
              
          <a class="platform-link" href="/doctype/article">article</a>
          
      </div> <br /><br/>
      
      
      
      

      
      

      
    </div>
  </header>


  <div class="content" itemprop="articleBody">
    <h2 id="file-systems-overview">File Systems Overview</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Partition size (min/max)</th>
<th>Cluster size (min/max)</th>
<th>File Max Size</th>
<th><code>fstab</code> code</th>
</tr>
</thead>
<tbody>
<tr>
<td>FAT16</td>
<td>16Mb/2Gb</td>
<td>2Kb/32Kb</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FAT32</td>
<td>260Mb/32Gb 🔍</td>
<td>2Kb/32Kb</td>
<td></td>
<td></td>
</tr>
<tr>
<td>NTFS 1.1</td>
<td>500Mb/8Gb 🔍</td>
<td>512B/8Kb</td>
<td></td>
<td></td>
</tr>
<tr>
<td>NTFS 3.0</td>
<td>500Mb/16EB</td>
<td>512B/64Kb</td>
<td></td>
<td></td>
</tr>
<tr>
<td>HFS</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>HFS+</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>APFS</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ext2</td>
<td>16Tb</td>
<td></td>
<td>2Tb</td>
<td><code>ext2</code></td>
</tr>
<tr>
<td>ext3</td>
<td>16Tb</td>
<td></td>
<td>2Tb</td>
<td><code>ext3</code></td>
</tr>
<tr>
<td>ext4</td>
<td>1Eb</td>
<td></td>
<td>16Tb</td>
<td><code>ext4</code></td>
</tr>
<tr>
<td>ReiserFS</td>
<td>16Tb</td>
<td></td>
<td>8Tb</td>
<td><code>resiserfs</code></td>
</tr>
<tr>
<td>JFS</td>
<td>32Pb</td>
<td></td>
<td>4Tb</td>
<td><code>jfs</code></td>
</tr>
<tr>
<td>XFS</td>
<td>16Eb</td>
<td></td>
<td>8Eb</td>
<td><code>xfs</code></td>
</tr>
<tr>
<td>Btrfs</td>
<td>16Eb</td>
<td></td>
<td>16Eb</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Two entries marked with a🔍  are from M. Graves' book &ldquo;Digital Archeaology&rdquo; book. I have not found any other information about max partition size on NTFS 1.1 and FAT32 max partition size is claimed to be 2,048 Gb, which doesn&rsquo;t correlate with other resources.</p>
</blockquote>
<p>There are: file name, file metadata and the contents of the file itself. They are not in the same place. File metadata contains filename and also a ptr to the sector, where the file&rsquo;s contents starts and size of data. Theoretically, we could change the file metadata to make it point to another cluster&hellip; 🤔</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Cluster</th>
<th>size</th>
<th>last accessed</th>
</tr>
</thead>
<tbody>
<tr>
<td>malware.txt</td>
<td>654</td>
<td>80</td>
<td>October 13, 2020</td>
</tr>
</tbody>
</table>
<p><strong>Essential</strong> data - can be trusted and <strong>non</strong>-<strong>essential</strong> cannot. But if ptr to cluster is called essential data, how we can trust it? Well, it&rsquo;s much harder to tamper with.</p>
<p><a href="https://apple.stackexchange.com/questions/321406/extract-hfs-hfsx-volume-from-dmg-file">https://apple.stackexchange.com/questions/321406/extract-hfs-hfsx-volume-from-dmg-file</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">open <span class="o">[</span>path/to/dmg<span class="o">]</span>
dd <span class="k">if</span><span class="o">=</span><span class="s2">&#34;/dev/disk[number]&#34;</span> <span class="nv">of</span><span class="o">=</span><span class="s2">&#34;/extract/path/file.img&#34;</span>
fdisk -l file.img
dd <span class="k">if</span><span class="o">=</span><span class="s2">&#34;path/to/file.img&#34;</span> <span class="nv">bs</span><span class="o">=</span>sector_size <span class="nv">skip</span><span class="o">=</span>sectors <span class="nv">count</span><span class="o">=</span>sectors &gt;&gt; output.hfs
</code></pre></div><h3 id="data-structures-and-flags">Data structures and Flags</h3>
<p>First, there must be some data structure identifier so that the CPU could know, how to read the subsequent data. For example, if we have the following:</p>
<p><code>1001 1000 1001 1110 1010 1100 1000 101</code></p>
<p>For example, the first 4 bits <code>0101</code> tell the CPU that the next bits should be interpreted as an image. Then, for example, there are other 4 bits <code>0011</code> that are 4 flags. Flag is a 1-bit value, indicating either <code>true</code> or <code>false</code>, or either <code>exists</code> or <code>doesn't</code>. This are flags, for example, that indicate: wether it&rsquo;s black-and-white (<code>0</code>) or colored (<code>1</code>); wether the image is editable <code>1</code> or <code>0</code> etc. And then the file contents.</p>
<p>Consider the above binary sequence. To make it more compressed, convert it to hex: <code>4c 4f 56 45</code>. What is this? That depends. If you tell CPU that it&rsquo;s machine instructions, then it&rsquo;s see this:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">dec esp
dec edi
push esi
inc ebp
</code></pre></div><p>But what if you tell that it&rsquo;s text? Then CPU sees&hellip; check out <a href="https://www.rapidtables.com/convert/number/ascii-to-hex.html">here</a>.</p>
<h3 id="bootcode-and-booting-process">Bootcode and Booting Process</h3>
<h3 id="posix">POSIX</h3>
<p>There is a standard that&rsquo;s called POSIX and those FS that compliant are called POSIX-compliant. This standard demands certain fucntionality and properties from a FS: for example, for a file to have several names or hard links (❓), case sensitive file naming. <a href="#fat">FAT</a> or <a href="https://en.wikipedia.org/wiki/High_Performance_File_System">HPFS</a> are not POSIX compliant.</p>
<h2 id="fat">FAT</h2>
<p>Any FAT partition has two main parts: system area and data area. System area contains FAT boot record (every file system has a boot record), 1st FAT and 2nd FAT. FAT12 and FAT16 also have Root directory in the system area. Data area consists of Root directory in case of FAT32 and file and subdirectory data in clusters.</p>
<h3 id="versions">Versions</h3>
<h4 id="fat12">FAT12</h4>
<p>For the cluster addressing there were 12 bits available, which is 2^12 clusters at most (4096 clusters).</p>
<h4 id="fat16">FAT16</h4>
<p>For the cluster addressing there were 16 bits available, which is 2^16 clusters at most (65536 clusters).</p>
<h4 id="fat32">FAT32</h4>
<p>For the cluster addressing there were 28 bits available (not 32), which is 2^28 clusters at most (268 435 456 clusters). 4 bytes were reserved. Unlike in FAT12 and FAT16 the Root directory is in the data area, giving more space for data.</p>
<h4 id="exfat">ExFAT</h4>
<p>Uses all 32 bits for cluster addressing. Thus, the maximum number of clusters is 2^32 which gives us 4 294 967 296 clusters to call. First supported by Windows CE 2006. Max volume size was 64 zettabytes ❓. File size limit - 16 exabytes ❓. Cross-platform. Used for large external media.</p>
<h3 id="fat-structure">FAT Structure</h3>
<h4 id="volume-boot-record">Volume Boot Record</h4>
<blockquote>
<p>⚠️ Not the MBR!!!!</p>
</blockquote>
<p>Located at sector 0 of the volume (❗️ not the physical sector 0). Starts with a jump instruction 3 bytes long at offset <code>0x0</code> (relative to VBR). Contains information about the volume (offset relative to the VBR start - size - name - description). Relevant information below:</p>
<ul>
<li><code>0x3</code> - 8 - <strong>OEM ID</strong>. Most likely MS-DOS5.0 for Win2000 and above.</li>
<li><code>0x0B</code> - 2- <strong>Bytes per sector</strong> (512 usually)</li>
<li><code>0x0D</code> - 1 - <strong>Sectors per cluster</strong></li>
<li><code>0x0E</code> - 2 - <strong>Reserved sectors</strong></li>
<li><code>0x10</code>  - 1 - <strong>Number of FATs</strong> (2, one of them is for backup purposes)</li>
<li><code>1C</code> - 4 - <strong>Hidden sectors</strong> 🙈 (preceding the volume)</li>
<li><strong>Total sectors</strong> (size of the volume)</li>
<li><code>0x16</code> - 2 - <strong>Sectors per FAT</strong> (FAT12 and 16)</li>
<li><code>0x24</code> - 4 - <strong>Sectors per FAT</strong> (FAT32)</li>
<li><code>0x2C</code> - 4 - <strong>Starting cluster of the root</strong> dir (2nd usually)</li>
<li><code>0x32</code> - 2 - <strong>Back-up boot sector</strong> location (6th usually)</li>
<li><code>0x43</code> - 4 - <strong>Volume serial number</strong>. In case of thumbdrive, this serial number can be used to track the device across the PC and other systems.</li>
<li><code>0x47</code> - 11 - <strong>Volume name/label</strong> 🏷 (not user defined, &ldquo;NONAME&rdquo; usually)</li>
<li><code>0x52</code> - 8 - <strong>FS type</strong></li>
</ul>
<p>Here is the full information available:</p>
<p><img src="images/fat-boot-struct.png" alt="fat-boot-struct"></p>
<h4 id="root-directory">Root Directory</h4>
<p>The name speaks for itself. It&rsquo;s the highest node in the dir structure of this volume, consists of 32 byte dir entries. Lists files and dirs in the root directory. FS stops reading these entries when it sees anything starting with <code>0x0</code>. So, data written here won&rsquo;t be seen by the OS and this is one of the ways to hide data. Types of root dir entries:</p>
<ul>
<li>
<p>volume name (user created)</p>
</li>
<li>
<p>short file name (8 uppercase letters + &ldquo;.&rdquo; + 3 letters for extension)</p>
<ul>
<li>
<p>8 bytes for the file name (uppercase), always includes a <code>~</code> at the -2 offset.</p>
</li>
<li>
<p>3 bytes for extension</p>
</li>
<li>
<p>1 byte for attributes (hidden (<code>0x02</code>), read-only (<code>0x01</code>), system (<code>0x04</code>), volume label (<code>0x08</code>), directory (<code>0x10</code>) and archive (<code>0x20</code>)). These attributes can be combined. Flags occupy just one byte and when there are more than one flag, their values are combined (like the access flags on Unix systems). See the attributes on the picture below. Only the bit for <code>volume</code> is set, which, given its position, has the value <code>0x08</code>.</p>
<p><img src="images/fat-short-attr.png" alt="fat-short-attr"></p>
</li>
<li>
<p>1 reserved byte - <code>0x00</code> for the long file name (not-8.3 compliant) and <code>0x10</code> for short file name (8.3 compliant) [<a href="https://www.coursera.org/learn/windows-os-forensics/home/welcome">5</a>]. In my case, however, it was always <code>0x00</code>.</p>
</li>
<li>
<p>1 byte for created time in 10 milliseconds</p>
</li>
<li>
<p>4 bytes for created date and time. See how the data is converted in the Timestamps section below.</p>
</li>
<li>
<p>Two bytes for Last accessed date (⚠️ no time!)</p>
</li>
<li>
<p>Pointer to the first cluster of the file/directory (high word). If the file is somewhere close to the disk start, it will be equal to <code>00 00</code>.</p>
</li>
<li>
<p>Four bytes for modified date and time</p>
</li>
<li>
<p>Pointer to the first cluster of the file/directory (low word).</p>
</li>
<li>
<p>Four bytes for the file size in bytes. ⚠️ It&rsquo;s always <code>00 00 00 00</code> for directories!!!</p>
</li>
</ul>
</li>
<li>
<p>long file name. Can consist of several entries (each 32-bits). If the file name is more than 8 characters, there will be more than one long entry. These are called a <em>set</em>. The last one contains the last characters + extension.</p>
<ul>
<li>1 byte for a status byte. When the entry is the last in the set (1 set for each file), its sequence number starts with <code>4</code>. Otherwise, it indiacates the entries number.</li>
<li>10 bytes for the file name (Unicode chars), i.e. for 5 characters of the name since one Unicode character occupies 2 bytes. If the file name is not long enough, unused bytes are filled with <code>0xFF</code>.</li>
<li>1 byte that&rsquo;s always <code>0x0F</code> and indicates a long file name.</li>
<li>1 byte reserved. In case it&rsquo;s <code>0x00</code> - it&rsquo;s a long file name. If it&rsquo;s <code>0x10</code> - short file name. So, along with the previous byte it can be used to determine that&rsquo;s the long name entry [<a href="https://www.coursera.org/learn/windows-os-forensics/home/welcome">5</a>]. In my case, however, it was always <code>0x00</code>.</li>
<li>1 byte for error correction (checksum)</li>
<li>12 bytes for the next part of the file name (6 Unicode characters). If the file name is not long enough, unused bytes are filled with <code>0xFF</code>.</li>
<li>2 bytes of zeroes</li>
<li>4 bytes for the next part of the file name (2 Unicode characters). If the file name is not long enough, unused bytes are filled with <code>0xFF</code>.</li>
</ul>
</li>
</ul>
<p>See below the example of a long entry <em>set</em> for a file with the name <code>asdjasdlkjasldkjsalkdaskljdjaljdajd.txt</code>. The lowest part - the short file name. Then there are three long file name entries. The first byte in the yellow area is <code>0x01</code>, meaning, it&rsquo;s the first entry in the set. The next (green one), has the first byte (sequence byte) set to <code>0x02</code>, indicating it&rsquo;s the second entry in the set.The last one (on the top, colored in red) has the status byte <code>0x43</code>. The first nibble (<code>4</code>) indicates that this is the last long entry in the set. The second nibble (<code>3</code>) is the sequence number.</p>
<p><img src="images/fat-long-fragmented.png" alt="fat-long-fragmented"></p>
<p>If the entry is a folder, its size will be <code>00 00 00 00</code> (the last 4 bytes). In its short file name entry find the first cluster, go this cluster and you&rsquo;ll see another list of files but that are in this folder. Find the entry for the file you are looking for.</p>
<p><strong>FAT high word</strong>. Start at 65536 and continue as power of two.</p>
<p><em>❓ Hot to get there?</em></p>
<p>From the FAT32 Boot Record get the following information:</p>
<ul>
<li><input disabled="" type="checkbox"> bytes per sector (2 bytes at offset <code>0x0B</code>) - marked with orange 🍊</li>
<li><input disabled="" type="checkbox"> sectors per cluster (1 byte at offset <code>0x0D</code>) - marked with green 🍏</li>
<li><input disabled="" type="checkbox"> number of reserved sectors  (2 bytes at offset <code>0x0E</code>) - marked with dark blue 🫐</li>
<li><input disabled="" type="checkbox"> number of FATs  (one byte at offset <code>0x10</code>) - marked with coral 🦞</li>
<li><input disabled="" type="checkbox"> sector per FAT (four bytes ar offset <code>0x24</code>) - marked with blue 🌊</li>
</ul>
<p>All this information is needed to get the offset to the start of data area (in sectors!!!!). Since root directory is the first in the data area (FAT32 only), this will give us what we are looking for. Root directory is usually at the 2nd cluster <strong>relative to the start of the VBR</strong>, but better check at the offset <code>0x2C</code> (keep in mind the endianness). Then, we need to calculate the number of bytes to the data area/root directory.</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="p">(</span><span class="n">number_of_FATs</span> <span class="o">*</span> <span class="n">sectors_per_fat</span><span class="p">)</span> <span class="o">+</span> <span class="n">reserved_sectors</span>
</code></pre></div><p>Here is an example:</p>
<p><img src="images/fat32-root-dir-find.png" alt="fat32-root-dir-find"></p>
<p>The values on the right pane represent raw data in hex, and on the left - its human-readable interpretation by Active@Disk Editor using a FAT32 Boot Record template. We get the value at <code>0x0B</code> which is <code>0x200</code> (when coverted to little-endian) and which equals 512 in decimal (marked in red). These are <strong>bytes per sector</strong> 🍊.</p>
<p>We then go to offset <code>0x0D</code> which is <code>0x8</code> and 8 in decimal (marked in green). That&rsquo;s <strong>sectors per cluster</strong> 🍏. Reading at offset <code>0x0E</code> 🫐 I get the <strong>number of reserved sectors</strong> (4110 in decimal). The <strong>number of FATs</strong> 🦞 is 2 (standard for FAT32) at offset <code>0x10</code> and the <strong>number of sectors per FAT</strong> 🌊 is 2041 in decimal.</p>
<p>Let&rsquo;s use the data in the formula: <code>(2 * 2041) + 4110 = 8192</code>. This is the starting sector of data area and usually it&rsquo;s the same with the root directory. Now, to get the numbrer of bytes to this root directory, we need to multiply <code>8192</code> by bytes per sector (512) = 4194304 in decimal (<code>0x400000</code> in hex). Our VBR starts at <code>0x00010000</code> in hex or <code>65536</code> in decimal. Adding 4194304 to 65536 (or <code>0x400000</code> to <code>0x10000</code>) will give us the offset to root directory from the start of VBR ( ⚠️ not GUID/MBR header). This value is 4259840 (<code>0x410000</code>). Let&rsquo;s go there in hex editor or if you are using Active@Disk Editor, using <strong>Go to offset</strong> button on the top pane. Voila!</p>
<p><img src="images/fat32-root-found.png" alt="fat32-root-found"></p>
<p>You may ask, what&rsquo;s the use of this information (knowing exactly how to find the offset of the root directory). There might be cases when we need to perform manual file recovery using a hex editor (remember, Active@Disk Editor is for Windows and Linux only) or with limited tools. Also, I find it useful to understand what the tool does, since tools fail too sometimes, as well as humans. We need to verify each other from time to time.</p>
<blockquote>
<p>❓ One question that remains for me here: why the hell is the root cluster <code>0x2</code>? The second cluster is <code>2 * (8 * 512) = 8192</code> bytes away from the VBR start and there is no root dir there. However, when clicking on the field in Active@Disk Editor, you&rsquo;ll get to the root dir.</p>
</blockquote>
<h4 id="directories-not-root">Directories (not Root)</h4>
<p>Entries for directories have <code>00 00 00 00</code> as file size, <code>0x10</code> as attributes value and <code>20 20 20</code> as extension. They point to some location, where files are listed. So, basically, a folder is just a pointer.</p>
<p>Root directory is the first in the tree, but not the only one. Each directory on the drive will have its own &ldquo;<em>table of contents</em>&rdquo; and its structure is a little different. It also consists of file name entries, each - 32 bytes long for FAT32.</p>
<p>The first 32 bytes start with a <code>0x2E</code> byte (<code>.</code> in ASCII). The rest of the information has the same structure as an ordinary SFN (short file name). In this case, about this directory itself.</p>
<p>The next 32 bytes start with a double <code>0x2E</code> byte (<code>.</code> in ASCII), i.e. <code>..</code>. The first cluster number would be <code>00 00</code> if the parent is the root directory. The rest of the information has the same structure as an ordinary SFN (short file name). In this case, about the parent directory.</p>
<blockquote>
<p>🗒 If you are using a Terminal or console or PowerShell and <code>cd</code> somewhere from time to time, these both entries are not mysterious for you. For those who are not - <code>.</code> denotes the current directory, <code>..</code> the parent one. For example, you have the following folder structure:</p>
<ul>
<li>root
<ul>
<li>folder1
<ul>
<li>folder4 <code>&lt; current directory</code></li>
</ul>
</li>
<li>folder2
<ul>
<li>folder5
<ul>
<li>folder6</li>
</ul>
</li>
</ul>
</li>
<li>folder3</li>
</ul>
</li>
</ul>
<p>If we opened folder4, the value of <code>.</code> (current directory) is the address of folder4. While remaining in this folder, <code>..</code> (parent directory) for folder4 is folder1. <code>..</code> (parent directory) for folder1 is root. So,</p>
</blockquote>
<h4 id="file-allocation-table-fat">File Allocation Table (FAT)</h4>
<p>Keeps track of clusters in use and free ones. There are FAT1 and FAT2 (the same). FAT2 for backup. Both are located in the system area. Also, singly-linked list, each entry points to the next cluster of a file (in case a file is fragmented, i.e. occupies more than one cluster). <code>0x00000000</code> - the cluster is free, <code>0xffffff0f</code> - end of file, then pointer to the next cluster (if any).</p>
<p>The first four bytes in the FAT32 (two bytes in FAT12 and FAT16) is the media descriptor (<code>0xF8FFFFFF</code>, usually indicates a fixed disk). The next four bytes are for the FAT type (<code>0xFFFFFFFF</code> in case of FAT32). Then each four bytes tell us about each cluster ordered sequencially, i.e. CL-2 (contains the root directory in FAT32), then CL-3, then CL-4 etc. It can have three possible values: <code>0x00000000</code> - if the cluster is free, <code>0xffffff0f</code> - if the cluster is the last in the chain (end of file, EOF marker) or a pointer to the next cluster (if any, convert to little-endian and then to decimal to find it).</p>
<p>🛠 Using Active@Disk Editor, press <code>Navigate &gt; Primary FAT32 &gt; FAT1</code> button on the top pane. Here is the example from my flash drive:</p>
<p><img src="images/fat-fat-file.png" alt="fat-fat-file"></p>
<p>Discarding the media descriptor and FAT version (the first 8 bytes) in the picture above we can see several clusters, most of them containing EOF marker (<code>0xFFFFFF0F</code>). That means, most of the files occupy one cluster only. Clusters 2-12 are marked with green and orange rectangles for better accessibly. Cluster 13 is marked in red and its value is <code>0x014A</code> (<code>330</code>) after converting to little-endian. That means that cluster 13 is not the last one in the chain and the next cluster is cluster number 330.</p>
<p>Now, this is what a contiguous file would look like in FAT table (a file that occupies more than 1 cluster and the clusters following one another on disk):</p>
<p><img src="images/fat-fat-contig-file.png" alt="fat-fat-contig-file"></p>
<p>Let&rsquo;s read each 4 bytes starting from the cluster with the value <code>0x70 00 00 00</code>. This is the first cluster in the chain that points to the next cluster (<code>0x70</code> cluster, i.e. cluster 112 in decimal). Cluster 112 (<code>0x70</code>), the next one, points to the next cluster in the chain (<code>0x71</code>, i.e. 113) and so on and so forth. But as you may notice it&rsquo;s easy to note such chains.</p>
<p>To make it easier to read FAT32 table (which has 4 bytes for each entry), you may change view preferences in Active@Disk Editor (<code>File &gt; Preferences &gt; Disk Editor &gt; Bytes per line &gt; 4</code>).</p>
<h3 id="timestamps">Timestamps</h3>
<p>Local times, not UTC! For Last Accessed we only have date, no time!</p>
<p>Four bytes for date and time created (first two bytes for time 🕰 and the second two bytes for date 📆). The time bytes are first converted from the little-endian notation (two bytes flipped). In the example below, for the yellow short entry the created date and time <code>0x55 0x6E 0x31 0x53</code>. Bytes <code>0x55 0x6E</code> are for the time and <code>0x31 0x53</code> are for the date. Let&rsquo;s take the time bytes <code>0x55 0x6E</code>. Flip them to convert from the little-endian notation: <code>06E 0x55</code>. Convert each nibble to a binary value: <code>b0110</code>, <code>b1110</code>, <code>b0101</code>, <code>b0101</code>. Now, write them in a row and separate with the following template in mind: 5 bits - 6 bits - 5 bits: <code>b01101 b110010 b10101</code>. The first five bits are for hours, the next 6 bits are for minutes and the last ones are for seconds. Then, each value is converted into a decimal separately to get us 13 hrs, 50 mins and 21 seconds in the end (see the above picture only shows hours and minutes). For the date 📆 value the template is 7-4-5 but the process is the same.</p>
<p><img src="images/fat-entry-struct.png" alt="fat-entry-struct"></p>
<h3 id="fat-file-creation-and-deletion">FAT File Creation And Deletion</h3>
<h4 id="creating">Creating</h4>
<p>Steps that are taken when a file is created:</p>
<ol>
<li>A directory entry is created is written to the parent directory</li>
<li>Data is written to the first available cluster</li>
<li>Entries in the FAT1 and FAT2 are made for all the clusters used</li>
</ol>
<h4 id="deleting">Deleting</h4>
<p>Steps that are taken when a file is deleted:</p>
<ol>
<li>The first character of the directory entry is changed to <code>0xE5</code>.</li>
<li>The clusters in the FAT1 and FAT2 are filled with zeroes.</li>
<li>The data area remains unchanged (⚠️ data is still out there!).</li>
</ol>
<h3 id="exfat-structure">exFAT Structure</h3>
<p>Also consists of System (Boot sector, backup boot sector, FAT1) and Data areas. exFAT doesn&rsquo;t have FAT2.</p>
<h4 id="boot-record">Boot Record</h4>
<p>Located at sector <code>0</code> of the volume. It contains the information about the volume (as usual).</p>
<blockquote>
<p>⚠️ Offsets are relative to the start of the volume.</p>
</blockquote>
<p>In general, it looks very close to FAT32. Something new - <code>bytes per sector shift</code> (between 9 and 12) and <code>bytes per cluster shift</code> (~sectors per cluster, 0-25). The value in this field is the power to which we need raise 2 to get the result. For example, if the field <code>bytes per sector shift</code> is set to 9, we raise 2 to the power of 9 (<code>2^9 = 512</code>, which means each sector is 512 bytes long). The same math is applied to the <code>bytes per cluster shift </code> field.</p>
<h4 id="fat1">FAT1</h4>
<p>32-bit entries. Media descriptor is the same: <code>0xFF FF FF F8</code>. Only tracks file fragmentation and doesn&rsquo;t track file allocation (Bitmap is used for that instead)!</p>
<h4 id="root-directory-1">Root Directory</h4>
<p>Types of directory entries:</p>
<ul>
<li>volume label (critical primary), <code>0x83</code>. User-created name for the volume. ⚠️ <em>Must be there!</em></li>
<li>file directory (critical primary) 🍇. Tracks attributes, MAC times (UTC), ⚠️ <em>but doesn&rsquo;t point to the parent directory (no <code>..</code> entry like in FAT32)</em>. <code>0x85</code> - in use, <code>0x05</code> - free. ⚠️<em>All files will have this entry!</em></li>
<li>stream extension directory (critical secondary) 🍇. Size and start of the file. ⚠️ <em>Size of the filename is here (in characters)!</em> Starts with <code>0xC0</code> if in use, <code>0x40</code> if not. <code>Not FAT chain</code> - if set, it&rsquo;s not a fragmented file. Also, there are two interesting values: <code>Valid data length</code> (init size) and <code>Data length</code>. If, say a file was downloaded, FS will allocate certain amount of space. But if that download was interrupted, then the file won&rsquo;t occupy all the space, thus these two values will be different.</li>
<li>file name (critical secondary) 🍇. Unicode for file name. <code>0xC1</code> if in use, <code>0x41</code> if not. Up to 15 Unicode chars. Might be more than one (~like long file names in FAT, can be more than one entry in case it&rsquo;s a long name).</li>
<li>system files (critical primary)
<ul>
<li>Bitmap <code>0x81</code>. Usually starts at cluster 2.</li>
<li>Upcase <code>0x82</code>. Usually starts at cluster 4.</li>
</ul>
</li>
</ul>
<p>Entries mared with 🍇 are those, that make up a <strong>directory set</strong>. Below is the breakdown of a directory set. The first byte (<code>0x85</code> in this case) indicates that the file is currently in use. It could be <code>0x05</code> if it were deleted.</p>
<p>The next byte is the secondary count, which indicated how many other directory entries we have in this file directory entry set (❓). The next two bytes are for error checking and then the next two <code>0x3A 00</code> are attributes. The we have MAC times. We have last accesssed time, which we didn&rsquo;t in FAT32.</p>
<p><img src="images/exfat-dir-entry-set.jpg" alt="exfat-dir-entry-set"></p>
<h4 id="additional-files">Additional Files</h4>
<p>exFAT has two additional files that FAT32 does not. They probably come from the NTFS&hellip;: <code>Bitmap</code> and <code>Upcase</code> (table of Unicode chars, used to convert characters for searching).</p>
<blockquote>
<p>⚠️ Both files have an entry in the root directory, but don&rsquo;t have a filename.</p>
</blockquote>
<h3 id="timestamps-1">Timestamps</h3>
<p>UTC! The timezone offset is in 15mins increments (see a breakdown below). So, we have created, modified and last accessed date/times. Each of these timestamps will have a corresponding UTC offset in the file directory entry. It makes sense that these are always the same. In my case, <code>0xF4</code> <code>-2</code> in decimal, which would make a <code>UTC-2</code> (London timezone). We now know (in this case) that MAC times are for London timezone.</p>
<blockquote>
<p>⚠️ We have last accesssed <strong>time</strong>, which we didn&rsquo;t in FAT32.</p>
</blockquote>
<p>Below is the breakdown of how to convert a UTC byte into a human-readable value.</p>
<p><img src="images/exfat-utc.jpg" alt="exfat-utc"></p>
<h3 id="exfat-file-creation-and-deletion">exFAT File Creation and Deletion</h3>
<h4 id="creation">Creation</h4>
<ul>
<li><input disabled="" type="checkbox"> directory set created</li>
<li><input disabled="" type="checkbox"> bitmap for allocated clusters set to <code>1</code></li>
<li><input disabled="" type="checkbox"> FAT updated (if fragmented)</li>
<li><input disabled="" type="checkbox"> data written to the allocated clusters</li>
</ul>
<blockquote>
<p>🧪 Are the timestamps updated for a deleted file in the directory entry? exFAT, FAT32 and NTFS as well.</p>
</blockquote>
<h4 id="deletion">Deletion</h4>
<ul>
<li><input disabled="" type="checkbox"> first bytes of each entry in the directory entry set is set in a way to show the file is not in use (<code>05</code> for a file directory entry, <code>40</code> for stream <code>41</code> for filename entries).</li>
<li><input disabled="" type="checkbox"> bitmap entries for this file clusters are set to <code>0</code></li>
<li><input disabled="" type="checkbox"> FAT may or may not be zeroed out</li>
<li><input disabled="" type="checkbox"> file/dir contents remains there until and if is overwritten</li>
</ul>
<blockquote>
<p>⚠️ If the parent folder is deleted, the child entries remain unchanged.</p>
</blockquote>
<h2 id="extx">ExtX</h2>
<h3 id="2">2</h3>
<p>No journaling</p>
<h3 id="3">3</h3>
<p>Same but + journaling</p>
<h3 id="4">4</h3>
<p>New FS</p>
<h2 id="reiserfs">ReiserFS</h2>
<p>Allows storing multiple files in a single sector. exclamation mark ❗️Unique to this FS!</p>
<h2 id="xfs">XFS</h2>
<p>Good for multimedia files.</p>
<h2 id="hfs">HFS</h2>
<h2 id="hfs-1">HFS+</h2>
<p>Since 1998, since macOS 8.1. Was replaced by APFS.</p>
<p>Didn&rsquo;t <em>natively</em> support full disk encryption (FV2 was added later). Timestamps were only to-the-second. Support up to 4 billion files.</p>
<p><a href="https://developer.apple.com/library/archive/technotes/tn/tn1150.html">https://developer.apple.com/library/archive/technotes/tn/tn1150.html</a></p>
<ul>
<li>Supports large files</li>
<li>Efficient disk space usage</li>
<li>unicode for filenames</li>
<li>name forks</li>
<li>file compression</li>
<li>journaling</li>
<li>dynamic resizing, defragmentation</li>
<li>not only for MacOS</li>
</ul>
<h2 id="apfs">APFS</h2>
<p><a href="https://developer.apple.com/support/downloads/Apple-File-System-Reference.pdf">https://developer.apple.com/support/downloads/Apple-File-System-Reference.pdf</a></p>
<p><strong>Advantages over HFS+</strong>:</p>
<ul>
<li>
<p>Optimized for Flash/SSD Storage.</p>
</li>
<li>
<p>Full disk encryption is <em>natively</em> supported.</p>
</li>
<li>
<p>Snapshot support.</p>
</li>
<li>
<p>Timestamps are to-the-nanosecond.</p>
</li>
<li>
<p>9 quintillion files at most (18 zeroes).</p>
</li>
<li>
<p>Clones</p>
</li>
<li>
<p>Snapshots</p>
</li>
<li>
<p>Space sharing</p>
</li>
<li>
<p>encryption</p>
</li>
<li>
<p>crash protection</p>
</li>
<li>
<p>sparse files</p>
</li>
<li>
<p>fast directory resizing</p>
</li>
</ul>
<p>iOS has two partitions: system and user.</p>
<p>Full support since iOS 10.3 and macOS High Sierra (10.13).</p>
<p>SANS Poster <a href="https://sansorg.egnyte.com/dl/zngSJguNqj/?">APFS File System Format Reference Sheet</a> (SANS FOR518 Reference Sheet).</p>
<p>Apple 🍏. 2006 PowerPC -&gt; Intel. They also moved to GUID partitioning (GPT). GPT replaces MPT at the end of MBR. The main difference between them is that MPT can only define 4 primary partitions, while GPT can have</p>
<p>Partitions and volumes are slightly different than for other FS. When we see a APFS disk, think in terms of volumes.</p>
<p>There  are five entries (raws) there. One of them, the first, is most likely a general, main container. The other 4 are volumes: MacHD, Preboot, Recovery, VM (standard, but MacHD is usually named Macintosh HD).</p>
<p>The first one - container GUID. All the volumes have the same container GUID. Container GUID is similar to disk signature or the serial number that we find at offset 440 of the MBR when we are looking at HDDs from a Windows system.</p>
<p>APFS volumes are not fixed in size. Share space within a container. Unallocated space is pooled to all the volumes within. That&rsquo;s why when analysing volumes there is no way to tell, which volume this unallocated space originated from (unlike on Win).</p>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://eclecticlight.co/2019/12/18/making-sense-of-disk-utility-and-disk-structure-in-macos-10-13-10-15/">Making sense of Disk Utility and disk structure in macOS 10.13-10.15</a></li>
</ul>
<h3 id="timestamps-2">Timestamps</h3>
<p>📆 <code>Jan 1, 1970</code></p>
<h4 id="modified">Modified</h4>
<h4 id="created">Created</h4>
<h4 id="accessed">Accessed</h4>
<p>On macOS type <code>mount</code> in Terminal to get all the disks mounted with their corresponding attributes. If you see a <code>noatime</code> attribute, it means <em>Accessed</em> attribute is not updated for that volume.</p>
<h4 id="changed">Changed</h4>
<h4 id="added">Added</h4>
<p>Unique to APFS. Very useful for forensics since it differenciates between the file being actually created and it being copied from another media (USB, for example).</p>
<h3 id="metadata">Metadata</h3>
<h4 id="fsevents">FSEvents</h4>
<p>Like <code>$UsnJrnl</code>. ❗️It keeps track of file ids, which is useful for <strong>sequencing</strong> events. Can be found <code>/.fseventsd</code>. Lot&rsquo;s of gzip archives.</p>
<blockquote>
<p>🔍 However, I couldn&rsquo;t find it on my M1 (macOS Big Sur, 11.2.3). The daemon was running (checked with Activity Monitor). Grabbing the processes path on disk (search for <code>fseventsd</code>, double-click, choose <code>Sample</code> and get the path from the result)</p>
</blockquote>
<p><img src="images/fseventsd-path.png" alt="fseventsd-path"></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">python FSEParser_V3.3.py -s -t folder /.fseventsd -o /Users/sentinel/Desktop/FSEvents_Out
</code></pre></div><p><strong>Keywords</strong>: Mount/Volume, Safari/Chrome (web search), Renamed/.trash (trash).</p>
<p>Lot&rsquo;s of information, so, think well whether to process it or not, since it&rsquo;ll take time.</p>
<blockquote>
<p>⚠️ If you insert a FAT-formatted thumb drive into a macOS machine, it will create fervents.</p>
</blockquote>
<p><strong>Tools</strong> 🛠: FSEventsParser.</p>
<h2 id="ntfs">NTFS</h2>
<p>Developed in collaboration with IBM. POSIX compliant. Official docs for NTFS <a href="http://ntfs.com/ntfs-mft.htm">here</a>.</p>
<blockquote>
<p>⚠️ Everything is a file!</p>
<p>⚠️ All offsets are relative to the start of the data structures.</p>
</blockquote>
<p>Entire logical volume is a data erea (in contrast to FAT where there is a system area as well ❓).</p>
<h3 id="versions-1">Versions</h3>
<h4 id="v10">V1.0</h4>
<p>The first release of Windows NT 3.1. Windows XP and above. It allowed for data recovery, rollback (restore the system to the last stable state) and larger volumes. Windows 8 + faster data recovery and cross platform. Windows 10 + extended logging features.</p>
<blockquote>
<p>⚠️ Windows Vista and above can obly be installed on a NTFS volume!</p>
</blockquote>
<h4 id="v12">V1.2</h4>
<p>Windows NT 3.51, included admin controls, compressed files and User Access Control (recycle bin for each user and own account).</p>
<h3 id="structure">Structure</h3>
<h4 id="volume-boot-record-1">Volume Boot Record</h4>
<p>In the <code>$MFT</code> is represented as <code>$Boot</code>. It&rsquo;s located at the sector <code>0</code> of the volume (not physical disk!). Below is the VBR structure for NTFS. The most important entries for forensic purposes are highlighted.</p>
<p><img src="images/ntfs-boot-record-struct.png" alt="ntfs-boot-record-struct"></p>
<h4 id="mft">MFT</h4>
<p>The heart ♥️ of NTFS. Created once the disk/volume is formatted with NTFS. It&rsquo;s an index of every single file on disk (at least 1 entry of a file), including  NTFS metadata files (those that start with <code>$</code>). The first 26 records are for the system meta data files. Records 12-23 are reserved. Records 24-26 transaction log and error recovery. The first user-created file is usually at index 35.</p>
<p>Below is the full table of the files [<a href="https://flatcap.org/linux-ntfs/ntfs/files/index.html">6</a>].</p>
<table>
<thead>
<tr>
<th style="text-align:right">Inode</th>
<th style="text-align:left">Filename</th>
<th style="text-align:left">OS</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/mft.html">$MFT</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Master File Table - An index of every file</td>
</tr>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/mftmirr.html">$MFTMirr</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">A <strong>backup copy</strong> of the first 4 records of the MFT</td>
</tr>
<tr>
<td style="text-align:right">2</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/logfile.html">$LogFile</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Transactional logging file</td>
</tr>
<tr>
<td style="text-align:right">3</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/volume.html">$Volume</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Serial number, creation time, dirty flag</td>
</tr>
<tr>
<td style="text-align:right">4</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/attrdef.html">$AttrDef</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Attribute definitions</td>
</tr>
<tr>
<td style="text-align:right">5</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/dot.html">. (dot)</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Root directory of the disk</td>
</tr>
<tr>
<td style="text-align:right">6</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/bitmap.html">$Bitmap</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Contains volume&rsquo;s cluster map (in-use vs. free)</td>
</tr>
<tr>
<td style="text-align:right">7</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/boot.html">$Boot</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Boot record of the volume</td>
</tr>
<tr>
<td style="text-align:right">8</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/badclus.html">$BadClus</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Lists bad clusters on the volume</td>
</tr>
<tr>
<td style="text-align:right">9</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/quota.html">$Quota</a></td>
<td style="text-align:left">NT</td>
<td style="text-align:left">Quota information</td>
</tr>
<tr>
<td style="text-align:right">9</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/secure.html">$Secure</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Security descriptors used by the volume</td>
</tr>
<tr>
<td style="text-align:right">10</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/upcase.html">$UpCase</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">Table of uppercase characters used for collating</td>
</tr>
<tr>
<td style="text-align:right">11</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/extend.html">$Extend</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">A directory: $ObjId, $Quota, $Reparse, $UsnJrnl</td>
</tr>
<tr>
<td style="text-align:right">12-15</td>
<td style="text-align:left"><!-- raw HTML omitted --></td>
<td style="text-align:left"></td>
<td style="text-align:left">Marked as in use but empty</td>
</tr>
<tr>
<td style="text-align:right">16-23</td>
<td style="text-align:left"><!-- raw HTML omitted --></td>
<td style="text-align:left"></td>
<td style="text-align:left">Marked as unused</td>
</tr>
<tr>
<td style="text-align:right">Any (25)</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/objid.html">$ObjId</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Unique Ids given to every file</td>
</tr>
<tr>
<td style="text-align:right">Any (24)</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/quota.html">$Quota</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Quota information</td>
</tr>
<tr>
<td style="text-align:right">Any (26)</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/reparse.html">$Reparse</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Reparse point information</td>
</tr>
<tr>
<td style="text-align:right">Any</td>
<td style="text-align:left"><a href="https://flatcap.org/linux-ntfs/ntfs/files/usnjrnl.html">$UsnJrnl</a></td>
<td style="text-align:left">2K</td>
<td style="text-align:left">Journalling of Encryption (usually at <code>/$Extend</code> directory, see above)</td>
</tr>
</tbody>
</table>
<p>A MFT record contains the following info:</p>
<ul>
<li>file allocation status</li>
<li>file dates</li>
<li>file name</li>
<li>location</li>
</ul>
<p>Records start at index <code>0</code> (for the MFT record itself) and the rest are numbered sequencially. Each record is usually 1024 bytes. New records are created on a first-available basis, i.e. if a record was deleted (deallocated) it get overwritten once new one is created and the deallocated one is the first free index in the table.</p>
<p>A file record begins with a header (ASCII <code>FILE</code> or <code>BAAD</code> if it was corrupted). It contains info about the file. It&rsquo;s made up of attributes. Each of them contains specific information about the file record entry. Each record ends with a <code>0xFF FF FF FF</code>. It has a sequence numbere at offset <code>0x10</code> 2 bytes long, that&rsquo;s incremented each time the file is deleted (not allocated ❗️). At offset <code>0x16</code> there is an allocation status flags: <code>0x00</code> for deleted file, <code>0x01</code> for allocated one, <code>0x02</code> for deleted dir, <code>0x03</code> for allocated dir.</p>
<p>Following the header, there are four attributes (each consists of a header and contents):</p>
<p><strong>Standard attribute</strong>. Starts with <code>0x10</code>. Standard attribute (file permissions, timestamps, security and admin info). Below is the attribute highlighted. Note, that there are very useful timestamps: file created/modified, record changed and last access time. ⚠️ All UTC.</p>
<p><img src="images/ntfs-attr-10.png" alt="ntfs-attr-10"></p>
<p><strong>File name</strong>. Starts with <code>0x30</code>. Also has timestamps, but for the filename. The first 6 bytes are for the parent directory&rsquo;s MFT record (it&rsquo;s not a cluster number like in FAT). The timestamps below are for the filename changes, not the changes for the file itself. For the file relevant timestamps see the atrribute <code>0x10</code> (above). If the file is resident, its contents will be contained in the MFT itself (see below marked with a yellow rectangle). If the file is too big, there will be a <code>data run</code> instead (❓).</p>
<p><img src="images/ntfs-attr-30.png" alt="ntfs-attr-30"></p>
<p><strong>Data attribute</strong>. ⚠️ Yes, data is considered an attribute in NTFS. Starts with <code>0x80</code>.  Contains data itself or the pointer to its location (depending on the file size). If the file is small enough, its contents will be here (below, green area). In this case the file is called <em>resident</em> file. Whether it&rsquo;s a resident file or not, you can determine by the <em>non-resident</em> byte (marked with a red rectangle in the picture below). In the picture below it&rsquo;s <code>0x00</code>, which means the file <em>is</em> resident and its contents is in the MFT record (right below). Marked with a green rectangle it&rsquo;s the offset to the data, for resident files it&rsquo;s always <code>0x0018</code> (little-endian), since the start of the data section is in the attribute itself at the fixed place.</p>
<p><img src="images/ntfs-attr-80.png" alt="ntfs-attr-80"></p>
<p>In the picture below there is an example of a record for a bigger file. Its non-resident flag is set to <code>0x01</code> (marked with a purple rectangle), meaning the contents is somewhere else on disk. In order to find the file contents location we need to perform the following steps:</p>
<ul>
<li><input disabled="" type="checkbox"> get the offset to data runs, which contain directions to the contents location (pointer). In the picture below it&rsquo;s <code>0x0040</code> (little-endian). This offset is relative to the attribute start. So, we count <code>0x40</code> from the attribute start and get to the location marked with a dark-red rectangle: <code>21 10 89 09 00 00 00 00</code> (run list).</li>
<li><input disabled="" type="checkbox"> read the run list.</li>
</ul>
<p><img src="images/ntfs-nonresident-set.png" alt="ntfs-nonresident-set"></p>
<p>Now, what&rsquo;s a run list?</p>
<p><img src="images/ntfs-big-nonresident-run-list.png" alt="ntfs-big-nonresident-run-list"></p>
<p>In the picture below this structure is highlighted on the left and expalined on the right. The first byte is the run header, it tells the number of bytes, occupied by the run list. The second byte tells the length in clusters. The next two bytes are for the starting cluster number (<strong>signed</strong> 16-bit value). End the remaining 4 bytes of zeroes - end of run.</p>
<blockquote>
<p>⚠️ To interpret the run header, split the byte into two nibbles and add them together: <code>2</code> + <code>1</code> = <code>3</code>, meaning, in the example above the run list length is 3 bytes. The first nibble (<code>2</code>  in this example) tells that the size of the first cluster field is 2 bytes. The second nibble tells that the size of the cluster count field of 1 byte (<code>1</code>). Together combined it&rsquo;s 3. meaning that both cluster count and first cluster fields are 3 bytes long.</p>
</blockquote>
<p>If the file is fragmented, there will be more than 1 data run. If there are more than 1 data run, then each next first cluster field is relative to the previous one. For example, if the first cluster for the first fragment in the first data run was <code>0x42A9</code> (17065 in decimal), and the next first cluster for the next fragment in the next data run is <code>0xBFBF</code> (-16449 decimal) then in order to get the first cluster for the second fragment, we would substitute 16449 from 17065 which would give us 616 decimal value, which would be the first cluster of the second fragment [<a href="https://www.coursera.org/learn/windows-os-forensics/home/welcome">5</a>]. So, each value is relevant to the last piece. To get the first cluster of the next fragment you&rsquo;d add it&rsquo;s value to 616 and so on and so forth. Active@Disk Editor does that automatically.</p>
<p><strong>Object ID attribute</strong>. Starts with <code>0x40</code>. This attribute contains a GUID of a file.</p>
<p><img src="images/ntfs-attr-40.png" alt="ntfs-attr-40"></p>
<p><strong>Bitmap attribute</strong>. Starts with <code>0xE0</code>?<code>0xB0</code>?. ⁉️</p>
<h3 id="file-creation-and-deletion">File Creation and Deletion</h3>
<h4 id="creating-files">Creating Files</h4>
<p>Steps taken to create a file:</p>
<ul>
<li><input disabled="" type="checkbox"> A file record (<code>FILE</code>) is created in <code>$MFT</code></li>
<li><input disabled="" type="checkbox"> The bitmap for the $MFT is changed to indicate the record is allocated❓</li>
<li><input disabled="" type="checkbox"> The record header allocation flag shows it as an allocated file or directory</li>
<li><input disabled="" type="checkbox"> Attributes are written to the $MFT file record</li>
<li><input disabled="" type="checkbox"> If the data is non-resident, the $BitMap file is updated to represent the clusters allocated to store the data</li>
</ul>
<p>Go to &ldquo;Browse File Records&rdquo; on the top pane, choose the newly created file and see its attributes. The most important are sequence number and flags. I&rsquo;ve noticed that when I create and delete files several times, the MFT file record remains the same, the sequence number just gets incremented. That&rsquo;s because NTFS uses the first free record when the file is created. If you know at which sector a resident file was located before deletion, you can view its contents before it gets overwritten. The sector number is shown on the very rightmost bottom pane in Active@Disk Editor:</p>
<p><img src="images/ntfs-activediskedit-sector-createdfile.png" alt="ntfs-activediskedit-sector-createdfile"></p>
<h4 id="deleting-files">Deleting Files</h4>
<p>Steps taken:</p>
<ul>
<li><input disabled="" type="checkbox"> The record header sequence number (see above) is incremented</li>
<li><input disabled="" type="checkbox"> The record header allocation flag indicates a deleted file or dir</li>
<li><input disabled="" type="checkbox"> The bitmap for the MFT is changed to show this file/dir is unallocated</li>
<li><input disabled="" type="checkbox"> If the data is non-resident, the $BitMap file is updated to indicate the clusters are unallocated</li>
</ul>
<h3 id="timestamps-3">Timestamps</h3>
<p>📆 <code>Jan 1, 1601</code>. UTC?</p>
<p>Modified, Accessed, Created, MFT Modified.</p>
<p>Sources: <code>$Standart_Information</code>,  <code>$Filename</code>, <code>$I30_Index</code>.</p>
<p><strong>Modified</strong></p>
<p><strong>Created</strong></p>
<p><strong>Accessed</strong></p>
<p>Sometimes this option might be turned off. To check, check the <code>NTFSLastAccessUpdate</code> key at <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem</code> in Windows Registry.</p>
<p>Can be changed with <code>fsutils</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">fsutil behavior <span class="nb">set</span> disablelastaccess <span class="o">[</span>0<span class="p">|</span>1<span class="p">|</span>2<span class="p">|</span>3<span class="o">]</span>
<span class="c1"># restart the PC</span>
</code></pre></div><table>
<thead>
<tr>
<th><strong>Value</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>User Managed, Last Access Time Updates Enabled</td>
</tr>
<tr>
<td>❗️<strong>1</strong></td>
<td>❗️<strong>User Managed, Last Access Time Updates Disabled</strong></td>
</tr>
<tr>
<td><strong>2</strong> (default)</td>
<td>System Managed, Last Access Time Updates Enabled</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>System Managed, Last Access Time Updates Disabled</td>
</tr>
</tbody>
</table>
<p><strong>Changed</strong></p>
<h3 id="ntfs-metadata">NTFS Metadata</h3>
<p>These files cannot be opened from the user space, it&rsquo;s maintained by NTFS driver. So, even if shown by Directory Snoop, you can&rsquo;t open it on a live system. You can view the hex data though in DS-NTFS. Another option would be to make a disk image and carve the files. View some more information here [<a href="http://blog.opensecurityresearch.com/2011/10/how-to-acquire-locked-files-from.html">3</a>].</p>
<h4 id="extendusnjrnl"><code>\$Extend\$UsnJrnl</code></h4>
<p>Journal change log for NTFS system. EVERYTHING! File and directory deletion, creation, encryption.</p>
<h4 id="logfile"><code>$LogFile</code></h4>
<p>It&rsquo;s a transaction journal of $MFT. Very similar to <code>$UsnJrnl</code>, but lives less. Tracks file creation, modification, renaming and deletion. May not exist, but since Windows Vista <code>$UsnJrnl</code> is there <strong>by default</strong>.</p>
<h2 id="references">References</h2>
<p>[<a href="">1</a>] Windows OS file system for 27 years</p>
<p>[<a href="https://www.magnetforensics.com/resources/demystifying-mac-investigations-mac-vs-windows-artifacts-comparison/?submission=https://go.magnetforensics.com/l/52162/2020-08-25/kqxr57">2</a>] Demystifying Mac Investigations: Mac vs. Windows Artifacts Comparison, Magnet Webinar</p>
<p>NTFS file system, Suhanov&rsquo;s blog: [<a href="https://dfir.ru/2021/07/15/playing-with-case-insensitive-file-names/">1</a>] Playing with case-insensitive file names, [<a href="https://dfir.ru/2021/01/10/standard_information-vs-file_name/">2</a>] $STANDARD_INFORMATION vs. $FILE_NAME, [<a href="https://dfir.ru/2020/10/03/exporting-registry-hives-from-a-live-system/">3</a>] Exporting registry hives from a live system, [<a href="https://dfir.ru/2020/06/12/trim-and-unallocated-space/">4</a>] Trim and unallocated space, [<a href="https://dfir.ru/2020/05/23/onedrive-and-ntfs-last-access-timestamps/">5</a>] OneDrive and NTFS last access timestamps, [<a href="https://dfir.ru/2020/05/18/deceptive-ntfs-short-file-names/">6</a>] Deceptive NTFS short file names, [<a href="https://dfir.ru/2020/02/23/you-write-to-a-logical-drive-when-you-read-from-it/">7</a>] You write to a logical drive when you read from it, [<a href="https://dfir.ru/2019/04/23/ntfs-large-clusters/">8</a>] NTFS: large clusters, [<a href="https://dfir.ru/2019/02/28/ntfs-unallocated-data-marked-as-allocated/">9</a>] NTFS: unallocated data marked as allocated, [<a href="https://dfir.ru/2019/02/16/how-the-logfile-works/">10</a>] How the $LogFile works?, [<a href="https://dfir.ru/2019/01/19/ntfs-today/">11</a>] NTFS today, [<a href="https://dfir.ru/2019/01/08/hibernation-and-ntfs/">12</a>] Hibernation and NTFS, [<a href="https://dfir.ru/2018/12/16/the-inconsistency-of-last-access-timestamps/">13</a>] The (in)consistency of last access timestamps, [<a href="https://dfir.ru/2018/12/08/the-last-access-updates-are-almost-back/">14</a>] The “Last Access” updates are almost back.</p>
<p>[<a href="http://blog.opensecurityresearch.com/2011/10/how-to-acquire-locked-files-from.html">3</a>] How to acquire &ldquo;locked&rdquo; files from a running Windows system, By Pär Österberg Medina</p>
<p>[<a href="https://stackoverflow.com/questions/19499257/opening-mft-file-causes-access-denied-even-if-run-as-administrator">4</a>] Opening $MFT file causes Access denied even if run as administrator, StackOverflow, answered by <a href="https://stackoverflow.com/users/175201/eric-brown">Eric Brown</a></p>
<p>[<a href="https://www.coursera.org/learn/windows-os-forensics/home/welcome">5</a>] Digital Forensics Specialization, Windows OS Forensics course, InfoSec Institute, Coursera</p>
<p>[<a href="https://flatcap.org/linux-ntfs/ntfs/files/index.html">6</a>] NTFS Documentation</p>
<p>[<a href="http://www.cs.fsu.edu/~cop4610t/lectures/project3/Week11/Slides_week11.pdf">7</a>] About FAT32</p>

  </div>
</article>
</div>
</div>

        </div>
      </div>
    </div>
    
  </div>

  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            <li class="zerostatic"><a href="https://www.zerostatic.io">www.zerostatic.io</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.1237ff71925bb8625c97a9af8db4c54525258bedfd7c47493daaff723bea755e.js"></script>
  

  
  
  
    
  


</body>

</html>
